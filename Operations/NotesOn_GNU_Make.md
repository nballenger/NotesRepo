# Notes on GNU make

http://www.gnu.org/software/make/manual/make.html

## Overview of make

## 2: An Introduction to Makefiles

### 2.1 What a rule looks like

* Simple makefiles are made of 'rules' with the form:

```Makefile
target ... : prerequisites ...
        recipe
        ...
        ...
```

* Target is the name of a file generated by a program, or the name of an action to carry out, like ``clean``
* Prerequisite is a file used as input to create the target
* Recipe is an action make carries out.
* Every recipe line must have a tab at the start.
* A rule explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target.
* A rule can also explain how and when to carry out an action.

### 2.2 A Simple Makefile

```Makefile
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c

kbd.o : kbd.c defs.h command.h
        cc -c command.c

display.o : display.c defs.h buffer.h
        cc -c display.c

insert.o : insert.c defs.h buffer.h
        cc -c insert.c

search.o : search.c defs.h buffer.h
        cc -c search.c

files.o : files.c defs.h buffer.h command.h
        cc -c files.c

utils.o : utils.c defs.h
        cc -c utils.c

clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```

* Edit command relies on the other stuff, which will be rebuilt if needed
* Calling make by itself will create the ``edit`` executable
* To call the clean action, do ``make clean``
* Targets that don't refer to a file are 'phony targets'

### 2.3 How make processes a makefile

* By default make starts with the first target that doesn't start with a period, called the 'default goal'
* You can also set the ``.DEFAULT_GOAL`` variable
* Before the default goal can be processed all its prerequisites must be checked
* After recompiling any prerequisite file newer than the target, the target will be relinked if it does not exist, or if any prerequisites were newer.

### 2.4 Variables make makefiles simpler

* Variables let you define a text string once and substitute it later
* Standard for every makefile to have a variable like OBJECTS, that's a list of all object file names
* Ex:

```Makefile
OBJECTS = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(OBJECTS)
        cc -o edit $(OBJECTS)

[...]

clean : 
        rm edit $(OBJECTS)
```

### 2.5 Letting make deduce the recipes

* There's an implicit rule for updating a .o file from a .c file with cc -c
* Ex:

```Makefile
main.o : defs.h
kbd.o : defs.h command.h
[...]
```

### 2.6 Another Style of Makefile

* There's a way to do it if all the objects are created by implicit rules

### 2.7 Rules for Cleaning the Directory

* Clean is a common action. Simplest:

```
clean:
        rm edit $(OBJECTS)
```

* Version with more complicated rules, which makes sure the makefile doesn't get confused by an actual file called ``clean``, and makes it continue even with errors from ``rm``

```
.PHONY : clean
clean :
        -rm edit $(OBJECTS)
```

* Don't put that at the beginning, you don't want it to be the default rule

## 3: Writing Makefiles

### What Makefiles Contain

* 5 kinds of things:
    * Explicit rule - when and how to remake one or more target files. Lists prerequisite files, may also give a recipe to use to create/update targets
    * Implicit rule - when/how to remake based on file name
    * Variable definition - stores string into a var
    * Directive - instruction to do something like:
        * Reading another makefile
        * Deciding whether to use or ignore a part of the makefile
        * Defining a variable from a verbatim string with multiple lines
    * # in a line starts a comment

#### 3.1.1 Splitting Long Lines

* Newline char marks the end of a statement
* Escape with backslash character to get multi-line

### What Name to Give Your Makefile

* Call it ``Makefile``

### 3.3 Including Other Makefiles

* The ``include`` directive: ``include filename1 filename2 shellGlob``
* Extra spaces are allowed and ignored at the beginning of the line
* First character must not be a tab, or it's treated as a recipe
* When processing hits an include, it pauses until file content is processed
* If you want it to ignore a makefile that doesn't exist or can't be remade, use the ``-include`` directive instead of ``include``

### 3.4 The Variable MAKEFILES

* If ``MAKEFILES`` is defined, make takes the value as a list of whitespace separated names of additional makefiles to read before the others

### 4.6 Phony Targets

* Just a name for a recipe to be executed when you make an explicit request.
* Explicitly declare the target to be phony by making it a prereq of the special target .PHONY



## 6: How to use Variables

* Names can be any sequence of characters without : # = \w
* Names are case sensitive
* UC for parameters that control implicit rules or overrideable by user
* LC for parameters used internally in the makefile

### 6.1 Basics of Variable References

* Substitution: ``$(varname)`` or ``${varname}``
* Escaped literal dollar sign: ``$$``
* References done by strict text substitution

### 6.2 The Two Flavors of Variables

* 'recursively expanded' variable - defined by lines using ``=``, or by the ``define`` directive
* Value is used verbatim, if it contains references to other variables, those are expanded whenever this var is substituted
* You cannot append anything to the end of this variable type: ``X = $(X) foo`` causes an infinite loop
* Functions referenced in the definition of the variable will be executed every time the variable is expanded
* Other flavor: 'simply expanded' variables - defined by lines using ``:=`` or ``::=``
* Value is scanned once and for all, expanding any referenes to other variables and functions, when the variable is defined
* Contains only their value at the time of definition
* adding a comment after a definition will cause the whitespace between the last character and the hash mark to be included in the string

### 6.3 Advanced Features for Reference to Variables

#### 6.3.1 Substitution References

* Substitutes the value of a variable with alterations you specify
* Takes the form ``$(var:a=b)`` or ``${var:a=b}``
* That means "take the value of 'var' and replace every a at the end of a word with b in that value, and substitute the resulting string"

#### 6.3.2 Computed Variable Names
