# Notes on post 'Demystifying Schemas & search_path through Examples'

By Jonathan S. Katz, March, 2018

From [https://info.crunchydata.com/blog/demystifying-schemas-search_path-through-examples](https://info.crunchydata.com/blog/demystifying-schemas-search_path-through-examples)

Want to look into what schemas are in postgres, how they are used under normal operations, and how to investigate schemas to look for suspicious functions.

## Setup

* Three user accounts: superuser, alice, bob

    ```bash
    createuser alice
    createuser bob
    ```

* alice and bob should have no special status or permissions, don't need pw
* If you get confused about who you're running as, use `SELECT SESSION_USER;`
* Create a database: `createdb -O alice theworld`
* Open terminals and connecto to `theworld` as alice and bob
* As alice, create a table:

    ```SQL
    CREATE TABLE vegetables (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        vegetable_name VARCHAR(255) NOT NULL UNIQUE
    );
    ```

* Running `\dt` should show you that table, as it has been created in the `public` schema of `theworld` database.
* It's equivalent to running `CREATE TABLE public.vegetables...`
* You don't have to, because your current schema is based on the search_path
* When pg gets an unqualified name, it uses search_path to resolve it, in order
* `"$user"` resolves to 'if there is a schema matching the value of `SELECT SESSION_USER;`, look in that
* search_path can be set per transaction, per session, or as a db config setting
* Execute as alice:

    ```SQL
    INSERT INTO vegetables (vegetable_name)
    VALUES ('asparagus'), ('broccoli'), ('eggplant');
    ```

* The search_path is examined, no schema named `alice` exists, so the insert is performed into `public.vegetables`.

### Quick Digreesion: Qualified Object Names

* Qualified names are of the form `database.schema.object`
* The above table would be `theworld.public.vegetables`
* Create a new db: `createdb -O alice newworld`
* Connecting to `newworld` and attempting to query the vegetables table produces:

    ```
    theworld=> \c newworld
    You are now connected to database "newworld" as user "alice".
    newworld=> select * from theworld.public.vegetables;
    ERROR:  cross-database references are not implemented: "theworld.public.vegetables"
    LINE 1: select * from theworld.public.vegetables;
    ```

* Cross database queries are not supported by postgres out of the box.

## What about bob? Multiple users and the public schema

* Running `\dt` as bob (connected to `theworld`) will show vegetables, because any user that can connect to the database has access to the public schema
* However, having access to the public schema doesn't mean bob can interact with all objects in that schema
* Attempting to run `SELECT * FROM vegetables;` as bob results in `ERROR:  permission denied for relation vegetables`
* The owner of the vegetables table, alice, did not GRANT any permissions to bob, and so he can't look inside it
* Bob can create his own objects in the public schema:

    ```
    CREATE TABLE fruits (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        fruit_name VARCHAR(255) NOT NULL UNIQUE
    );

    INSERT INTO fruits (fruit_name)
    VALUES ('apple'), ('banana'), ('pear');
    ```

* Bob can select from the table, but alice cannot (though alice can see it and its owner listed with `\dt`)

## Functions and the public schema

* As alice, create a function to cube integers:

    ```
    CREATE OR REPLACE FUNCTION cube(int)
    RETURNS int
    AS $$
        SELECT $1 * $1 * $1;
    $$ LANGUAGE SQL IMMUTABLE;
    ```

* That function now shows up in the public schema:

    ```
    theworld=> \df
                            List of functions
     Schema | Name | Result data type | Argument data types |  Type  
    --------+------+------------------+---------------------+--------
     public | cube | integer          | integer             | normal
    ```

* Alice can run the function, but bob can ALSO run the function!
* By default, when a function is created it is executable by all users with the USAGE permission in that schema
* The function may not execute properly due to underlying permissions of objects referenced in the function. For example, if alice creates:

    ```
    CREATE OR REPLACE FUNCTION reverse_all()
    RETURNS TABLE(vegetable_name text)
    AS $$
        SELECT reverse(vegetable_name)
        FROM vegetables;
    $$ LANGUAGE SQL STABLE;
    ```

* Alice can run the function, but if bob runs it, it raises `permission denied for relation vegetables`
* Bob can execute the function, but it can't run successfully given his permissions
* Note that `reverse()` is unqualified, and exists in the `pg_catalog` schema. `pg_catalog` is implicitly prepended to `search_path`
* To see all `pg_catalog` functions, use `\df pg_catalog.*`

## Creating and managing schemas

### Creating a "$user" schema

* As alice, run: `CREATE SCHEMA alice;`
* Now create a table called `fruits`, using the same create statement as bob used
* Having done so, you can now see:

    ```
    theworld=> \dt
              List of relations
     Schema |    Name    | Type  | Owner 
    --------+------------+-------+-------
     alice  | fruits     | table | alice
     public | vegetables | table | alice
    ```

* Note that `public.fruits` does not show up now, because based on search_path precedence the name is resolved to the "$user" schema `alice`
* To specifically see tables in `public`, use `\dt public.*`
* Now, as alice, run:

    ```
    INSERT INTO fruits (fruit_name) 
    VALUES ('grape'), ('kiwi'), ('orange');
    SELECT * FROM fruits;
    ```

* Doing so runs the insert to `alice.fruits` based on search_path resolution order
* Running `\dt` as bob will still show only his fruits table, in the public schema--he has to run `\dt alice.*` to see the fruits table in the alice schema
* Bob can also inspect alice's table structure with `\d alice.fruits`

## Schemas outside of the search_path

* As alice, create a new schema: `CREATE SCHEMA animals;` but do not add it to the search_path
* Create a table in animals:

    ```
    CREATE TABLE animals.fish (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        fish_name varchar(255)
    );
    INSERT INTO animals.fish (fish_name) 
    VALUES ('trout'), ('grouper'), ('salmon');
    ```

* As alice, running `SELECT * FROM fish;` raises `ERROR:  relation "fish" does not exist` because `animals` is not in `search_path`
* Running `SELECT * FROM animals.fish;` succeeds for alice
* If bob tries the same it fails, because he doesn't have access to the `animals` schema
* Alice can grant select to bob for the animals schema:

    ```SQL
    GRANT SELECT ON ALL TABLES IN SCHEMA animals TO bob;
    ```

* However, if alice does and bob tries to select from animals.fish, it still fails, because alice has to give bob USAGE on animals:

    ```SQL
    GRANT USAGE ON SCHEMA animals TO bob;
    ```

## Functions in schemas outside the search path

* Try this as bob:

    ```
    CREATE FUNCTION animals.reverse_all()
    RETURNS TABLE(fish_name text)
    AS $$
        SELECT reverse(fish_name) FROM fish;
    $$ LANGUAGE SQL STABLE;
    ```

* Fails with `ERROR:  permission denied for schema animals`
* Alice gave USAGE and SELECT, but not CREATE
* As alice, run `GRANT CREATE ON SCHEMA animals TO bob;`
* Now as bob try recreating the function--it fails with `ERROR:  relation "fish" does not exist` because animals is not in bob's search path
* Two ways to resolve:
    * SET the search path for the function:

        ```SQL
        CREATE FUNCTION animals.reverse_all()
        RETURNS TABLE(fish_name text)
        AS $$
            SELECT reverse(fish_name) FROM fish;
        $$ LANGUAGE SQL STABLE
        SET search_path = 'animals';
        ```

    * Or use the qualified object name:

        ```SQL
        CREATE FUNCTION animals.reverse_all()
        RETURNS TABLE(fish_name text)
        AS $$
            SELECT reverse(fish_name) FROM animals.fish;
        $$ LANGUAGE SQL STABLE;
        ```
