++++ C++ CHEATSHEET ++++

Compiler Declarations:

Using and Namespaces:
    You can declare a namespace like this:
        namespace myglobals {
            int cat;
            string dog = "bow wow";
        }
    Fully qualified names are things like myglobals::cat
    If you 'use' a namespace, like:
        using std::string;
        using namespace myglobals;
    you don't have to use fully qualified names
    
Scope rules:
    Local scope is block scope
    Global scope is outside any block

Constants and Typedef:
    Adding 'const' to a declaration makes an immutable variable
    Adding 'typedef' to a declaration aliases a type name
    Example:
        const double PI = 3.14159265;
        typedef char* BufferPtr;        // pointer to char
        typedef double Coordinate;      // Coordinate is a double

Fundamental Types:
    bool                true|false
    char                8 bit (implementation dependent)
    short               at least 16 bits
    int                 at least 32 bits
    long                at least 32 bits
    enum                a set of discrete values, int associated
    float               bit size not set, double by default
    double              bit size not set
    
Pointers and References
    Given a type T, the type T* denotes a pointer to a var of type T
    & is the address-of operator--if x is an int, &x is x's mem addr
    Dereferencing is done with *:
        if q is a pointer to an integer:    int* q
        and we then set q to &x:            q = &x
        we can access x's value with:       *q
    A pointer that points at nothing is a 'null' pointer
    When declaring pointers, remember * binds to the variable:
        int* x, y, z;  // same as int* x; int y; int z;
        
    Given a type T, the notation T& indicates a reference to
        an object of type T
    References cannot be NULL, must refer to a variable
    Must be initialized on declaration
    Access is treated like access to the underlying object
        string a = "A";
        string& b = a;
        b = "c";            // a is now "c"
        
        
Arrays
    Given a type T and a constant N, a variable of type T[N] holds
        an array of N elements, each of type T
    Arrays are 0 indexed with integer values
    The size of an array cannot be changed after definition
    The [] operator does no run time checking for index out of bounds
    Two dimensional arrays are an "array of arrays":    
        int A[15][30]; // declares a 30 x 15 array of arrays
    The name of an array is a pointer to the first element in it
    
Strings
    String literals are a fixed length array of charters ending
        with the null character, making them C-style strings
    STL strings come from <string>
    STL strings can be input and output with >> and <<
    
Structs
    An aggregation of unique elements
    May be of different types
    Defined with:
    
        struct StructName {
            datatype    membername_A;
            datatype    membername_B;
        }
        
        StructName structvar = { "A", "B" };
        structvar.membername_A = "C";
        
Dynamic Memory and 'new'
    C++ runtime maintains a free store of memory
    The 'new' operator allocates out of the free store
    Used for creating new objects
    Memory reclaimed by calling delete on the obj
    Example:
    
        T *t;
        t = new T;
        t->name = "Bob";
        t->bday = "2012-10-10";
        delete t;
        
    Arrays can be allocated with 'new':
    
        char* buffer = new char[500];
        buffer[3] = 'a';
        delete [] buffer;               // note [] for array delete
        

Operators and Expressions:
    Arithmetic: +           - * / %
    Unary:                  - +
    Pre/post increment:     ++ --
    Relational:             < > <= >= == !=
    Logical:                ! && ||
    Bitwise:                ~ & ^ | << >>
    Assignment:             = += -= *= /= %=
    Class scope resolution: class_name::member
    Namespace resolution:   namespace::member
    Ternary:                bool ? if_true : if_false
    Stream input:           stream >> var
    Stream output:          stream << exp
    
Casting:
    C-Style casting:                (T)exp
    C++ functional cast:            T(exp)

    Cast ops that make the safety explicit:
        static_cast
        dynamic_cast
        const_cast
        reinterpret_cast
        
    Syntax:                 static_cast <desired_type> (expression)
        
    
Control Flow:

    if (condition)
        true_statement
    else if (condition)
        else if statement
    else
        else statement
        
        
    char command;
    cin >> command;
    switch (command) {
        case 'I':
            editInsert();
            break;
        case 'D':
            editDelete();
            break;
        case 'R':
            editReplace();
            break;
        default:
            cout << "Unrecognized command\n";
            break;
    }
    
    
    while (condition)
        loop_body
        
    do
        loop_body
    while (condition)
    
    
    for (initialization; condition; increment)
        loop_body
        
    const int NUM_ELEMENTS = 100;
    double b[NUM_ELEMENTS];
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        if (b[i] > 0)
            cout << b[i] << '\n';
    }
    

Function Declaration and Definition

    bool evenSum(int a[], int n);       // declaration
    
    bool evenSum(int a[], int n) {      // definition
        int sum = 0;
        for (int i = 0; i < n; i++)
            sum += a[i];
        return (sum % 2) == 0;
    }
    
    
Passing Arguments
    By default, args are passed by value, not reference:
    
        void f(int value, int& ref) {
            value++;                    // no effect on actual argument
            ref++;                      // modifies actual argument
            cout << value << endl;
            cout << ref << endl;
        }    
    
    Passing a structure or class by value makes a (possibly large) copy
    Passing an arg as a constant reference makes it immutable inside the fn:
    
        void someFunction(const &Passenger pass) {
            pass.name = "new name";         // ILLEGAL--pass is declared const
        }    
        
    When an array is passed, it's converted to a pointer to its initial element
    So T[] is converted to T*
    
    
Function Overloading

    void print (int x) { cout << x; }
    
    void print (const Passenger& pass) {
        cout << pass.name << " " << pass.mealPref;
        if (pass.isFreqFlyer)
            cout << " " << pass.freqFlyerNo;
    }
    

Operator Overloading

    // Example of overloading the equality operator:            
    bool operator==(const Passenger& x, const Passenger& y) {
        return x.name        == y.name
            && x.mealPref    == y.mealPref
            && x.isFreqFlyer == y.isFreqFlyer
            && x.freqFlyerNo == y.freqFlyerNo;
    }
    
    
Inline Functions

    Hint to the compiler to expand the function code in place 
        rather than using call-return mechanism
        
    Example: inline int min (int x, int y) { return (x < y ? x : y); }