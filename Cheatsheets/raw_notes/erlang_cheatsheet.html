<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Erlang Cheatsheet</title>
        <style type="text/css">
        table { border-collapse: collapse; }
        th, td { border: 1px solid #999999; padding: 8px; }
        pre { background-color: silver; padding: 8px; }
        </style>
    </head>
    <body>
        <h2>Executables</h2>
        <table>
            <tr>
                <th><code>erl</code></th>
                <td>Interpreter / shell</td>
            </tr>
            <tr>
                <th><code>erlc</code></th>
                <td>Compiler</td>
            </tr>
        </table>

        <h2>Shell Commands</h2>
        <table>
            <tr>
                <th><code>q().</code></th>
                <td>Quit the shell.</td>
            </tr>
            <tr>
                <th><code>^G</code></th>
                <td>Enter the switch command.</td>
            </tr>
            <tr>
                <th><code>^G i &lt;enter&gt; c &lt;enter&gt;</code></th>
                <td>Sequence to interrupt the current job and rejoin the shell.</td>
            </tr>
        </table>

        <h2>Operators</h2>
        <table> 
            <tr>
                <th>Symbols</th>
                <th>Definition</th>
                <th>Example(s)</th>
            </tr>
            <tr>
                <th><code>+<br>-<br>*<br>/</code></th>
                <td>Numeric</td>
                <td>
<pre>1&gt; 2 + 2.                % Numeric addition
4
2&gt; 2 - 2.                % Numeric subtraction
0
3&gt; 2 * 2.                % Numeric multiplication
4
4&gt; 2 / 2.                % Numeric division</pre>
                        </td>
            </tr>
            <tr>
                <th><code>div<br>rem</code></th>
                <td>Integer-returning numeric</td>
                <td>
<pre>5&gt; 5 div 2.              % Integer returning division
2
6&gt; 5 rem 2.              % Integer returning modulo
1 </pre>
                </td>
            </tr>
            <tr>
                <th><code>=</code></th>
                <td>Assignment, Equality test with non-boolean return</td>
                <td>
<pre>1&gt; SomeVar = 100.        % SomeVar is unbound, so assignment happens
100
2&gt; SomeVar = 5.          % A bound variable CANNOT be rebound.
** exception error: no match of right hand side value 5
3&gt; SomeVar = 50 + 50.    % Bound variables can take part in true statements.
100
4&gt; A = B = C = 1.        % Multiple assignment is allowed.</pre>
                </td>
            </tr>
            <tr>
                <th><code>=:=<br>=/=<br>==<br>/=</code></th>
                <td>Equality Tests</td>
                <td>
<pre>
1&gt; 1 =:= 1.              % Equality
true
2&gt; '1' =:= 1.
false
3&gt; 1.0 =:= 1.
false
4&gt; 1 =/= 1.              % Inequality
false
5&gt; 1.0 =/= 1.
true
6&gt; 1 == 1.               % Type-safe equality
true
7&gt; 1.0 == 1.
true
8&gt; 1 /= 1.               % Type-safe inequality
false
9&gt; 1.0 /= 1.
false
10&gt; '1' == 1.            % Type is not dynamic.
false
</pre>
                </td>
            </tr>
            <tr>
                <th><code>&lt;<br>&gt;<br>&gt;=<br>=&lt;</code></th>
                <td>Comparison Tests<br><small>Note that you can compare anything with anything else.<br>Type comparisons follow this inequality:</small><br><code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</code></td>
                <td>
<pre>
1&gt; 1 &lt; 2.                 % Less than
true
2&gt; 1 &gt; 2.                 % Greater than
false
3&gt; 1 =&lt; 2.                % Less than or equal to (NOTE ORDER OF SYMBOLS)
true
4&gt; 1 &gt;= 2.                % Greater than or equal to
false
</pre>
                </td>
            </tr>
            <tr>
                <th><code>and<br>or<br>xor<br>not<br>andalso<br>orelse<br></code></th>
                <td>Boolean</td>
                <td>
<pre>
% and/or always evaluate both sides of the statement
1&gt; true and true.            % true
2&gt; true and false.           % false
3&gt; false and false.          % false

4&gt; true or true.             % true
5&gt; true or false.            % true
6&gt; false or false.           % false

7&gt; true xor true.            % false
8&gt; true xor false.           % true
9&gt; false xor false.          % false

10&gt; not true.                % false
11&gt; not false.               % true

% andalso/orelse only evaluate the right side if necessary
12&gt; true andalso true.       % true
13&gt; true andalso false.      % false
14&gt; false andalso false.     % false

15&gt; true orelse true.        % true
16&gt; true orelse false.       % true
17&gt; false orelse false.      % false
</pre>          </td>
            </tr>
            <tr>
                <th><code>Base#Value</code></th>
                <td>Number in specific base</td>
                <td>
<pre>
1&gt; 2#10101010.
170
2&gt; 8#0677.
447
3&gt; 16#AE.
174
</pre>
                </td>
            </tr>
        </table>

        <h2>Data Types</h2>
        <table>
            <tr>
                <th>Numbers</th>
                <td>
                    <ul>
                        <li>Erlang is agnostic about floats versus integers--both are supported for arithmetic.</li>
                        <li>For integer-to-integer division and modulo, make sure to use the <code>div</code> and <code>rem</code> operators.</li>
                        <li>Arbitrary bases up to 256 are supported with <code>Base#Value</code> syntax.</li>
                    </ul>
                </td>
                <td>
<pre>
1&gt; 2 + 15.
17
2&gt; 49 * 100.
4900
3&gt; 1892 - 1472.
420
4&gt; 5 / 2.
2.5
5&gt; 5 div 2.
2
6&gt; 5 rem 2.
1
7&gt; 2#101010.
42
8&gt; 8#0677.
447
9&gt; 16#AE.
174
</pre>
                </td>
            </tr>
            <tr>
                <th>Atoms</th>
                <td>
                    <ul>
                        <li>Atoms are constants whose only value is their own name.</li>
                        <li>They can be single words, or a series of words in single quotes.</li>
                        <li>If they are a word, they must begin with a lower case letter.</li>
                        <li>They may contain underscores and @ signs.</li>
                        <li>They are stored in the 'atom table', which is not garbage collected. Don't generate them dynamically or you'll run out of memory.</li>
                    </ul>
                </td>
                <td>
<pre>
1&gt; atom.
atom
2&gt; atoms_rule.
atoms_rule
3&gt; atoms_rule@erlang.
atoms_rule@erlang
4&gt; 'Atoms can be cheated!'.
'Atoms can be cheated!'
5&gt; atom = 'atom'.
atom
</pre>
                </td>
            </tr>
            <tr>
                <th>Tuples</th>
                <td>
                    <ul>
                        <li>A tuple groups a set of terms.</li>
                        <li>They appear inside curly braces: <code>{ }</code>.</li>
                        <li>A tuple can contain data of any type.</li>
                        <li>A tuple with an atom followed by one element is a 'tagged tuple.'</li>
                    </ul>
                </td>
                <td>
<pre>
1&gt; Point = {4,5}.
{4,5}
2&gt; {X,Y} = Point.
{4,5}
3&gt; X.
4
4&gt; {point, {X,Y}}.
{point,{4,5}}
</pre>
                </td>
            </tr>
            <tr>
                <th>Lists</th>
                <td>
                    <ul>
                        <li>Lists are ordered groupings that can contain any kind of data.</li>
                        <li>Lists appear inside brackets: <code>[ ]</code>.</li>
                        <li>Lists and strings are the same thing, and lists that contain numbers will print as strings if they do not contain any items which cannot be a numeric representation of a character.</li>
                        <li>Lists are combined with the <code>++</code> operator:
<pre>5&gt; [1,2,3] ++ [4,5].
[1,2,3,4,5]</pre></li>
                        <li>Items are removed from a list with <code>--</code>:
<pre>6&gt; [2,4,2] -- [2,4].
[2]</pre>
                        </li>
                        <li><code>++</code> and <code>--</code> are right associative</li>
                        <li>First element of a list is the 'head', the rest is the 'tail'</li>
                        <li><code>hd(list)</code> and <code>tl(list)</code> get them, respectively</li>
                        <li>Shortcut for adding a new head to a list:
<pre>
List = [2,3,4].
NewList = [1|List].   % NewList now = [1,2,3,4]
</pre>
                        </li>
                        <li>Getting the head and tail off a list at the same time:
                            <pre>[Head|Tail] = NewList.</pre></li>
                        <li>The pipe is the 'cons' (constructor) operator.</li>
                        <li>Any list can be built with just cons operators and values:
<pre>
[1 | []]
[2 | [1 | []]].
[3 | [2 | [1 | []]]].
</pre></li>
                        <li>So you can define lists recursively as a head preceding a tail, which is itself a head followed by more heads.</li>
                        <li>Technically [1|2] is an improper list, because a proper list ends with an empty list as the last cell.</li>
                    </ul>
                </td>
                <td>
<pre>
1&gt; [1,2,3,{numbers,[4,5,6]},5.34,atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
2&gt; [1,2,3] ++ [4,5].
[1,2,3,4,5]
3&gt; [2,4,2] -- [2,4].
[2]
4&gt; List = [2,3,4].
[2,3,4]
5&gt; NewList = [1|List].
[1,2,3,4]
6&gt; [Head|Tail] = NewList.
[1,2,3,4]
7&gt; Head.
1
8&gt; Tail.
[2,3,4]
9&gt; List2 = [3 | [2 | [1 | []]]].
[3,2,1]
</pre>
                </td>
            </tr>
        </table>

        <h2>Pattern Matching</h2>

        <h2>Functions</h2>

        <h2>List Comprehensions</h2>
        <ul>
            <li>Generic recipe:
                <pre>NewList = [Expression || Pattern &lt;- List, Condition1, ConditionN]</pre></li>
            <li>Example of 'for all n values in [1,2,3,4], give me n*2':
                <pre>[2*N || N &lt;- [1,2,3,4]].</pre></li>
            <li>Constraints imposed:
                <pre>[X || X &lt;- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].</pre></li>

            <li><code>Pattern &lt;- List</code> is a 'generator expression'</li>

            <li>In depth example:
<pre>
RestaurantMenu = [
    {steak, 5.99}, {beer, 3.99}, {poutine, 3.50},
    {kitten, 20.99}, {water, 0.00}
].

[{Item, Price*1.07} ||
    {Item,Price} &lt;- RestaurantMenu,
    Price &gt;= 3, Price =&lt; 10].</pre></li>

            <li>You can have multiple generator expressions:
<pre>
[X+Y || X &lt;- [1,2], Y &lt;- [3,4]].
% returns [4,5,5,6], because it runs X[0]+Y[0], X[0]+Y[1], etc.</pre></li>

            <li>Further generic recipe:
<pre>NewList = [Expression || Generator1, Generator2, ..., GeneratorN,
            Condition1, Condition2, ..., ConditionM]</pre></li>

            <li>Combining generator expressions with pattern matching for filtering:
<pre>Weather = [
    {toronto,rain}, {montreal,storms}, {london,fog},
    {paris,sun}, {boston,fog}, {vancouver,snow}
].

FoggyPlaces = [X || {X,fog} &lt;- Weather].</pre></li>
        </ul>

        <h2>Binary Data</h2>
        <ul>
            <li>Binary data is surrounded by <code>&lt;&lt;&nbsp;&nbsp;&gt;&gt;</code></li>
            <li>Inside the brackets, binary data is split into readable segments with commas.</li>
            <li>Each segment is a sequence of bits, and comma boundaries may or may not coincide with byte bounardies. Example: <pre>Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.</pre></li>
            <li>You can unpack a binary sequence into discrete variables with pattern matching:
            <pre>Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.
&lt;&lt;Pix1:24,Pix2:24,Pix3:24,Pix4:24&gt;&gt; = Pixels.
&lt;&lt;R:8, G:8, B:8&gt;&gt; = &lt;&lt;Pix1:24&gt;&gt;.</pre></li>

            <li>You can selectively store only a portion of the head of a sequence. The following will store everything but the first 8 bits into a variable named <code>Rest</code>:
            <pre>&lt;&lt;R:8, Rest/binary&gt;&gt; = Pixels.</pre></li>
            <li>Ways of describing a binary segment:
                <ul>
                    <li><code>Value</code></li>
                    <li><code>Value:Size</code></li>
                    <li><code>Value|TypeSpecifierList</code></li>
                    <li><code>Value:Size|TypeSpecifierList</code></li>
                </ul>
            </li>
        </ul>
        <table>
                    <tr>
                <th colspan="3">TypeSpecifierList</th>
            </tr>
            <tr>
                <td colspan="2">Represents one or more of the following, hyphen separated:</td>
                <td rowspan="5">
Examples:
<pre>
1&gt; &lt;&lt;X1/unsigned&gt;&gt; = &lt;&lt;-44&gt;&gt;.
&lt;&lt;"Ô"&gt;&gt;
2&gt; X1.
212
3&gt; &lt;&lt;X2/signed&gt;&gt; = &lt;&lt;-44&gt;&gt;.
&lt;&lt;"Ô"&gt;&gt;
4&gt; X2.
-44
5&gt; &lt;&lt;N:8/unit:1&gt;&gt; = &lt;&lt;72&gt;&gt;.
&lt;&lt;"H"&gt;&gt;
6&gt; N.
72
7&gt; &lt;&lt;N/integer&gt;&gt; = &lt;&lt;72&gt;&gt;.
&lt;&lt;"H"&gt;&gt;
8&gt; &lt;&lt;Y:4/little-unit:8&gt;&gt; = &lt;&lt;72,0,0,0&gt;&gt;.
&lt;&lt;72,0,0,0&gt;&gt;
9&gt; Y.
72
</pre>
                </td>
            </tr>
            <tr>
                <th>Type:</th>
                <td><code>integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32</code> <br>(<code>integer</code> is the default, <code>bytes</code> is a synonym for <code>binary</code>, and <code>bits</code> is a synonym for <code>bitstring</code>.</td>
            </tr>
            <tr>
                <th>Signedness:</th>
                <td><code>signed | unsigned</code><br>(<code>unsigned</code> is the default. Applies to <code>integer</code> type only.)</td>
            </tr>
            <tr>
                <th>Endianness:</th>
                <td><code>big | little | native</code><br>(<code>big</code> is default.)</td>
            </tr>
            <tr>
                <th>Unit:</th>
                <td><code>1..256</code><br>(Written as <code>unit:Integer</code>. 1 is the default for <code>integer</code>, <code>float</code>, and <code>bitstring</code>. 8 is the default for <code>binary</code>. <code>utf8</code>, <code>utf16</code>, and <code>utf32</code> don't require a unit size.)</td>
            </tr>
        </table>

        <table>
            <tr>
                <th colspan="2">Bitwise Operations</th>
            </tr>
            <tr>
                <th><code>bsl</code</th>
                <td>bit shift left</td>
            </tr>
            <tr>
                <th><code>bsr</code></th>
                <td>bit shift right</td>
            </tr>
            <tr>
                <th><code>band</code></th>
                <td>binary and</td>
            </tr>
            <tr>
                <th><code>bor</code></th>
                <td>binary or</td>
            </tr>
            <tr>
                <th><code>bxor</code></th>
                <td>binary xor</td>
            </tr>
            <tr>
                <th><code>bnot</code></th>
                <td>binary not</td>
            </tr>
        </table>

        <h3>Binary Strings</h3>
        <ul>
            <li>Lists (and therefore strings) are like linked lists, whereas binary strings are bolted on top of binary notation, and packed like an array in C.</li>
            <li>Syntax is <code>&lt;&lt;"this is a binary string!"&gt;&gt;</code></li>
            <li>Loss of simplicity in pattern matching and manipulation, compared to lists, so use them to store text that won't be manipulated a lot.</li>
        </ul>

        <h3>Binary Comprehensions</h3>
        <ul>
            <li>Similar to list comprehensions:

<pre>&lt;&lt; &lt;&lt;X&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;1,2,3,4,5&gt;&gt;, X rem 2 == 0 &gt;&gt;.
% returns &lt;&lt;2,4&gt;&gt;</pre></li>

            <li>Binary generators use <code>&lt;=</code> instead of <code>&lt;-</code>, and <code>&lt;&lt; &gt;&gt;</code> instead of <code>[]</code></li>

            <li>Getting RGB values with a comprehension:

<pre>Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.
RGB = [ {R,G,B} || &lt;&lt;R:8,G:8,B:8&gt;&gt; &lt;= Pixels ].
% RGB is a list of 3-tuples with binary RGB values</pre></li>

            <li>The elements of a binary resulting from a comprehension require a clearly defined binary type if the generator returns binaries:

<pre>&lt;&lt; &lt;&lt;Bin/binary&gt;&gt; | Bin &lt;- [&lt;&lt;3,7,5,4,7&gt;&gt;] &gt;&gt;.
% returns &lt;&lt;3,7,5,4,7&gt;&gt;</pre></li>
            
            <li>A binary comprehension with a binary generator:

<pre>&lt;&lt; &lt;&lt;(X+1)/integer&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;3,7,5,4,7&gt;&gt; &gt;&gt;.
% returns &lt;&lt;4,8,6,5,8&gt;&gt;</pre></li>
        </ul>

        <h3>Binary Data Use-case: Parsing TCP segments:</h3>
<pre>&lt;&lt;SourcePort:16, DestinationPort:16, AckNumber:32,
  DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
  CheckSum:16, UrgentPointer:16, Payload/binary&gt;&gt; = SomeBinary.</pre>

    </body>
</html>
