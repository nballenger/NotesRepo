#### STRUCTURE OF C PROGRAMS ####

    * Every C program has the general form:
    
        documenation describing the entire program
        preprocessor directives
        defined constants /* optional, explained later */
        global variables /* not recommended, explained later */
        function prototypes
        
        int main()
        {
            declarations of variables and constants
            ...
            executable statements
            ...
            return 0;
        }
        
        function implementations
        
    * The structure of a subordinate function is:
    
        documenation describing the function
        external variables /* not recommended, explained later */
        return type     function name(parameter list)
        {
            declarations of variables
            ...
            executable statements
            ...
            return;
        }

#### BASIC DATA TYPES ####

    * int: one or more digits, possibly signed, no decimal point
        - storage size can be set to 2 bytes with 'short int'
        - storage size can be set to 4 bytes with 'long int'
        - Sizes are defined in limits.h
        - You can explicitly declare an int to be 'unsigned'
        - Multiple variables can be declared in one line: int a, b, c;
    * float: one or more digits, possibly signed, a decimal point or scientific notation
        * Allocated four bytes of storage
        * using E in a number will give exponentiation
    * double: eight bytes of storage, holding up to fifteen decimal digits
        - most high precision values are represented in scientific notation
    * char: one byte of storage, with one character
        - character constants must be enclosed in single quotes
        - double quotes indicate a string
        - stored in memory as an integer value from ASCII
    * special characters:
        '\a'    bell
        '\b'    back space
        '\f'    form feed
        '\n'    new line
        '\t'    tab
        '\0'    null character
        '\\'    backslash
        '\''    single quote
        
#### DERIVED DATA TYPES ####

    * Arrays are defined with:
    
        int loc[] = {1,2,3};  <-- x/y/z point in space
        
    * Strings are defined with:
    
        char digits[] = {'0','1','2','3','\0'}; <-- characters ending in a null character
        
#### POINTERS AND POINTER VARIABLES ####

    * Tool for manipulating data using the memory address of a variable
    * Value of a pointer is the memory address of a variable
    * Pointer variable points to the data value at the address stored in the pointer
    * The data type of a pointer variable is the same as the data type it refers to
    * Asterisks denote pointer variables:
    
        float var1 = 460.5;
        float *ptrvar1;
        
    * To store a memory address into a pointer variable post declaration, use the address operator, &:
    
        ptrvar1 = &var1;
        
    * To access the value of a memory address a pointer refers to, use the dereference operator, *:
    
        *ptrvar1 = 723.14;
        *ptrvar1 = *ptrvar1 + 200;
        
#### ARITHMETIC OPERATORS AND EXPRESSIONS ####

    * Can be performed on int, float or double types
    * Operators are: + - * / %
    * Exponentiation is done with: pow(double, double) from the math library
    * Dividing an integer by an integer produces an integer
    * Cast one or both ints to float to avoid the truncation of the decimal part
    * In a mixed type operation, both will be converted to the more complex of the two
    
    2.3.2 Arithmetic Expressions
        * Expressions can be used wherever a value of the same type could be used
        
    2.3.3 Assignment Statement
        * The equal sign is the assignment operator
        * Assigns the value on the right to the variable on the left
        * Assignments are carried out in three steps:
            - Evaluate the expression on the right of the equals sign
            - Convert if necessary to the data type of the variable on the left
            - The value from the right is stored in the memory cell associated with the variable or pointer
            
    2.3.4 Order of Evaluations
        * Operator precedence order is:
            ()
            + - (unary)
            pow()                
            * and / and %, left to right
            + and -
            
    2.3.5 Use of Parentheses
        * Generally necessary when an algebraic expression has fractions or exponents
        
    2.3.6 Special Operators
        +=  increment
        -=  decrement
        /=  fractional
        *=  product
        %=  remainder
        ++  unary increment (pre or post)
        --  unary decrement (pre or post)
        
        * You can use a cast operator to convert a value to another data type without changing it in storage
        * Example:
            
            int     var1;
            float   var2;
            (float) var1;   <-- casts the stored int as float
            (int)   var2;   <-- casts the stored float as int
            
        * sizeof operator: determines at run time the number of bytes of storage for a variable or data type
        * Example:
        
            int var, varsize;
            varsize = sizeof(int);
            -- or --
            varsize = sizeof(var);
            
#### RELATIONAL AND LOGICAL OPERATORS ####

    >       greater than
    >=      greater than or equal to
    <       less than
    <=      less than or equal to
    ==      equal to
    !=      not equal to
    &&      AND
    ||      OR
    !       NOT
                        
    * Good to use approximate equality for comparing real numbers, like:
    
        float a;
        a = 1.0 / 3.0;
        a = 3 * a;
        if (fabs(a - 1.0) < 0.0001) /* is approximately equal */
                
                        
            
#### FILE I/O ####

    * Three main file modes: r (read), w (write), a (append
    * Data files are accessed via file pointers, declared and set with:
    
        FILE *fptr;
        fptr = fopen("myfile.dat", mode);
        [...]
        fclose(fptr);
            
    * List of modes:
        r       reads if exists, error if not
        w       writes to file from beginning if exists, creates new file if not exists
        a       appends to file if exists, creates new file if not exists
        r+      opens for reading and writing if exists, error if not
        w+      opens for reading and writing if exists, new file if not
        a+      opens for reading and appending if exists, new file if not
        wb      opens a binary file for writing
        r+b     opens a binary file for reading and writing

#### INPUT FROM A FILE ####

    * Reading data from a file, general form:
        
        fscanf(file pointer, "format control string", &var1, &var2, ..., &varN);
            
    * If there is not enough data in the file, fscanf() returns an EOF flag
    * Example read:
    
        FILE *inptr;
        int var1, var2;
        float var3;
        double var4;
        
        inptr = fopen("myfile1.dat", "r");
        fscanf(inptr, "%d %d %f %e", &var1, &var2, &var3, &var4);
        
    * Amount of data read by an input statement is an 'input record', same for 'output record'
    * Every time a record is read or written, the record marker is moved to the beginning of the next record
    * Initially it's set to the first record at the beginning of the file
    * Example of failsafe input:
    
        FILE *inptr;
        float var1, var2, var3, var4;
        inptr = fopen("myfile2.dat", "r");
        
        if (inptr)
        {
            fscanf(inptr, "%f %f", &var1, &var2);
            fscanf(inptr, "%f %f", &var3, &var4);
        }
        else
        {
            printf("file myfile2.dat not available\n");
        }
        
#### OUTPUT TO A FILE ####        
        
    * General form:
    
        fprintf(file pointer, "format control string", var1, var2, ..., varN);
        
    * Example of output:
    
        int var1, var4,;
        float var2, var3;
        
        FILE *outptr;
        outptr = fopen("myfile3.dat", "w");
        fprintf(outptr, "%d %f %f %d", var1, var2, var3, var4);
        
    * Building a data file from pairs of numbers entered at the keyboard:
    
        #include <stdio.h>
        int main()
        {
            float x, y;
            FILE *graphptr;
            
            graphptr = fopen("graph.dat", "w");
            
            if (graphptr)
            {
                while(scanf("%f %f", &x, &y))
                {
                    fprintf(graphptr, "%f %f", x, y);
                }
                fclose(graphptr);
            }
            else
                printf("File <graph.dat> is not available");
            return 0;
        }
        
    * Outputting a data file:
    
        #include <stdio.h>
        int main() 
        {
            float x, y;
            FILE *fptr;
            
            fptr = fopen("myfile.dat", "r");
            
            if (fptr)
            {
                printf("  x  y\n");
                while ((fscanf(fptr, "%f %f", &x, &y)) != EOF)
                    printf("%f %f\n", x, y);
                fclose(fptr);
            }
            else
                printf("File <myfile.dat> not available\n");
            return 0;
        }
        

#### CHARACTER I/O ####

    * Characters are defined as:
    
        char ch1, ch2, ch3;
        
    * Input:
    
        scanf("%c%c%c", &ch1, &ch2, &ch3);
        
    * Output:
    
        printf("%c %c %c", ch1, ch2, ch3);  <-- as characters
        printf("%d %d %d", ch1, ch2, ch3);  <-- as ascii code integers
            
    * Character input from file example:
    
        FILE *inptr;
        inptr = fopen("myfile7.dat", "r");
        char ch1, ch2, ch3, ch4;
        fscanf(inptr, "%c%c%c%c", &ch1, &ch2, &ch3, &ch4);
        
    * Character output to file example:
        
        char ch1='3', ch2=' ', ch3='X', ch4='Y';
        FILE *outptr;
        outptr = fopen("myfile8.dat", "w");
        fprintf(outptr, "%c%c%c%c", ch1, ch2, ch3, ch4);
            
    * Unformatted Input and Output
        * getchar() and putchar() do input and output of characters from stdin/stdout
        * getchar() takes a single character from the keyboard
        * putchar() puts a single character in an output buffer, to display when you hit enter
        * Example:
        
            char ch;
            while(( ch = getchar()) != '\n')
                putchar(ch);
                
                
#### CONTROL FLOW STRUCTURES ####
        
    if (cond1) {
        stmt1;
    }
    else if (cond2) {
        stmt2;
    }
    else if (cond3) {
        stmt3;
    }
    else {
        stmt4;
    }
    
    
    switch (expression) {
        case 1:
            sequence1;
            break;
        case 2:
            sequence2;
            break;
        case 3:
            sequence3;
            break;
        default:
            sequence4;
    }
    
    * Case codes must be int or char
    * To combine cases:
    
    switch (expression) {
        case 1:
            stmt1;
            break;
        case 2:
        case 3:
            printf("case 2 or 3: %d\n" expression);
            break;
        default:
            stmt3;
    }
            
    int i;
    for (i = 1; i < 6; i++)
    {
        funcall();
        printf("i = %d\n", i);
    }
    printf("i = %d\n", i);
    

    int i, j;
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 40; j++)
        {
            funcall();
            printf("i = %d  j = %d\n", i, j);
        }
        printf("\n");
    }
    

    float r, a;
    const float PI = 3.141593;
    
    scanf("%f", &r);
    while (r != 0)
    {
        a = PI * r * r;
        printf("radius = %f area = %f\n", r, a);
        scanf("%f", &r);
    }
    

    /* Flag controlled (EOF) while loop: */
    int num;
    while ((fscanf(inptr, "%d", &num)) != EOF)
    {
        stmt1;
        stmt2;
        stmtN;
    }
    
    /* do while loop */
    do
    {
        stmt1;
        stmt2;
        stmtN;
    }
    while (condition);
    