Notes on Secrets of the JavaScript Ninja
by John Resig and Bear Bibault
ISBN-13: 978-1-933988-69-6

Part 1: Preparing for Training

Chapter 1: Enter the ninja

1.1 The JavaScript Libraries We'll be Tapping
    * Will be looking at code from:
        - jQuery
        - Prototype
        - YUI
        - base2
        
    * "The makeup of a JavaScript library can be broken down into three aspects:
        - Advanced use of the JavaScript language.
        - Meticulous construction of cross-browser code.
        - The use of current best practices that tie everything together."
        
1.2 Understanding the JavaScript Language
    * "JavaScript consists of a close relationship between objects, functions, and closures."
    * Two features that are underused: timers and regular expressions.
    * "A firm grasp of how timers operate within the browser...gives us the ability to
        tackle complex coding tasks such as long-running computations and smooth animations."
    * Will look at both 'with' and 'eval()'--controversial topics
    
1.3 Cross-browser considerations
    * Quality of browsers is way better than it was, but still buggy and missing APIs
    * Important to decide which browsers to support in which environments
    * Concept from Yahoo! development: graded browser support matrix, A through F
    * Factors to consider:
        - expectation and needs of the target audience
        - market share of the browser
        - amount of effort necessary to support the browser
    * Worth support IE 7 and 8 because of market share, 9 because of standards compliance
    * Worth supporting chrome and ff because of market share, safari because of compliance
    * "If it works in Chrome, it'll likely work in Safari--pathological cases notwithstanding."
    * Opera on the desktop is effort on part with Safari, but way smaller market share
    * Mobile Opera is a bigger deal--has mobile market share on par with safari and android
    
1.4 Current best practices
    * Includes such elements as:
        - Testing
        - Performance analysis
        - Debugging skills
    
    1.4.1 Current best practice: testing
        * Primary tool in this book is an assert() function, whose general form is:
        
            assert(condition, message);
            
        * Not a built in function, will add it ourselves
        
    1.4.2 Current best practice: performance analysis
        * Browser engines have been making huge strides, but that's no excuse for sloppy code
        * Will be bracketing repetitions of code with execution timestamps
    
1.5 Summary
    * Cross-browser web app development is hard, harder than most people would think.
    * To do it, you need language mastery, browser knowledge, and best practices
    * You can do world class development by leveraging existing great libraries
    
    
Chapter 2: Arming with testing and debugging

2.1 Debugging code
    * Tools exist for all major browsers:
        - Firebug for FF
        - IE Developer tools in IE 8+
        - Opera Dragonfly in O 9.5+
        - WebKit Developer Tools in Safari 3+ and Chrome
        
    * Two important approaches: logging and breakpoints
    
    2.1.1 Logging
        * Logging to the console immediately gives feedback without interrupting flow
        * If you're not dealing with old versions of Opera you can use console.log
        * Otherwise implement something like:
        
            function log() {
                try {
                    console.log.apply(console, arguments);
                }
                catch (e) {
                    try {
                        opera.postError.apply(opera, arguments);
                    }
                    catch (e) {
                        alert(Array.prototype.join.call(arguments, " "));
                    }
                }
            }
            
        * More complete implementation at http://patik.com/blog/complete-cross-browser-console-log/
        
    2.1.2 Breakpoints
        * Halt execution at a specific line of code, pausing the browser, so you can see state
        * You set a breakpoint, run the code, then start / stop / step through it.
        * A debugger with breakpoints is highly browser dependent, so each browser
            has its own package of tools.
            
2.2 Test generation
    * Good tests make good code, and have three important characteristics:
        - Repeatability: runs should always produce the same results / be deterministic
        - Simplicity: focus each test on testing one thing, removing as much HTML/CSS/JS as possible
        - Independence: tests should execute in isolation
    * Two primary approaches for constructing tests:
        - Deconstructive test cases: whittle down existing code to isolate a problem, 
            eliminating anything that's not germane to the issue.
        - Constructive test cases: start from a known good, reduced case and built up until
            we're able to reproduce the bug in question.
    * Example of constructive testing: start with a few HTML files with minimal functionaltiy
        * Following listing shows a simple DOM test case used to test jQuery:
        
            <script src="dist/jquery.js"></script>
            <script>
                $(document).ready(function() {
                    $("#test").append("test");
                });        
            </script>
            <style>
                #test { width: 100px; height: 100px; background: red; }
            </style>
            
        * Shell script to check out the library, copy the test case, build the test suite:
        
            #!/bin/sh
            # Check out a fresh copy of jQuery
            git clone git://github.com/jquery/jquery.git $1
            # Copy the dummy test case file in
            cp $2.html $1/index.html
            # Build a copy of the jQuery test suite
            cd $1 && make
            
        * Executed with: './gen.sh mytest dom'
        
    * Other alternative is to use a prebuilt service designed for creating simple test cases
    * JS Bin is a simple tool that builds a test case that then becomes available at a URL
    
2.3 Testing frameworks
    * Pick a suite that works well for your coding style and code base
    * Features that we might look for in a JS unit-testing framework:
        - Ability to simulate browser behavior like clicks and keypresses
        - Interactive control of tests (pausing and resuming)
        - Handling asynchronous test timeouts
        - Ability to filter which tests are to be executed
    * Majority of authors who do write tests use one of four tools:
        - JsUnit
        - QUnit
        - Selenium
        - YUI Test
    * Additional top ten tools include:
        - FireUnit
        - Prototype
        - Screw.Unit
        - Envjs
        - JsSpec
        - Dojo
        
    * Fairly easy to write a test framework from scratch, not a bad exercise
    * Consequently there's a lot of one off frameworks--try to use a good one though
    
    2.3.1 QUnit
        * Built to test jQuery, is now a standalone unit-testing framework
        * Features:
            - Simple API
            - Supports asynchronous testing
            - Not limited to jQuery or jQuery using code
            - Especially well suited for regression testing
            
    2.3.2 YUI Test
        * Built at Yahoo!, rewritten completely for YUI 3 in '09
        * Features:
            - Extensive and comprehensive unit-testing functionality
            - Supports asynchronous tests
            - Good event simulation
            
    2.3.3 JsUnit
        * Port of JUnit to JavaScript
        * Popular, but old and not updated enough
        
    2.3.4 Newer Unit-testing frameworks
        * JUnit is now focused on a new testing tool named Jasmin
        * TestSwarm is a distributed, continuous integration testing tool at Mozilla Labs
        
2.4 The fundamentals of a test suite
    * Purpose is to aggregate all the individual tests that your code base might have
        into a single unit to be run in bulk
    
    2.4.1 The assertion
        * Core of a framework is its assertion method, usually assert()
        * Usually takes a value and a description that describes the purpose of the assertion
        * If the value is truthy, the assertion passes
        * Simple implementation of an assert function:
        
            function assert(value, desc) {
                var li = document.createElement('li');
                li.className = value ? "pass" : "fail";
                li.appendChild(document.createTextNode(desc));
                document.getElementById("results").appendChild(li);
            }
            
    2.4.2 Test groups
        * A test group will likely represent a collection of assertions as they relate
            to a single method in our API or application
        * Sample, in which a test group is built of assertions, and if any assertion fails
            the group fails as well:
            
            <script>
            (function() {
                var results;
                this.assert = function assert(value, desc) {
                    var li = document.createElement("li");
                    li.className = value ? "pass" : "fail";
                    li.appendChild(document.createTextNode(desc));
                    results.appendChild(li);
                    if (!value) {
                        li.parentNode.parentNode.className = "fail";
                    }
                    return li;
                };
                this.test = function test(name, fn) {
                    results = document.getElementById("results");
                    results = assert(true, name).appendChild(
                        document.createElement("ul"));
                    fn();
                };
            })();
            
            window.onload = function() {
                test("A test.", function() {
                    assert(true, "First assertion completed.");
                    assert(true, "Second assertion completed.");
                    assert(true, "Third assertion completed.");
                });
                test("Another test.", function() {
                    assert(true, "First test completed");
                    assert(false, "Second test failed");
                    assert(true, "Third assertion completed.");
                });
                test("A third test.", function() {
                    assert(null, "fail");
                    assert(5, "pass");
                });
            };
            </script>
            <style>
                #results li.pass { color: green; }
                #results li.fail { color: red; }
            </style>
            <ul id="results"></ul>
            
    2.4.3 Asynchronous testing
        * Difficult to figure out how to handle testing asynchronous tasks
        * To do it, we need to follow some simple steps:
            1.  Assertions that rely on the same asynchronous operation need to be
                grouped into a unifying test group.
            2.  Each test group needs to be placed on a queue to be run after all the 
                previous test groups have finished running.
        * So each test group must be capable of running asynchronously.
        * Example:
        
            <script>
            (function() {
                var queue = [], paused = false, results;
                this.test = function(name, fn) {
                    queue.push(function() {
                        results = document.getElementById('results');
                        results = assert(true, name).appendChild(
                            document.createElement('ul'));
                        fn();
                    });
                    runTest();
                };
                
                this.pause = function() { paused = true; };
                
                this.resume = function() {
                    paused = false;
                    setTimeout(runTest, 1);
                };
                
                function runTest() {
                    if (!paused && queue.length) {
                        queue.shift()();
                        if (!paused) {
                            resume();
                        }
                    }
                }
                
                this.assert = function assert(value, desc) {
                    var li = document.createElement('li');
                    li.className = value ? 'pass' : 'fail';
                    li.appendChild(document.createTextNode(desc));
                    results.appendChild(li);
                    if (!value) {
                        li.parentNode.parentNode.className = 'fail';
                    }
                    return li;
                };
            })();
            
            window.onload = function() {
                test('Async Test #1', function() {
                    pause();
                    setTimeout(function() {
                        assert(true, "First test completed");
                        resume();
                    }, 1000);
                });
                test('Async Test #2', function() {
                    pause();
                    setTimeout(function() {
                        assert(true, "Second test completed");
                        resume();
                    }, 1000);
                });
            };
            </script>
            
        * Three publicly available functions in the above: test(), pause(), resume()
            - test(fn) takes a function that contains a number of assertions and places
                it on the queue to await execution
            - pause() is called from within a test function and tells the test suite to
                pause executing tests until the test group is done
            - resume() unpauses the tests and starts the next test running after a short delay
                designed to avoid long-running code blocks
        * runTest() is internal and is called whenever a test is queued or dequeued
        
2.5 Summary
    * Logging lets you look at code while it's running
    * Breakpoints lets you view state during execution flow
    * Tests should be: repeatable, simple, and independent
    * Tests are typically 'constructive' or 'deconstructive'
    * Most people now use QUnit, JSUnit, or Selenium as test frameworks
    * Tests are made up of assertions
    * You can test asynchronous cases by leveraging timers
    
    
Chapter 3: Functions are fundamental
    * Functions are first-class objects: can be treated like any other js object
    
3.1 What's with the functional difference?
    3.1.1 Why is JavaScript's functional nature important
        * Functions as first class objects:
            - Can be created via literals
            - can be assigned to variables, array entries, and object properties
            - can be passed as arguments to functions
            - can be returned as values from functions
            - can possess properties that can be dynamically created and assigned
        * Unlike other objects, they can be invoked
        * Invocation is frequently done asynchronously
    
        The browser event loop
            * We set event handlers for the browser's event loop
            * The events are placed on a FIFO queue as they occur
            * Events happen at unpredictable times, in an unpredictable order: they're asynchronous
            * Some types of events that can happen:
                - Browser events, like the page finishing its load or is going to be unloaded
                - Network events, like an Ajax request returning
                - User events like mouse clicks or moves
                - Timer events, like a timeout expiring or an interval firing
            * Event loop is single-threaded: every event placed into the queue is handled
                in the order that it's placed onto the queue
            * Two handlers never execute simultaneously in separate threads.
            * The mechanism in the browser that puts events onto the queue is external
                to the loop model itself: "The processing necessary to determine when
                events have occurred and to push them onto the event queue doesn't participate
                in the thread that's _handling_ the events."
            * Event handlers are 'callback functions'
            
        The callback concept
            * When we set up a function to be called at a later time, that's a callback
            * Example of a completely useless function that accepts a reference to another
                function as a parameter and calls that function as a callback:
                
                function useless(callback) { return callback(); }
            
    3.1.2 Sorting with a comparator
        * In a non-functional language if you wanted to use a pre-existing sort routine
            but with a custom constructor, you'd need to do something like augment an object
            with additional methods.
        * In javascript you can pass a function to Array.sort():
        
            var values = [ 213, 16, 2058, 54, 10, 1965, 57, 9 ];
            values.sort(function(value1, value2) { return value2 - value1; });
            
3.2 Declarations
    * JS Functions are declared using function literals
    * Function literals are made of four parts:
        1.  The function keyword
        2.  An optional name that, if specified, must be a valid JS identifier
        3.  A comma-separated list of parameter names enclosed in parens
        4.  The body of the function as a series of JS statements in braces
    * When a function is named, that name is valid throughout the scope in which it was declared.
    * All functions have a 'name' property storing the function's name as a string
    
    3.2.1 Scoping and functions
        * JavaScript has function scope, not block scope
        * Lots of stuff about that, but it's all pretty much 'js has function scope'
        
3.3 Invocations
    * The manner in which a function is invoked determins how hte code within it operates
    * Mostly to do with how 'this' is set
    * Four ways to invoke a function:
        - As a function, in which the function is invoked in a straightforward manner
        - As a method, which ties the invocation to an object
        - As a constructor, in which a new object is brought into being
        - Via its apply() or call() methods
    * The parens operator is the function invocation operator
    
    3.3.1 From arguments to function parameters
        * If there are values inside the function invocation operator, they're passed
            to the function body as parameters in the order they were received
        * If you get more arguments than you need, they go into the 'arguments' obj
        * If there are more parameters than args, you get undefined parameter values
        * All function invocations are passed 'arguments' and 'this'
        * 'arguments' is an array like structure that holds the args to the function
        * 'this' refers to the function context
        
    3.3.2 Invocation as a function
        * A function is "invoked as a function" if it isn't invoked as a method, a
            constructor, or via apply() or call()
        * When it's invoked as a function, the function context (and therefore 'this'
            refers to the global head object--in a browser, the window object
        
    3.3.3 Invocation as a method
        * When a function is assigned as a property and is invoked by reference to that
            property, it's being called as a method
        * The function context in that case is the object the function is a method of,
            so 'this' refers to that object
        
    3.3.4 Invocation as a constructor
        * Constructors are just like other functions for declaration purposes
        * Something is invoked as a constructor when called with 'new'
        * When the constructor is called:
            - a new empty object is created
            - the object is passed to the constructor as the value of 'this'
            - in the absence of an explicit return value, 'this' is the return value
            
    3.3.5 Invocation with apply() and call()
        * If you want to explicitly set the function context, you can do it via apply/call
        * apply() and call() are methods inherited from Function()
        * apply() takes two params: the object to use as the function context and an array
            of values to use as the function arguments
        * call() takes the object to use as the context and comma separated args
        
            x.apply(obj1, [1,2,3,4]);
            x.call(obj1, 1,2,3,4);
            
        * Useful example:
        
            function forEach(list, callback) {
                for (var n = 0, l = list.length; n < l; n++) {
                    callback.call(list[n], n);
                }
            }
            
            var weapons = ['stick', 'knife', 'gun'];
            
            forEach(
                weapons,
                function(index) {
                    assert(this === weapons[index],
                           "Got the expected value of " + weapons[index]);
                }
            );
            
        * How to decide between call() and apply()? Use whichever one improves code clarity.
        
3.4 Summary
    * Functions are incredibly important to JS, and they're first class objects
    * Functions derived from Function() can be invoked with the parens operator
    * Functions are created via literals, for which a name is optional
    * The browser can invoke functions during a page's lifetime by invoking them as event handlers
    * Scope rules:
        - Variables inside a function are scoped to that function
        - Inner named functions are available anywhere within the enclosing function
    * Parameter lists and arguments can be of different number
        - Extra args will be in 'arguments'
        - Missing params will be undefined
    * Each function invocation gets 'arguments' and 'this' implicitly
    * Functions can be invoked:
        - as functions, whose context is the global head
        - as a method, whose context is the owning object
        - as a constructor, whose context is a newly allocated object
        - when invoked via apply() or call(), the context is whatever the first arg is
    

Chapter 4: Wielding functions
    * Covers: anonymous functions, function references including recursion, storing references
        to functions, using the function context to get our way, dealing with variable-length
        argument lists, determining whether an object is a function
        
    4.1 Anonymous Functions
        * Functions with no name that exist and are called purely by reference.
        
    4.2 Recursion
        4.2.1 Recursion in named functions
            * Common example for recursion: palindrome test
            * Math-ish definition of a palindrome:
                1.  A single or zero-character string is a palindrome
                2.  Any other string is a palindrome if the first and last characters are
                    the same, and the string that remains is a palindrome.
                    
            * Implementation:
            
                function isPalindrome(text) {
                    if (text.length <= 1) { return true; }
                    if (text.charAt(0) != text.charAt(text.length - 1)) { return false; }
                    return isPalindrome(text.substr(1,text.length-2));
                }
                
            * Example of recursing using the function's name:
            
                function chirp(n) {
                    return n > 1 ? chirp(n-1) + "-chirp" : "chirp";
                }
                
                assert(chirp(3) == "chirp-chirp-chirp", "Worked.");
                
        4.2.2 Recursion with Methods
            * Same thing, but as a method:
            
                var ninja = {
                    chirp: function(n) {
                        return n > 1 ? ninja.chirp(n-1) + "-chirp" : "chirp";
                    }
                };
                
        4.2.3 The pilfered reference problem
            * Consider:
            
                var ninja = {
                    chirp: function(n) {
                        return n > 1 ? ninja.chirp(n-1) + "-chirp" : "chirp";
                    }
                };
                
                var samurai = { chirp: ninja.chirp };
                
                ninja = {};
                
                try {
                    assert(samurai.chirp(3) == "chirp-chirp-chirp",
                        "Is this going to work?");
                }
                catch(e) {
                    assert(false, "Ruh-roh.");
                }
                
            * samurai loses its reference to chirp when ninja is reset
            * fix is to use 'this' in the function def instead of ninja
            
        4.2.4 Inline named functions
            * The name of an inline function is valid only within that function, but
                allows an anonymous function to refer to itself without reference to
                the container object or variable that holds it
            * In practice looks like:
            
                var ninja = {
                    chirp: function signal(n) {
                        return n > 1 ? signal(n-1) + "-chirp" : "chirp";
                    }
                };
                
            * Note that the fact that function names are only in scope for themselves
                is why top level functions are added to the head object--otherwise they'd
                have no existing references outside of their own names (which are only
                in scope in their body)
            
        4.2.5 The callee property
            * Warning: argument.callee is not available in ECMAScript 5 or under strict mode
            * For reference in existing code:
                
                var ninja = {
                    chirp: function(n) {
                        return n > 1 ? argument.callee(n-1) + "-chirp" : "chirp";
                    }
                };
                
4.3 Fun with function as objects
    * Remember that functions are first level objects, and can have arbitrary properties
    
    4.3.1 Storing functions
        * Problem: storing functions in a collection, but some may already be there:
        
            var store = {
                nextId: 1,
                cache: {},
                add: function(fn) {
                    if (!fn.id) {
                        fn.id = store.nextId++;
                        return !!(store.cache[fn.id] = fn);
                    }
                }
            };
            
            function ninja(){}
            
            assert(store.add(ninja),
                   "Function was safely added.");
            assert(!store.add(ninja),
                   "But it was only added once.");
                   
        * Note: !! will convert any expression into the boolean equivalent
        
    4.3.2 Self-memoizing functions
        * Simple, memoized function for computing primes:
        
            function isPrime(value) {
                if (!isPrime.answers) { isPrime.answers = {}; }
                if (isPrime.answers[value] != null) {
                    return isPrime.answers[value];
                }
                var prime = value != 1; // 1 can't be prime
                for (var i = 2; i < value; i++) {
                    if (value % i == 0) {
                        prime = false;
                        break;
                    }
                }
                return isPrime.answers[value] = prime;
            }
            
        * Memoized DOM elements:
        
            function getElements(name) {
                if (!getElements.cache) { getElements.cache = {}; }
                return getElements.cache[name] = 
                    getElements.cache[name] ||
                    document.getElementsByTagName(name);
            }
            
    4.3.3 Faking array methods
        * Creating an object that has some of the behaviors of an array:
        
            <input id="first" />
            <input id="second" />
            
            <script>
                var elems = {
                    length: 0,
                    
                    add: function(elem) {
                        Array.prototype.push.call(this,elem);
                    },
                    
                    gather: function(id) {
                        this.add(document.getElementById(id));
                    }
                };
                
                elems.gather("first");
                assert(elems.length == 1 && elems[0].nodeType,
                    "Verify that we have an element in our stash");
                    
                elems.gather("second");
                assert(elems.length == 2 && elems[1].nodeType,
                    "Verify the other insertion");
                    
            </script>
            
4.4 Variable-length argument lists
    4.4.1 Using apply() to supply variable arguments
        * Math.min() and Math.max() want variable length arguments, but won't take an array
        * You can deal with that via apply:
        
            function smallest(array) {
                return Math.min.apply(Math, array);
            }
            
            function largest(array) {
                return Math.max.apply(Math, array);
            }
            
        * Works because of how apply() works versus how call() works--apply() wants an array
            which it will then convert into an arguments list to pass to the function
            
    4.4.2 Function Overloading
        * In JS you overload functions by creating a single function definition that
            acts differently based on the number and type of arguments it gets:
            
            function merge(root) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var key in arguments[i]) {
                        root[key] = arguments[i][key];
                    }
                }
                return root;
            }
            
        * All function objects have a 'length' property that tells you the number of
            parameters that the function was originally declared with
        * So you can determine two things about arguments to a function:
            - How many named parameters it was defined with, via length
            - How many arguments were passed on invocation, with arguments.length
            
        * Overloading functions by argument count:
        
            var ninja = {
                whatever: function() {
                    switch (arguments.length) {
                    
                    case 0:
                        /* do something */
                        break;
                    case 1:
                        /* do something */
                        break;
                    case 2:
                        /* do something */
                        break;
                    }
                }
            }
            
        * A tidier way to do it, by creating an addMethod() function for an object that
            lets you add multiple functions with the same name:
            
            function addMethod(object, name, fn) {
                var old = object[name];
                object[name] = function() {
                    if (fn.length == arguments.length) {
                        return fn.apply(this, arguments);
                    }
                    else if (typeof old == 'function') {
                        return old.apply(this, arguments);
                    }
                };
            }

            var x = {};            
            addMethod(x, 'myMethod', function() { console.log('first one'); });
            addMethod(x, 'myMethod', function(a) { console.log('second one'); });
            addMethod(x, 'myMethod', function(a,b) { console.log('third one'); });
            
        * This one's pretty tricky--what it's actually doing is nesting closures, so that 
            each nested 'old' function is holding all previous 'old' versions in a nested structure.
        * Screwy though--hard to document, and collisions on number of arguments provided
            will only resolve via a LIFO stack. Not a great solution, really.
            
4.5 Checking for functions
    * How to detect when a particular object is an instance of a function, and therefore callable
    * typeof x == "function" works in most cases, but gives some false positives:
        - Firefox--typeof called on the HTML <object> element gives "function"
        - IE--typeof called on a function from another window (like an iframe) gives "unknown"
        - Safari--considers a DOM NodeList to be a function, so typeof document.body.childNodes == "function"
        
    * Decent (but not perfect) test is to do:
    
        function isFunction(fn) {
            return Object.prototype.toString.call(fn) === "[object Function]";
        }
        
    * Exception to that is that IE reports methods of DOM elements with a type of "object"
    
    
Chapter 5: Closing in on Closures

5.1 How closures work
    * A closure is "the scope created when a function is declared that allows the function
        to access and manipulate variables that are external to that function."
    * Important thing to remember: a function can be called even after the scope in which
        it was declared has gone away.
    * "a closure was also created that encompasses not only the function declaration, but
        also all variables that are in scope at the point of declaration"
    * They create a "safety bubble" of the function and the variables in scope at declaration.
    * Some concepts regarding closures:
        - Function parameters are included in the closure of that function
        - All variables in an outer scope, even those declared after the function, are included
        - Within the same scope, variables not yet defined cannot be forward-referenced
    * Remember that there is a direct overhead cost to implementing the closure
    
5.2 Putting Closures to Work
    5.2.1 Private variables
        * Common usage is to encapsulate private variables
        
            function Ninja() {
                // private by closure
                var feints = 0;
                
                this.getFeints = function() { return feints; };
                
                this.feint = function() { feints++; };
            }
            
    5.2.2 Callbacks and Timers
        * With callback and timer functions you often need to access outside data, so
            using a closure is an intuitive way of doing that.
        * Example:
        
            jQuery('#testButton').click(function() {
                var elem$ = jQuery('#testSubject');
                
                elem$.html("Loading...");
                
                jQuery.ajax({
                    url: "test.html",
                    success: function(html) {
                        assert(elem$, "We can see elem$ via the closure for the callback");
                        elem$.html(html);
                    }
                });
            });
            
        * Note that suffixing or prefixing a $ to a variable is a common convention for
            indicating that the variable holds a jQuery object reference.
            
        * Example using a closure in a timer interval callback:
        
            function animateIt(elementId) {
                var elem = document.getElementById(elementId),
                    tick = 0,
                    timer;
                    
                timer = setInterval(function() {
                    if (tick < 100) {
                        elem.style.left = elem.style.top = tick + "px";
                        tick++;
                    }
                    else {
                        clearInterval(timer);
                        assert(tick == 100, "tick accessed via closure");
                        assert(elem, "Element accessed via closure");
                        assert(timer, "timer reference obtained via closure");
                    }
                }, 10);
            }
                
            animateIt('box');
            
5.3 Binding function contexts
    * Example to consider:
    
        <button id="text">Click me!</button>
        
        <script>
        var button = {
            clicked: false,
            click: function() {
                this.clicked = true;
                assert(button.clicked, "The button is clicked.");
            }
        };
        
        var elem = document.getElementById("test");
        elem.addEventListener("click", button.click, false);
        </script>
        
    * If you run this the assert will fail, because the context of the button.click method
        is not referring to the button object
    * If it were called as button.click, it would be a method call and 'this' would be the
        button object, but the event handler sets the context of the invocation to be the
        target element of the event, so the context is the <button> element--so state was
        set on the dom object instead of the javascript object
    * You can set a function invocation to always have a desired context by using a mix of
        anonymous functions, apply(), and closures:
        
        function bind(context, name) {
            return function() {
                return context[name].apply(context, arguments);
            };
        }
        
        var button = {
            clicked: false;
            click: function() {
                this.clicked = true;
                assert(button.clicked, "Button clicked.");
                console.log(this);
            }
        };
        
        var elem = document.getElementById("test");
        elem.addEventListener("click", bind(button, "click"), false);
        
    * Returns an anonymous function to be the actual event handler, which itself returns
        an apply() call binding the method call to its object parent as context
    
5.4 Partially Applying Functions
    * Currying / proxy functioning, etc, lets you prefill some portions of a function's args
    * Example partial function:
    
        Function.prototype.partial = function() {
            var fn = this, args = Array.prototype.slice.call(arguments);
            return function() {
                var arg = 0;
                for (var i = 0; i < args.length && arg < arguments.length; i++) {
                    if (args[i] === undefined) {
                        args[i] = arguments[arg++];
                    }
                }
                return fn.apply(this, args);
            };
        };
        
        // Function that can be easily delayed:
        var delay = setTimeout.partial(undefined, 10);
        
        delay(function() {
            assert(true, "A call to this will be delayed 10ms.");
        });
        
        // Function for binding events:
        var bindClick = document.body.addEventListener.partial("click", undefined, false);
        
        bindClick(function() {
            assert(true, "Click event bound via curried function.");
        });
        
5.5 Overriding Function Behavior
    * Two techniques for modifying: modification of how existing functions work, and
        producing new self-modifying functions based on existing static functions
        
    5.5.1 Memoization
        * Method for memoizing functions:
        
            Function.prototype.memoized = function(key) {
                this._values = this._values || {};
                return this._values[key] !== undefined ?
                    this._values[key] :
                    this._values[key] = this.apply(this, arguments);
            };
            
            function isPrime(num) {
                var prime = num != 1;
                for (var i = 2; i < num; i++) {
                    if (num % i == 0) {
                        prime == false;
                        break;
                    }
                }
                return prime;
            }
            
            var from_computation = isPrime.memoized(5);
            var from_memo        = isPrime.memoized(5);
            
        * That requires you to call it through its memoized() method
        * Using closures to implement a function that can automatically memoize itself:
        
            Function.prototype.memoized = function(key) {
                this._values = this._values || {};
                return this._values[key] !== undefined ?
                    this._values[key] :
                    this._values[key] = this.apply(this, arguments);
            };

            Function.prototype.memoize = function() {
                var fn = this;
                return function() {
                    return fn.memoized.apply(fn, arguments);
                };
            };
            
            var isPrime = (function(num) {
                var prime = num != 1;
                for (var i = 2; i < num; i++) {
                    if (num % i == 0) {
                        prime == false;
                        break;
                    }
                }
                return prime;
            }).memoize();
            
    5.5.2 Function wrapping
        * Encapsulates the logic of a function while overwriting it with new or extended
            functionality in a single step
        * Common use is implementing cross browser pieces of code where a browser
            deficiency has to be accounted for
        * Technique from Prototype for working around Opera's implementation of accessing
            title attributes, which does function wrapping rather than a big if-else block:
            
            function wrap(object, method, wrapper) {
                var fn = object[method];
                
                return object[method] = function() {
                    return wrapper.apply(this, [fn.bind(this)].concat(
                        Array.prototype.slice.call(arguments)));
                };
            }
            
            if (Prototype.Browser.Opera) {
                wrap(Element.Methods, "readAttribute",
                     function(original, elem, attr) {
                    return attr == "title" ?
                        elem.title :
                        original(elem, attr);
                });
            }

5.6 Immediate Functions
    * Basic syntax: 
        
        (function(){})()
        
    * Any expression that references a function instance can be used with () to call that function
    * Code like this:
    
        (function() {
            statement-1;
            statement-2;
            ...
            statement-n;
        })();
        
    * Does this:
        - Creates a function instance
        - Executes the function
        - Discards the function
        
    5.6.1 Temporary scope and private variables
        * Example of an immediately bound handler that references a private variable:
        
            (function() {
                var numClicks = 0;
                document.addEventListener("click", function() {
                    alert(++numClicks);
                }, false);
            })();
            
        * Different version of (almost) the same thing:
        
            document.addEventListener("click", (function() {
                var numClicks = 0;
                return function() {
                    alert(++numClicks);
                };
            })(), false);
            
        * Avoiding name collisions within $ for jQuery and Prototype via immediate fn closure:
        
            $ = function() { alert('not jQuery!'); };
            
            (function($) {
                $('img').on('click', function(event) {
                    $(event.target).addClass('clickedOn');
                });
            })(jQuery);
            
        * Creating a shortname jargon within a limited scope (from Prototype):
        
            (function(v) {
                Object.extend(v, {
                    href:       v._getAttr,
                    src:        v._getAttr,
                    type:       v._getAttr,
                    action:     v._getAttrNode,
                    disabled:   v._flag,
                    checked:    v._flag,
                    readonly:   v._flag,
                    multiple:   v._flag,
                    onload:     v._getEv,
                    onunload:   v._getEv,
                    onclick:    v._getEv,
                    ...
                });
            })(Element.attributeTranslations.read.values);
            
        * That makes for much more readable code, having subbed 'v' in for 
            'Element.attributeTranslations.read.values'
            
    5.6.2 Loops
        * Interesting case:
        
            var divs = document.getElementsByTagName("div");
            
            for (var i = 0; i < divs.length; i++) {
                divs[i].addEventListener("click", function() {
                    alert("div #" + i + " was clicked");
                }, false);
            }
            
        * That will alert, for all clicked divs, the highest value i ever got to, because
            i is being updated outside the closure context of the anonymous function that
            is getting bound as the click handler
            
        * Handling the iterator properly:
        
            var divs = document.getElementsByTagName("div");
            
            for (var i = 0; i < div.length; i++) {
                (function(n) {
                    div[n].addEventListener("click", function() {
                        alert("div #" + n + " was clicked");
                    }, false);
                })(i);
            }
            
    5.6.3 Library Wrapping
        * Don't crowd the global namespace when you write a library.
        * Closures lets you keep as much of your library private as possible
        * Example from jQuery:
        
            (function() {
                var jQuery = window.jQuery = function() {
                    // initialize
                };
                // ...
            })();
            
        * Different way of getting the same thing:
        
            var jQuery = (function() {
                function jQuery() {
                    // initialize
                }
                // ...
                return jQuery;
            })();
            

Chapter 6: Object-orientation with prototypes

6.1 Instantiation and prototypes
    6.1.1 Object instantiation
        * Prototypes are object blueprints
        * Creating a new instance with a prototyped method:
        
            function Ninja(){}
            
            Ninja.prototype.swingSword = function() {
                return true;
            };
            
            var ninja1 = Ninja();
            assert(ninja1 === undefined, "No instance created.");
            
            var ninja2 = new Ninja();
            assert(ninja2 &&
                   ninja2.swingSword &&
                   ninja2.swingSword(),
                   "Instance exists and method is callable.");
                   
        * Method is attached to the prototype
        * "When a function is called as a constructor via the new operator, its context
            is defined as the new object instance. This means that in addition to attaching
            properties via the prototype, we can initialize values within the constructor
            function via the this parameter."
        * Observing the precedence of initialization activities:
        
            function Ninja() {
                this.swung = false;
                this.swingSword = function() {
                    return !this.swung;
                };
            }
            
            Ninja.prototype.swingSword = function() {
                return this.swung;
            };
            
            var ninja = new Ninja();
            assert(ninja.swingSword(), "Called the instance method, not the prototype one.");
            
        * Both methods have the same name, but the instance method added in the constructor
            is the version that gets called.
        * Precedence of initialization operations:
            1.  Properties are bound to the object instance from the prototype
            2.  Properties are added to the object instance within the constructor function
        * "Binding operations within the constructor always take precedence over those in
            the prototype."
        * The prototype is NOT copied into the object on instantiation, but attached to it
        * Overview of the process:
            1.  When a property reference to an object is made, the object itself is checked
                to see if the property exists. If it does, the value is taken. If not...
            2.  The prototype associated with the object is located, and _it_ is checked for
                the property. If it exists, the value is taken, if not...
            3.  The value is undefined.
        
        * The variable points to the object, the constructor property of the object points
            to the constructor object, the prototype property of the constructor points
            to the prototype object.
        * "The prototype is actively attached to the object, and any references to object
            properties are reconciled, using the prototype if necessary, _at the time of reference._"
        * Further precedence example:
        
            function Ninja() {
                this.swung = true;
                this.swingSword = function() {
                    return !this.swung;
                };
            }
            
            var ninja = new Ninja();
            
            Ninja.prototype.swingSword = function() {
                return this.swung;
            };
            
            assert(ninja.swingSword(), "Called the instance method, not the prototype method.");
            
        * Even when the prototype is augmented with a same-named member after the constructor
            runs, the instance member still is the one that takes precedence.
            
    6.1.2 Object typing via constructors
        * Example code for examining the type of an instance and its constructor:
        
            function Ninja() {}
            
            var ninja = new Ninja();
            
            assert(typeof ninja == "object", "Instance is object type.");
            
            assert(ninja instanceof Ninja, "instanceof identifies the constructor");
            
            assert(ninja.constructor == Ninja, "The ninja object was created by the Ninja function.");
            
        * Example of instantiating a new object using a reference to a constructor:
        
            function Ninja() {}
            
            var ninja = new Ninja();
            
            var ninja2 = new ninja.constructor();
            
            assert(ninja2 instanceof Ninja, "It's a Ninja!");
            assert(ninja !== ninja2, "But not the same one.");
            
        * Works even if the constructor itself is out of scope.
        
    6.1.3 Inheritance and the prototype chain
        * Best technique for creating a multi-level prototype chain is to use an instance
            of an object as the other object's prototype:
            
            SubClass.prototype = new SuperClass();
            
        * Like:
        
            Ninja.prototype = new Person();
            
        * Example:
        
            function Person(){}
            Person.prototype.dance = function(){};
            
            function Ninja(){}
            
            Ninja.prototype = new Person();
            
            var ninja = new Ninja();
            assert(ninja instanceof Ninja, "Ninja gets stuff from the Ninja prototype");
            assert(ninja instanceof Person, "...and the Person prototype");
            assert(ninja instanceof Object, "...and the Object prototype");
            assert(typeof ninja.dance == "function", "...and can dance.");
            
        * Note: DO NOT use the Person prototype directly as the Ninja prototype, like
        
            Ninja.prototype = Person.prototype;
            
        * If you do that, all changes to Ninja.prototype will also effect Person.prototype.
        
    6.1.4 HTML DOM prototypes
        * In modern browsers (IE 8+, FF, Safari, Opera), all DOM elements inherit from an
            HTMLElement constructor. Consequently, you can extend any HTML node:
            
            <div id="parent">
                <div id="a">I'm going to be removed.</div>
                <div id="b">Me too!</div>
            </div>
            
            <script>
            HTMLElement.prototype.remove = function() {
                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                }
            };
            
            // The old fashioned way:
            var a = document.getElementById('a');
            a.parentNode.removeChild(a);
            
            // The new hotness:
            document.getElementById('b').remove();
            
        * Note that HTMLElement prototypes don't exist in IE prior to 8
        * Also, you can't instantiate HTML elements from their constructor function, like:
        
            // DOESN'T WORK:
            var elem = new HTMLElement();
            
6.2 The gotchas!
    6.2.1 Extending Object
        * If you extend Object.prototype, every object gets that feature.
        * Example of a problem:
        
            Object.prototype.keys = function() {
                var keys = [];
                for (var p in this) keys.push(p);
                return keys;
            };
            
            var obj = {a: 1, b: 2, c: 3};
            
            assert(obj.keys().length == 3, "There are three properties in this object.");
            
        * Whomp whomp, that fails--you added another property by adding keys itself
        * To beat it, use hasOwnProperty()
        
    6.2.2 Extending Number
        * Reasonably safe to extend most native prototypes, except Object
        * Number is problematic though. Example:
        
            Number.prototype.add = function(num) {
                return this + num;
            };
            
            var n = 5;
            assert(n.add(3) == 8, "Works when the number is a variable.");
            assert((5).add(3) == 8, "Also works for a number in parens.");
            assert(5.add(3) == 8, "What about a literal?"); // Syntax parser can't even handle this
        
        * Solution: don't screw with Number.prototype.
        
    6.2.3 Subclassing native objects
        * You subclass Object all the time, but if you try with, say, Array:
        
            function MyArray(){}
            
            MyArray.prototype = new Array();
            
            var mine = new MyArray();
            mine.push(1,2,3);
            
            assert(mine.length == 3, "All the items are in our subclassed array.");
            assert(mine instanceof Array, "Verify that we implement Array functionality.");
            
        * That works, but not in IE, because the length property is special there and
            doesn't react well to being screwed with.
            
        * Better strategy is to implement individual pieces of functionality from natives:
        
            function MyArray(){}            
            MyArray.prototype.length = 0; // set up a class with a length property
            
            (function() {
                var methods = ['push', 'pop', 'shift', 'unshift', 'slice', 'splice', 'join'];
                
                for (var i = 0; i < methods.length; i++) {
                    (function(name) {
                        MyArray.prototype[name] = function() {
                            return Array.prototype[name].apply(this, arguments);
                        };
                    })(methods[i]);
                }
            })();
            
            var mine = new MyArray();
            assert(mine.length == 3, "All items are on our sub-classed array.");
            assert(!(mine instanceof Array), "But we aren't subclassing Array.");
            
    6.2.4 Instantiation Issues
        * If you don't call a constructor with new, you're in for a world of hurt.
        * Test within a function for whether it's being called as a constructor:
        
            function Test() {
                return this instanceof arguments.callee;
            }
            
            assert(!Test(), "Didn't instantiate, returns false.");
            assert(new Test(), "Did instantiate, returns true.");
            
        * Caveat: arguments.callee is deprecated going forward, and this assumes a lot
            about the coder's intentions--probably best to avoid testing for new and
            let people make their own mistakes.
            
6.3 Writing class-like code
    * This section adds a subClass() method to Object.prototype--interesting, but I'm
        not in need of it in particular.
        

Chapter 7: Regular Expressions

7.1 Why regular expressions rock
7.2 A regular expression refresher
7.3 Compiling Regular Expressions
    * You can get some speed benefits by precompiling reused regexes
    * Example of two ways to create a compiled regex:
    
        var re1 = /test/i;
        var re2 = new RegExp("test", "i");
        
    * Compile once, store it in a variable.
    * Compiling at runtime:
    
        <div class="samurai ninja"></div>
        <div class="ninja samurai"></div>
        <div></div>
        <span class="samurai ninja ronin"></span>
        
        <script>
        function findClassInElements(className, type) {
            var elems = document.getElementsByTagName(type || '*');
            
            var regex = new RegExp("(^|\\s)" + className + "(\\s|$)");
            
            var results = [];
            
            for (var i = 0, length = elems.length; i < length; i++) {
                if (regex.test(elems[i].className)) {
                    results.push(elems[i]);
                }
            }
            return results;
        }
        
7.4 Capturing matching segments
7.5 Replacing using functions
7.6 Solving common problems with regex


Chapter 8: Taming threads and timers

8.1 How timers and threading work
    8.1.1 Setting and clearing timers
        * Two methods to create timers, two to clear them--all methods of the window object:
        
        setTimeout      id=setTimeout(fn, delay)    Initiates a timer that will execute the
                                                    passed callback exactly once after the
                                                    delay has elapsed. A value uniquely
                                                    identifying the timer is returned.
        clearTimeout    clearTimeout(id)            Cancels the timer identified by the passed
                                                    value if the timer has not yet fired.
        setInterval     id=setInterval(fn, delay)   Initiates a timer that will continually
                                                    execute the passed callback at the
                                                    specified delay interval, until canceled.
        clearInterval   clearInterval(id)           Cancels the interval timer identified
                                                    by the passed value.
                                                    
    8.1.2 Timer execution within the execution thread
        * Outside of web workers, all JS executes in a single thread in the browser.
        * Handlers must queue up to execute, and no handler interrupts another
        * When an asynchronous event handler occurs, it has to wait on the queue
        * Events have to wait for the main body of code to execute, then the queued events
            can start executing
        * Intervals will only actually queue if there is not an existing event in the queue
            from the same timer--so you don't get two of the same events firing in the same chunk
        * Because of that, you cannot guarantee that a timed event will actually fire
            at the time interval you specify
        
    8.1.3 Differences between timeouts and intervals
        * Example:
        
            // Set a timeout that reschedules itself every 10ms
            setTimeout(function repeatMe() {
                /* some long block of code */
                setTimeout(repeatMe, 10);
            }, 10);
            
            // Set an interval that triggers every 10ms
            setInterval(function() {
                /* some long block of code */
            }, 10);
            
        * The setTimeout version will always have at least a 10ms delay after the previous
            callback execution (possibly more, but never less)
        * setInterval() will attempt to execute a callback every 10ms regardless of when
            the last callback was executed
        * Recap:
        
            - JS engines execute only a single thread at a time, and async events queue
            - If a timer is blocked from immediately executing, it will be delayed until
                the next available time of execution (which may be longer, but never
                shorter than the specified delay)
            - Intervals may end up executing back to back with no delay if they get backed
                up enough, and multiple instances of the same interval handler will never
                be queued up
            - setTimeout() and setInterval() are fundamentally different in how their
                firing frequencies are determined
                
8.2 Minimum timer delay and reliability
    * It's not intuitively obvious what the shortest effective timer delay you can use is
    * At a certain point, a browser is incapable of providing fine enough resolution to
        handle them accurately, because the browser is limited by the timing of the OS
    * A test of 1ms execution loops in multiple browsers, for the first 100 ticks of the
        timer, gives hugely variant results across browsers and OSs
    * Some browsers are approaching 1ms granularity, but they're not there yet.
    * Probably 10 or 15ms is the reasonable practical floor of what you can use
    
8.3 Dealing with computationally expensive processing
    * Complex computation + single execution thread = complicated apps with laggy UI
    * Other than waiting for web workers to be universally available, the best strategy
        is to break up anything that takes more than a few hundred ms into smaller ops
    * We can convert intensive loops and ops into nonblocking operations with timers
    * Example of a long running task:
    
        // Finds the tbody we're going to create a lot of rows for
        var tbody = document.getElementsByTagName("tbody")[0];
        
        // Makes 20k rows, six cols wide
        for (var i = 0; i < 20000; i++) {
            var tr = document.createElement("tr");
            
            for (var t = 0; t < 6; t++) {
                var td = document.createElement('td');
                td.appendChild(document.createTextNode(i + ',' + t));
                tr.appendChild(td);
            }
            
            tbody.appendChild(tr);
        }
        
    * That creates 240k dom nodes--incredibly expensive, will hang the browser
    * Using a timer to break up a long running task:
    
        var rowCount = 20000;
        var divideInto = 4;
        var chunkSize = rowCount / divideInto;
        var iteration = 0;
        
        var table = document.getElementsByTagName('tbody')[0];
        
        setTimeout(function generateRows() {
            var base = (chunkSize) * iteration;
            for (var i = 0; i < chunkSize; i++) {
                var tr = document.createElement('tr');
                for (var t = 0; t < 6; t++) {
                    var td = document.createElement('td');
                    td.appendChild(document.createTextNode((i+base) + "," + t + "," + iteration));
                    tr.appendChild(td);                    
                }
                table.appendChild(tr);
            }
            iteration++;
            if (iteration < divideInto) {
                setTimeout(generateRows, 0);
            }
        }, 0);
        
    * Each chunk of this self-rescheduling function runs a piece of the whole job, but
        is likely not noticeably blocking the UI by itself
        
8.4 Central timer control
    * Having a large number of timers is pretty unwieldy--bad for animations in particular,
        where you have to update a ton of things at once
    * When you have a bunch of timers, you're more likely to trigger a garbage collection
        task in the browser itself, which may cause locking or stuttering
    * All modern animation engines use a technique called central timer control
    * Having central timer control gives us:
        - We only need one timer running per page at a time
        - We can pause and resume the timers at will
        - The process for removing callback functions is trivialized
    * A central timer to manage multiple handlers:
    
        var timers = {
            // Records state variables
            timerID: 0,
            timers: [],
            
            // function to add handlers
            add: function(fn) {
                this.timers.push(fn);
            },
            
            // function to start a timer
            start: function() {
                if (this.timerID) return;
                (function runNext() {
                    if (timers.timers.length > 0) {
                        for (var i = 0; i < timers.timers.length; i++) {
                            // If a callback function returns false, it takes itself off queue
                            if (timers.timers[i]() === false) {
                                timers.timers.splice(i, 1);
                                i--;
                            }
                        }
                        
                        timers.timerID = setTimeout(runNext, 0);
                    }
                })();
            },

            // function to stop a timer            
            stop: function() {
                clearTimeout(this.timerID);
                this.timerID = 0;
            }
        };    

    * Organizing timers like this ensures they will fire in the order you give

8.5 Asynchronous testing
    * Can be difficult to test events that may not occur at a predictable time
    * Simple async test suite:
    
        (function() {
            var queue = [], paused = false;
            
            this.test = function(fn) {
                queue.push(fn);
                runTest();
            };
            
            this.pause = function() {
                paused = true;
            };
            
            this.resume = function() {
                paused = false;
                setTimeout(runTest, 1);
            };
            
            function runTest() {
                if (!paused && queue.length) {
                    queue.shift()();
                    if (!paused) resume();
                }
            }
        })();
        

Chapter 9: Ninja alchemy: runtime code evaluation

9.1 Code evaluation mechanisms
    9.1.1 Evaluation with the eval() method
        * Function in the global scope, executes code passed to it as a string, within
            the current context--return value is value of last evaluated expression
        * Two basic expectations of eval():
            -   It will evaluate the code passed to it as a string
            -   It will execute that code in the scope that eval() was called from
        * Note that anything other than a simple variable, primitive, or assignment needs
            to be wrapped in parens to be returned correctly:
            
            var ninja = eval("({name: 'Ninja'})");
            
        * Versions of IE before 9 need to be tricked to return an eval'd function def:
        
            var fn = eval("false||function() { return true; }");
            
        * When you create a function within a scope via eval, that function inherits
            the closure of that scope
            
    9.1.2 Evaluation via the Function constructor
        * If you instantiate a function object with the Function constructor, the last
            argument you pass it is a string representing the function body:
            
            var add = new Function("a", "b", "return a+b;");
            
    9.1.3 Evaluation with timers
        * Normally you'd pass an inline function or a function reference to a timer, but
            timer methods also accept strings that will be evaluated when the timers fire:
            
            var tick = window.setTimeout('alert("Hi!")', 100);
            
        * Discouraged except in cases where the code to be evaluated must be a runtime string
        
    9.1.4 Evaluation in the global scope
        * We may want to evaluate strings in the global scope despite the fact that it may
            not be the current execution scope
        * You can assign things directly to window.whatever, but that doesn't modify the
            current execution scope, it just reaches out to the head object
        * Injecting a dynamic <script> tag into the document with the contents to execute
            will put the execution scope back into the global scope
        * Technique from Andrea Giammarchi for cross-browser script tag injection, adapted here:
        
            <script type="text/javascript">
            function globalEval(data) {
                data = data.replace(/^\s*|\s*$/g, "");
                if (data) {
                    var head = document.getElementsByTagName("head")[0] ||
                               document.documentElement,
                        script = document.createElement('script');
                        
                    script.type = 'text/javascript';
                    script.text = data;
                    
                    head.appendChild(script);   // attach to the DOM
                    head.removeChild(script);   // remove from the DOM
                }
            }
            
            window.onload = function() {
                (function() {
                    globalEval("var test = 5;");
                })();
                
                assert(test === 5, "Code was evaluated globally.");
            };
            </script>
            
    9.1.5 Safe code evaluation
        * Generally runtime eval is pretty unsafe--too many ways for it to go wrong
        * Google's 'Caja' project tries to convert JS to a safer form, immune to attack
        
9.2 Function "decompilation"
    * Performed by the toString method of function objects:
    
        function test(a) { return a + a; }
        
        assert(test.toString() === "function test(a) { return a + a; }", "Function decompiled.");
        
    * The value returned will contain all the whitespace of the original declaration
    * Example adapted from Prototype that infers function parameter names from decompilation:
    
        function argumentNames(fn) {
            var found = /^[\s\(]*function[^(]*\(\s*([^)]*?)\s*\)/.exec(fn.toString());
            
            return found && found[1] ?
                found[1].split(/,\s*/) :
                [];
        }
        
    * Some browsers, like Opera Mini, don't support decompilation
    * Don't do browser detection to find out, use feature simulation, like:
    
        var FUNCTION_DECOMPILATION = /abc(.|\n)*xyz/.test(function(abc){xyz;});
        assert(FUNCTION_DECOMPILATION, "Function decomp works in this browser.");
        
    * Tests implicit call of inline function's toString against a regex
    
9.3 Code evaluation in action
    9.3.1 Converting JSON
        * Biggest reason for evaluating runtime strings is to turn JSON into objects
        * Most browsers support JSON.parse() and JSON.stringify(), but some early ones don't
        * One minor gotcha to getting data back from a json string--have to wrap it in parens:
        
            var json = '{"name":"Ninja"}';
            var object = eval("("+json+")");
            
        * Carefully consider security when using eval on remote server json
        
    9.3.2 Importing Namespaced Code
        * If you want to bring namespaced code into the current context, usually you resort to:
        
            var DOM = base2.DOM;
            var JSON = base2.JSON;
            
        * The base2 library has an interesting solution--any time a new class or module is
            added to a base2 package, a string of executable code is constructed that can
            be evaluated to introduce the functions into the current context:
            
            // Assumes base2 is loaded.
            base2.namespace =
                "var Base=base2.Base; var Package=base2.Package;" +
                [...] +
                "var doc=base2.doc;";
                
            eval(base2.namespace);
            
    9.3.3 JavaScript compression and obfuscation
        * Don't pre-optimize--write for clarity, then compress for transmission.
        * Dean Edwards wrote Packer to help with the problem
        * Gives you a string to eval that's had variable names replaced, whitespace removed, etc
        * Problem is the overhead of decompressing every time the script loads
        * Important to remember that smaller code downloads faster, but doesn't necessarily
            evaluate faster--and the combination of download+eval is what makes up the time
        * Packed code isn't faster than minimized code--but it is obfuscated
        
    9.3.4 Dynamic code rewriting
        * Because we can decompile functions to strings, we can manipulate their contents
        * Screw.Unit is a unit testing framework that rewrites code on the fly to include
            its own functions in the global scope for individual function calls it tests
        
    9.3.5 Aspect-oriented script tags
        * AOP, aspect-oriented programming, is "a programming paradigm which aims to increase
            modularity by allowing the separation of cross-cutting concerns"
        * Basically it's a technique by which code is injected and executed at runtime to handle
            cross-cutting things like logging, caching, security, etc
        * You can use non standard type attributes to the script tag to get the browser to
            ignore the contents of the script tag, so you can pull it in later
        * Example:
        
            <script type="text/javascript">
            window.onload = function() {
                var scripts = document.getElementsByTagName('script');
                for (var i = 0; i < scripts.length; i++) {
                    if (scripts[i].type = 'x/onload') {
                        globalEval(scripts[i].innerHTML);
                    }
                }
            };
            </script>
            
            <script type="x/onload">
            assert(true, "Executed on page load.");
            </script>
            
    9.3.6 Metalanguages and DSLs
        * "Domain specific languages" describes stuff like Processing.js and Objective-J
        

Chapter 10: With statements

10.1 What's with "with"?
    * A with statement creates a scope within which the properties of a specified object
        can be referenced without a prefix
        
    10.1.1 Referencing properties within a with scope
        * Example of a with scope using an object:
        
            var use = "other";
            
            var katana = {
                isSharp: true,
                use: function() {
                    this.isSharp = !this.isSharp;
                }
            };
            
            with (katana) {
                assert(use !== "other" && typeof use == "function",
                       "use is a function from the katana object.");
                assert(this !== katana,
                       "context isn't changed; keeps its original value");
            }
            
            assert(use === "other",
                   "outside the with use is unaffected");
            assert(typeof isSharp === "undefined",
                   "outside the with the properties don't exist");
                   
        * The properties of the katana object are introduced into the scope created by the
            with statement. Within the scope, we can reference the properties directly
            without the katana prefix as if they were top level variables and methods.
        * Within a with statement, simple references can resolve to an object's properties
        * Within a with statement, the object's properties take absolute precedence over
            variables of the same name defined in higher level scopes
        * The function context (this) is unaffected by the with statement
    
    10.1.2 Assignments within a with scope
        * Example of assignments in with scopes:
        
            var katana = {
                isSharp: true,
                use: function() {
                    this.isSharp = !this.isSharp;
                }
            };
            
            with(katana) {
                isSharp = false;    // assigns to existing property
                
                assert(katana.isSharp === false, "Properties can be assigned.");
                
                cut = function() {      // attempts to create a new property
                    isSharp = false;
                };
                
                // This will fail:
                assert(typeof katana.cut == "function", "New properties can be created on the scoped object.");
                
                // This will pass:
                assert(typeof window.cut == "function", "New properties are created in the global scope");
            }
            
        * Unreferenced assignments that are not to an existing property on the with scope's
            object are made to the global context. 
            
    10.1.3 Performance Considerations
        * Slows the execution performance of any JS it encompasses
        * Across browsers and operating systems, code executed in with scopes was dramatically
            slower, even when there was no access of the object brought in at all
            
10.2 Real-world examples
    * From Prototype:
    
        Object.extend(String.prototype.escapeHTML, {
            div: document.createElement('div'),
            text: document.createTextNode('')
        });
        
        // Prevents having to use very long reference names
        with (String.prototype.escapeHTML) div.appendChild(text);
        
    * Better way to do it, without the with statement:
    
        (function(s) {
            s.div.appendChild(s.text);
        })(String.prototype.escapeHTML);
        
    * Examples that allow for terser code, from base2:
    
        var Rect = Base.extend({
            constructor: function(left, top, width, height) {
                this.left = left;
                this.top = top;
                this.width = width;
                this.height = height;
                this.right = left + width;
                this.bottom = top + height;
            },
            
            contains: function(x,y) {
                with (this) return x >= left && x <= right && y >= top && y <= bottom;
            },
            
            toString: function() {
                with (this) return [left, top, width, height].join(',');
            }
        });
        
    * From Firebug, a complex example:
    
        const evalScriptPre = "with(__scope__.vars) { with(__scope__.api) { " +
            " with(__scope__.userVars){ with(window) {";
        const evalScriptPost = "}}}}";
        
    * Used in the debugger, gives user access to local variables, the firebug API, and the 
        global object, all within the JS console.
    * Note that the nested use of with gives precedence to the window object over __scope__
    
10.33 Importing Namespaced Code
    * Difference between these two pieces:
    
        YAHOO.util.Event.on(
            [YAHOO.util.Dom.get('item'), YAHOO.util.Dom.get('otheritem')],
            'click', function() {
                YAHOO.util.Dom.setStyle(this, 'color', '#C00');
            }
        );
        
        with (YAHOO.util.Dom) {
            YAHOO.util.Event.on([get('item'), get('otheritem')], 'click',
                function(){ setStyle(this, 'color', '#C00'); });
        }
        
10.4 Testing
    * Common problem: attending to the synchronization between the assertion methods and the
        test case currently being run--big problem with async tests
    * Solution: create a central tracking object for each test run
    * Example that uses with(this) to avoid lots of this.* calls:
    
        new Test.Unit.Runner({
            testSliderBasics: function(){ with(this) {
                var slider = new Control.Slider('handle1', 'track1');
                assertInstanceOf(Control.Slider, slider);
                assertEqual('horizontal', slider.axis);
                assertEqual(false, slider.disabled);
                assertEqual(0, slider.value);
                slider.dispose();
            }},
            // ...
        });
        
10.5 Templating with 'with'
    * General goals for a templating system?
        - There should be a way to run embedded code and print out data
        - There should be a means of caching compiled templates
        - It should be simple to access mapped data
    * Example of a simple template to generate an html page:
    
        <html>
        <head>
            <script type="text/tmpl" id="colors">
                <p>Here's a list of <%= items.length %> items:</p>
                <ul>
                    <% for (var i = 0; i < items.length; i++) { %>
                    <li style="color:<%= colors[i % colors.length] %>">
                        <%= items[i] %></li>
                    <% } %>
                </ul>
                and here's another...
            </script>
            <script type="text/tmpl" id="colors2">
                <p>Here's a list of <%= items.length %> items:</p>
                <ul>
                    <% for (var i = 0; i < items.length; i++) {
                        print("<li style='color:", colors[i % colors.length], "'>", items[i], "</li>");
                    } %>
                </ul>
            </script>
            <script type="text/javascript" src="tmpl.js"></script>
            <script type="text/javascript">
                var colorsArray = ['red', 'green', 'blue', 'orange'];
                
                var items = [];
                for (var i = 0; i < 10000; i++) {
                    items.push("test");
                }
                
                function replaceContent(name) {
                    document.getElementById('content').innerHTML = 
                        tmpl(name, {colors: colorsArray, items: items});
                }
            </script>
        </head>
        <body>
            <input type="button" value="Run Colors" onclick="replaceContent('colors')" />
            <input type="button" value="Run Colors2" onclick="replaceContent('colors2')" />
            <p id="content">Replaced content will go here.</p>
        </body>
        </html>
        
    * A templating solution:
    
        (function() {
            var cache = {};
            
            this.tmpl = function tmpl(str, data) {
                var fn = !/\W/.test(str) ?
                    cache[str] = cache[str] || tmpl(document.getElementById(str).innerHTML) :
                    
                    new Function('obj',
                        'var p=[],print=function(){p.push.apply(p,arguments);};' +
                        'with(obj){p.push("' +
                        
                        str
                            .replace(/[\r\t\n]/g, " ")
                            .split("<%").join("\t")
                            .replace(/((^|%>)[^\t]*)'/g, "$1\r")
                            .replace(/\t=(.*?)%>/g, "',$1,'")
                            .split("\t").join("');")
                            .split("%>").join(".ppush('")
                            .split("\r").join(\\'")
                        + "'; } return p.join('');");
                        
                return data ? fn(data) : fn;
            };
        })();
                    
                    
Chapter 11: Developing Cross-browser Strategies

11.1 Choosing Which Browsers to Support
    * Choosing to support a browser means:
        - We'll actively test against that browser with our test suite
        - We'll fix bugs and regressions associated with that browser
        - The browser will execute our code with a reasonable level of performance
    * Most projects try to support the previous, current, and upcoming releases of:
        - IE
        - FF
        - Safari
        - Chrome
        - Opera
    * Make a browser support matrix to check your progress against
    * "Quality should never be sacrificed for coverage."
    
11.2 The five major development concerns
    * The five major points of concern for reusable JS:
        - Browser bugs
        - Browser bug fixes
        - Missing features in the browsers
        - External code
        - Browser regressions
        
    11.2.1 Browser bugs and differences
        * Any features we provide should completely and verifiably correct for bugs across
            all supported browsers
        * We need a comprehensive test suite to cover common and edge cases
        * Tricky point: making sure fixes in js are future proof against browser fixes
        
    11.2.2 Browser bug fixes
        * Issue: fixes in your code that break functionality when the browser maker issues
            a fix for the thing you were correcting for
        * When unsure of whether something is a bug, check the spec
        
    11.2.3 Living with external code and markup
        * "Our code must not only be able to withstand living with poorly written external 
            code, it must itself take care not to have adverse effects on the code with 
            which it lives."
        * Manning book "Third-Party JavaScript" is good on the topic
        * Strategies for dealing with it:
            - Encapsulating our code
            - Dealing with less-than-exemplary code
            - Avoiding implanted properties
            - Coping with greedy ids
            - Order of stylesheets
        * Encapsulating our code:
            - Keep your global footprint as small as possible--one variable if possible
            - do it by namespacing your code
            - avoid modifying existing variables, function prototypes, or DOM elements
        * Dealing with less-than-exemplary code
            - other people's code may intentionally screw with core language features
        * Avoiding implanted properties
            - You can use hasOwnProperty to detect extensions to Object.prototype vs own methods:
            
                Object.prototype.ronin = "ronin";
                
                var object = { ninja: 'value' };
                object.samurai = 'samurai';
                
                assert(object.hasOwnProperty('ronin'), 'ronin is a property'); // fails
                assert(object.hasOwnProperty('ninja'), 'ninja is a property'); // passes
                assert(object.hasOwnProperty('samurai'), 'samurai is a property'); // passes
                
            - Particularly problematic with a for..in loop
            
        * Coping with greedy ids
            - Example:
                
                <form id="form" action="/conceal">
                    <input type="text" id="action" />
                    <input type="submit" id="submit" />
                </form>
                
                <script>
                // what will end up a reference to input#action element
                var what = document.getElementById('form').action;
                
                // causes a script error: Property 'submit' of object #<HTMLFormElement> 
                //  is not a function
                document.getElementById('form').submit();
                </script>
                
            - The browser added properties to the <form> element for each of the input elements
                within the form that reference the element
            - The name of the added property is taken from the id value of the input elements
            - If that id value overloads an existing property of the form element, the
                original properties are replaced by the new property
            - To deal with, avoid id values that can conflict with standard property names
            
        * Order of stylesheets
            - If stylesheets are loaded after scripts, any references from the script to
                the style information can cause problems
            - Make sure you load external stylesheets prior to external scripts
            
    11.2.4 Missing features
        * Graceful degradation
            - Write code defensively so it degrades gracefully, or provides fallbacks for
                missing functionality
        * Backward compatibility
            - Actively direct known, failing browsers to an alternative version of the page
            - Make sure your alternative works, even if it's very simple
            
    11.2.5 Regressions
        * Bugs or non-backward-compatible API changes that browsers have introduced and
            that cause our code to break in unpredictable ways.
        * Example for anticipating IE 9's support for DOM level 2 event handlers:
        
            function bindEvent(element, type, handle) {
                if (element.addEventListener) {
                    // Binds via the standard API
                    element.addEventListener(type, handle, false);
                }
                else if (element.attachEvent) {
                    // Binds via a proprietary API
                    element.attachEvent("on" + type, handle);
                }
            }
            
        * We can't predict what bugs will be introduced by a browser, so be diligent
        
11.3 Implementation Strategies
    11.3.1 Safe cross-browser fixes
        * Simplest and safest cross-browser fixes:
            - have no negative effects or side effects on other browsers
            - use no form of browser or feature detection
        * Example that ignores negative height and width values for IE:
        
            if ((key == 'width' || key == 'height') && parseFloat(value) < 0) {
                value = undefined;
            }
            
        * That prevented an error in IE, and had no tangible effect in other browsers
        * Example that disallows all attempts to manipulate a type attribute on
            injected input elements, rather than allow just IE to throw a proprietary one
            
            if (name == 'type' &&
                elem.nodeName.toLowerCase() == 'input' &&
                elem.parentNode) {
              throw "type attribute can't be changed";
            }
            
    11.3.2 Object detection
        * Determines if a certain object or property exists, and if so assume that it gives
            the implied functionality
        * Whenever possible, default to the standard way of performing an action
        * Example:
        
            if (typeof document !== "undefined" &&
                (document.addEventListener || document.attachEvent) &&
                document.getElementsByTagName &&
                document.getElementById) {
              // we have enough of an API to work with to build our application
            }
            else {
                // Provide fallback
            }
            
    11.3.3 Feature simulation
        * Rather than just an object lookup, feature simulation does a runthrough to test
            that a feature is present and works as expected
        * Example to determine if getElementsByTagName() includes comments (as it does in IE8)
        
            window.findByTagWorksAsExpected = (function() {
                var div = document.createElement('div');
                div.appendChild(document.createComment('test'));
                return div.getElementsByTagName("*").length === 0;
            })();
            
        * Test for the integrity of a feature, not a specific bug's presence or absence
        
    11.3.4 Untestable browser issues
        * Some known issues that are impossible to test using any conventional JS interactions:
            - Event handler bindings: you can't test whether an event handler has been bound
            - Event firing: possible to see whether a browser has a means of binding an
                event, but no way to test whether a browser will actually fire that event
            - CSS property effects: you can't determine whether changing certain CSS properties
                actually changes the visual representation of the display
            - Browser crashes: you can't catch crashes like you can exceptions--testing for
                the problem will itself cause the browser to crash
            - Incongruous APIs: when a bug is so bad it that a workaround would make an
                inconsistent api across browsers, you may have to kill the feature for everybody
            - API Performance: try to use APIs that have good performance--but that's hard
                when the same api may perform differently in different browsers
            - Ajax issues: Finding out whether ajax calls actually work is either not possible
                or incurs a lot of overhead to do a test call
                
11.4 Reducing assumptions
    * Test for proper behavior, not the presence of a specific bug
    * Don't do UA detection
    * Know when to settle for having some assumptions included in your code
    
Chapter 12: Cutting through attributes, properties, and CSS

12.1 DOM attributes and properties
    * When accessing the values of element attributes, you can use DOM methods like
        getAttribute and setAttribute, or properties of the DOM objects:
    
        e.getAttribute('id')
        e.id
        
    * Code demonstrating how attribute values and properties behave:
    
        <div></div>
        <script type="text/javascript">
        window.onload = function() {
            var div = document.getElementByTagName('div')[0];
            
            div.setAttribute('id', 'ninja-1');
            assert(div.getAttribute('id') === 'ninja-1', 'Attribute successfully changed.');
            
            div.id = 'ninja-2';
            assert(div.id === 'ninja-2', 'Property successfully changed.');
            
            div.id = 'ninja-3';
            assert(div.id === 'ninja-3', 'Property successfully changed.');
            assert(div.getAttribute('id') === 'ninja-3', 'Attribute changed via property.');
            
            div.setAttribute('id', 'ninja-4');
            assert(div.id === 'ninja-4', 'Property changed via attribute.');
            assert(div.getAttribute('id') === 'ninja-4', 'Attribute successfully changed.');            
        };
        </script>    
                
    * Changing the property changes the attribute and vice versa, but they do not share the
        same value--they're linked, but not always identical.
    
    12.1.1 Cross-browser naming
        * Property names across browsers tend to be more the same than attribute names
        * Libraries will standardize this, but without them you have to come up with solutions
        
    12.1.2 Naming restrictions
        * Attributes have looser naming rules than properties, which are js identifiers
        * ECMAScript says certain keywords can't be used as property names
        * Cases where property names and attribute names differ:
        
            Attribute                       Property
            for                             htmlFor
            class                           className
            readonly                        readOnly
            maxlength                       maxLength
            cellspacing                     cellSpacing
            rowspan                         rowSpan
            colspan                         colSpan
            tabindex                        tabIndex
            cellpadding                     cellPadding
            usemap                          useMap
            frameborder                     frameBorder
            contenteditable                 contentEditable
            
        * There may be additional html5 elements and attributes that have this as well
        
    12.1.3 Differences between XML and HTML
        * Automatic correspondence between attributes and properties is HTML-DOM-only
        * XML DOM doesn't automatically create properties, so you have to get them manually
        * Good to put a check in your code to find out if an element or doc is XML:
        
            function isXML(elem) {
                return (elem.ownerDocument || elem.documentElement.nodeName.toLowerCase() !== 'html');
            }
            
    12.1.4 Behavior of custom attributes
        * Any attributes not natively specified in the HTML DOM will not become properties
        * If you're not sure about an attribute:
        
            var value = element.someValue ? element.someValue : element.getAttribute('someValue');
            
        * Preface all custom attributes with data-
        
    12.1.5 Performance considerations
        * In general property access is faster than the corresponding DOM methods, particularly in IE
        * Example here that does 5M iterations across getAttribute, setAttribute, property get/set
        * Outcome is that properties are a little less than twice as fast, and much faster in IE
        * A method to access a value by property, and DOM method by fallback:
        
            (function() {
                var translations = {
                    'for': 'htmlFor',
                    'class': 'className',
                    'readonly': 'readOnly',
                    'maxlength': 'maxLength',
                    'cellspacing': 'cellSpacing',
                    'rowspan': 'rowSpan',
                    'colspan': 'colSpan',
                    'tabindex': 'tabIndex',
                    'cellpadding': 'cellPadding',
                    'usemap': 'useMap',
                    'frameborder': 'frameBorder',
                    'contenteditable': 'contentEditable'
                };
                
                window.attr = function(element, name, value) {
                    var property = translations[name] || name,
                        propertyExists = typeof element[property] !== 'undefined';
                        
                    if (typeof value !== 'undefined') {
                        if (propertyExists) {
                            element[property] = value;
                        }
                        else {
                            element.setAttribute(name, value);
                        }
                    }
                    
                    return propertyExists ?
                        element[property] :
                        element.getAttribute(name, value);
                };      
            })();
            
12.2 Cross-browser attribute issues
    12.2.1 DOM id/name expansion
        * Problem: the browsers take the id or name values of form input elements and add
            references to the elements as properties of the <form> element under those names
        * Any existing property of the form element with the same name will be overwritten
        * Additionally, IE also replaces the attribute values with references to the elements
        * However! It is possible to gain access to the original DOM node representing
            the element attribute itself--that node is untainted by the browser's tinkering:
            
            var actionValue = element.getAttributeNode('action').nodeValue;
            
    12.2.2 URL normalization
        * In all modern browsers, when accessing a property that references a url, like href,
            src, or action, the url value is automatically converted into a full canonical url
        * Test demonstrating this:
        
            <a href="listing-12.5.html" id="testSubject">Self</a>
            
            <script type="text/javascript">
            var link = document.getElementById('testSubject');
            
            var linkHref = link.getAttributeNode('href').nodeValue;
            
            assert(linkHref === 'listing-12.5.html', 'link property value is ok');
            // This test fails:
            assert(link.getAttribute('href') === linkHref, 'link attribute not modified');
            </script>
            
        * You can use the dom node trick to get the raw value.
        
    12.2.3 The style attribute
        * You can get the style information of the element with element.style, but getting
            the actual string that made up the original style declaration in the html is harder
        * getAttribute('style') works in most browsers, but not IE, where you have to look
            at element.style.cssText
        
    12.2.4 The type attribute
        * IE gotcha for 8 and earlier--no reasonable workaround
        * Once an input element has been inserted into a doc, its type attribute
            can no longer be changed--IE throws an exception if you try.
        * Example:
        
            <form id="testForm" action="/"></form>
            
            <script type="text/javascript">
            window.onload = function() {
                var input = document.createElement('input');
                
                input.type = 'text';
                assert(input.type == 'text', 'Input type is text.');
                
                document.getElementById('testForm').appendChild(input);
                
                input.type = 'hidden';
                assert(input.type == 'hidden', 'Input type changed to hidden.');
            };
            </script>
            
        * Passes in all browsers but IE 8 and earlier, where it throws an exception
        * Stopgap measures:
            - Create a new input element, copy over all properties and attributes, replace 
                the original element with the new one--attendant problems are event handlers,
                since you can't find out whether an element has any assigned to it; any
                existing references to the original element then become invalid.
            - In any API you create, reject attempts to change the type value
            
    12.2.5 The tab index problem
        * Hard to know how to get the tabindex of an element, little agreement on how it
            should be done
        * You can request getAttribute('tabIndex') and element.tabIndex, but browsers return
            0 for the property and null for the attribute for elements with no explicit index
        * Consequently, you can't tell what the tab index of an arbitrary element actually is
        
    12.2.6 Node names
        * Determining the name of a particular node can be tricky
        * The case sensitivity changes per document type--HTML docs return nodeName as all caps
            version of the node, XML and XHTML return the name as specified by the author
        * You probably want to normalize to lower case:
        
            var all = document.getElementsByTagName('*')[0];
            
            for (var i = 0; i < all.length; i++) {
                var nodeName = all[i].nodeName.toLowerCase();
                if (nodeName === "div" || nodeName === "ul") {
                    all[i].className = "found";
                }
            }
            
12.3 Styling attribute headaches
    * Getting and setting styling attributes can be a problem--two main approaches, style
        property and the attribute value
    
    12.3.1 Where are my styles?
        * The DOM style property is initially set from the value specified from the style
            attribute in the markup
        * During page execution, script can set or modify values in the style object
        * No styles from stylesheets are available on the element's style object

    12.3.2 Style property naming
        * Some style names differ across browsers
        * Multi-word css style names are converted to camel case in javascript
        * You could write a wrapper function to parse style names, or just remember the difference
        
    12.3.3 The float style property
        * float is a reserved keyword in JavaScript, so the browser has to have an alternate
            name for the float css property
        * Most browsers use css-Float, IE uses styleFloat
        
    12.3.4 Conversion of pixel values
        * When setting a numeric value for a style property, you have to give the units
        * Not all numeric values represent pixels--some styles are number only:
            - z-index
            - font-weight
            - opacity
            - zoom
            - line-height
        * When reading a pixel value from a style attribute, use parseFloat()
        
    12.3.5 Measuring heights and widths
        * If explicit values for 'height' and 'width' weren't provided, they default to 'auto',
            so you can't get the element height or width off of them
        * offsetHeight and offsetWidth provide the actual height/width of an element
        * Those include the padding of the element
        * When an element is display: none, it has no dimensions
        * If you want the non-hidden values, you can do this:
            1.  change the display property to block
            2.  set visibility to hidden
            3.  set position to absolute
            4.  grab the dimension values
            5.  restore the changed properties

    12.3.6 Seeing through opacity
        * IE before 9 used proprietary alpha filter notation for opacity
        * Often you'll see things like this in a style sheet:
        
            opacity: 0.5;
            filter: alpha(opacity=50);
            
        * Browsers that support opacity will always normalize an opacity value less than 
            1.0 with a leading 0, so you can detect browser capability with:
            
            var div = document.createElement('div');
            div.setAttribute('style', 'opacity:.5');
            var OPACITY_SUPPORTED = div.style.opacity === "0.5";
            
    12.3.7 Riding the color wheel
        * Getting color info back from styles is at the mercy of the page author and browser
        * CSS3 color formats:
        
            keyword             any of the recognized HTML color keywords
            #rgb                short hex
            #rrggbb             long hex
            rgb(r,g,b)          decimal from 0 to 255 or 0% to 100%
            rgba(r,g,b,a)       same, with alpha channel
            hsl(h,s,l)          hue, saturation, lightness, hue from 0 to 360, s and l 0%-100%
            hsla(h,s,l,a)       same, with alpha channel
            
        * You'd need to write a getColor function to handle all the corner cases well
        
12.4 Fetching computed styles
    * The computed style of an element is a combination of all the styles applied to it
    * Standard api available everywhere but IE before 9 is window.getComputed-Style()
    * function to get the computed style, browser independent:
    
        function fetchComputedStyle(element, property) {
            if (window.getComputedStyle) {
                var computedStyles = window.getComputedStyle(element);
                
                if (computedStyles) {
                    property = property.replace(/(A-Z)/g, '-$1').toLowerCase();
                    return computedStyles.getPropertyValue(property);
                }
            }
            
            else if (element.currentStyle) {
                property = property.replace(
                    /-([a-z])/ig,
                    function(all, letter) { return letter.toUpperCase(); }
                );
                return element.currentStyle[property];
            }
        }
        
Chapter 13: Surviving events
    * DOM implementation at level 0 is usable across browsers, but level 2 is not
    * level 2 has features you probably need though
    
13.1 Binding and unbinding event handlers
    * We'll call DOM level 2 the DOM model, and the IE proprietary model the IE model
    * They're largely similar functionally, except that the IE model doesn't provide
        a way to listen for the capturing stage of an event, only the bubbling phase
    * In the DOM level 2 event model, events propagate from the event target up to the
        root of the DOM during the 'bubble phase', and then traverse back down the
        tree to the target during the 'capture phase'
    * The IE model's implementation doesn't set a context on the bound handler, so 'this'
        in the IE model will refer to the global window object
    * The IE model doesn't pass the event information to the handler, it tacks it onto
        the global window object
    * We need to use browser-specific ways to do almost anything for events:
        - Binding a handler
        - Unbinding a handler
        - Obtaining event information
        - Obtaining the event target
    * Example of providing proper context when binding event handlers:
    
        if (document.addEventListener) {    // the DOM model
            this.addEvent = function (elem, type, fn) {
                elem.addEventListener(type, fn, false);
                return fn;
            };
            
            this.removeEvent = function (elem, type, fn) {
                elem.removeEventListener(type, fn, false);
            };
        }
        else if (document.attachEvent) {    // the IE model
            this.addEvent = function (elem, type, fn) {
                // fix the context problem with anonymous wrapper fn
                var bound = function() {
                    return fn.apply(elem, arguments);
                };
                elem.attachEvent("on" + type, bound);
                return bound;
            };
            
            this.removeEvent = function (elem, type, fn) {
                elem.detachEvent("on" + type, fn);
            };
        }
        
    * Important to return the function since in order to unbind later we need a reference
    * Note that when you use this setup your functions can't rely on callee, because the
        returned function (under the IE model) is the anonymous function, not the passed in fn
    
13.2 The Event object