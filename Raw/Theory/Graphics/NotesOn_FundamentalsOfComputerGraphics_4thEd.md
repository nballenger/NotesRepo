# Notes on Fundamentals of Computer Graphics, 4th Ed.

By Peter Shirley, Steve Marschner; AK Peters / CRC Press 2016; ISBN 9781498785907

## Chapter 1: Introduction

1. Graphics Areas
    * Major areas of computer graphics:
        * Modeling - specification of shape and appearance properties
        * Rendering - creation of shaded images from 3D models
        * Animation - illusion of motion through sequential images
    * Related areas that may or may not be core areas:
        * User interaction
        * Virtual reality
        * Visualization
        * Image processing
        * 3d scanning
        * Computational photography
1. Major Applications
    * video games
    * cartoons
    * visual effects
    * animated films
    * CAD/CAM
    * simulation
    * medical imaging
    * information visualization
1. Graphics APIs
    * Two major APIs for any graphics program: graphics API and UI API
    * Some approaches have integrated libraries for both (Java), some have separate (OpenGL)
1. Graphics Pipeline
    * Software/hardware subsystem to efficiently draw 3D primitives in perspective
    * Typically optimized for processing 3D triangles with shared vertices
    * Most geometric manipulation in the graphics pipeline can be done in a 4D coordinate space composed of x,y,z and a fourth homogeneous coordinate to help with perspective viewing.
1. Numerical Issues
    * Modern computers typically adhere to the IEEE floating point standard
    * Special values for real numbers in IEEE floating point:
        * Infinity
        * Minus infinity
        * NaN
    * Also has both positive zero and negative zero
    * Rules for division by infinite:
        * +n / +inf = +0
        * -n / +inf = -0
        * +n / -inf = -0
        * -n / -inf = +0
    * Other operations:
        * inf + inf = +inf
        * inf - inf = NaN
        * inf x inf = inf
        * inf / inf = NaN
        * inf / n = inf
        * inf / 0 = inf
        * 0 / 0 = NaN
    * Rules in boolean expressions involving infinite values:
        * All finite valid numbers are less than +inf
        * All finite valid numbers are greater than -inf
        * -inf is less than +inf
    * Rules involving expressions with NaN values:
        * Any arithmetic expression including NaN results in NaN
        * Any boolean expression involving NaN is false
    * Rules for divide by zero:
        * +n / +0 = +inf
        * -n / +0 = -inf
1. Efficiency
    * Good heuristic for current age is to pay more attention to memory access patterns than to operation counts, because the speed of processors has outpaced the speed of memory access.
    * Reasonable approach to making code fast is to take these steps in order, using only those necessary:
        1. Write code in the most straightforward way possible. Compute intermediate results on the fly rather than storing them.
        1. Compile in optimized mode.
        1. Use whatever profiling tools exist to find critical bottlenecks.
        1. Examine data structures to look for ways to improve locality. If possible, make data unit sizes match the cache/page size on the target architecture.
        1. If profiling reveals bottlenecks in numeric computations, examine the assembly code generated by the compiler for missed efficiencies. Rewrite source code to solve any problems you find.
    * In all situations profiling is needed to determine whether any particular optimization has merit.
1. Designing and coding graphics programs
    1. Class Design
        * Make your classes/routines for geometric / graphic entities (vectors, matrices, colors, images) as clean and efficient as possible. 
        * Keep points and vectors separate because it makes code more readable and can let the compiler catch some bugs.
        * Some basic classes that need to be written:
            * vector2 - stores an x and y in an array[2] to support indexing. Also include ops for vector addition, subtraction, dot product, cross product, scalar multiplication and division.
            * vector3 - analogous to vector2
            * hvector - homogeneous vector with four components
            * rgb - color with three components, with ops for addition, subtraction, multiplication, scalar multiplication, and scalar division.
            * transform - 4x4 matrix for transformations
            * image - 2d array of rgb pixels with an output operation
        * Possibly also want classes for intervals, orthonormal bases, and coordinate frames, and maybe unit length vectors.
    1. Float vs Double
        * Use doubles for geometric computation and floats for color computation.
        * For data that uses a lot of memory (meshes) store float data but convert to double when data is accessed through member functions.
    1. Debugging graphics programs
        * Traditional debuggers tend to be less and less useful the more experienced you get, because your errors tend to be conceptual.
        * Do all your computations with floats until you find evidence that double precision is needed in a particular piece of code.
        * Useful debugging strategies:
            * Scientific method - hypothesis through conclusion, repeat
            * Images as coded debugging output - draw into the output to find stuff out
            * Using a debugger - set a trap for a bug by making the program deterministic (single thread, all randoms computed from fixed seeds), then find out which pixel or triangle is exhibiting the bug, and add a statement in code that will execute only for the suspect case.
            * Data visualization for debugging - plot the output for your repeated test cases

## Chapter 2: Miscellaneous Math

## Chapter 3: Raster Images

## Chapter 4: Ray Tracing

* Rendering (to a raster) is the process of taking a set of objects as input and producing output which determines how each object contributes to each pixel in a grid as seen from a particular vantage point.
* There are two general ways of organizing rendering:
    * Object-order rendering - each object is considered in turn, and for each object all pixels it influences are found and updated.
    * Image-order rendering - each pixel is considered in turn, and for each pixel all the objects that influence it are found and the pixel value computed.
* Basically nested loops, with an object loop and a pixel loop on the inside or outside.
* Both types can produce the same output, but have comparative performance characteristics for different kinds of effects. Broadly, image-order is simpler to get working and more flexible, but takes more time.
* A ray tracer makes it easy to compute accurate shadows and reflections, which are awkward in object-order.
* Ray tracing is an image-order algorithm for rendering 3D scenes, and you can make one without doing the heavy math lifting for an object-order renderer.

### 4.1 The basic ray-tracing algorithm

* A ray tracer computes one pixel at a time.
* For each pixel it finds the object that is seen at that pixel's location in the image.
* Pixels have a 'viewing ray', a line emanating from the viewpoint in the direction the pixel is looking--essentially from the camera, through the pixel, to the object.
* You find for a pixel the object closest to the camera, then do a shading computation to determine its color.
* A basic ray tracer has three parts:
    1. Ray generation - computes origin/directionof each pixel's viewing ray
    1. Ray intersection - finds the closest object intersecting the viewing ray
    1. Shading - computes pixel color
* Basic algorithm:
    
```Pseudocode
for each pixel do
    compute viewing ray
    find first object hit by ran and its surface normal n
    set pixel color to value computed from hit point, light, and n
```

### 4.2 Perspective

* 3D objects are projected onto a 2D plane according to certain rules.
* Different types of projections have different rules.
* Common types include parallel, orthographic, and 3 point perspective

### 4.3 Computing Viewing Rays

* To generate rays you need a mathematical representation for one.
