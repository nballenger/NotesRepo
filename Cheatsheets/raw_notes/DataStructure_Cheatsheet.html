<!DOCTYPE html>
<html lang="en">
    <head>
        <link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
        <script src="http://code.jquery.com/jquery-latest.js"></script>
        <script src="js/bootstrap.min.js"></script>
    </head>
    <body>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span2">Left Bar</div>
                <div class="span10">
                    <h1>Data Structures Cheatsheet (Examples in C++)</h1>
                    <div class="section">
                        <h2>Array Usage</h2>
<pre>
class GameEntry {
public:
    GameEntry(const string& n="", int s=0);
    string getName() const;
    int getScore() const;
private:
    string name;
    int score;
};

GameEntry::GameEntry(const string& n, int s)
    : name(n), score(s) { }
    
string GameEntry getName() const { return name; }
int GameEntry::getScore() const { return score; }

class Scores {
public:
    Scores(int maxEnt = 10);
    ~Scores();
    void add(const GameEntry& e);
    GameEntry remove(int i)
        throw(IndexOutOfBounds);
private:
    int maxEntries;
    int numEntries;
    GameEntry* entries;
};

Scores::Scores(int maxEnt) {
    maxEntries = maxEnt;
    entries = new GameEntry[maxEntries];
    numEntries = 0;
}

Scores::~Scores() {
    delete[] entries;
}

void Scores::add(const GameEntry& e) {
    int newScore = e.getScore();
    if (numEntries == maxEntries) {
        if (newScore &lt;= entries[maxEntries-1].getScore())
            return;                                         // if it's smaller than the last element, do nothing
    }
    else numEntries++;
    
    int i = numEntries - 2;                                 // start with next to last
    while (i &gt;= 0 && newScore &gt; entries[i].getScore() ) {
        entries[i+1] = entries[i];                          // move everything to the right
        i--;
    }
    entries[i+1] = e;                                       // put the new value into the empty spot
}

GameEntry Scores::remove(int i) throw(IndexOutOfBounds) {
    if ((i &lt; 0) || (i &gt;= numEntries))
        throw IndexOutOfBounds("Invalid Index");
    GameEntry e = entries[i];
    for (int j = i + 1; j &lt; numEntries; j++)
        entries[j-1] = entries[j];
    numEntries--;
    return e;
}
</pre>
                    </div>
                    <div class="section">
                        <h2>Singly Linked Lists</h2>
<pre>
template &lt;typename E&gt;
class SNode {
private:
    E elem;
    SNode&lt;E&gt;* next;
    friend class SLinkedList&lt;E&gt;;
};

template &lt;typename E&gt;
class SLinkedList {
public:
    SLinkedList();
    ~SLinkedList();
    bool empty() const;
    const E& front() const;
    void addFront(const E& e);
    void removeFront();
private:
    SNode&lt;E&gt;* head;
};

template &lt;typename E&gt;
SLinkedList&lt;E&gt;::SLinkedList()
    : head(NULL) { }
    
template &lt;typename E&gt;
bool SLinkedList&lt;E&gt;::empty() const
    { return head == NULL; }
    
template &lt;typename E&gt;
const E& SLinkedList&lt;E&gt;::front() const
    { return head-&gt;elem; }
    
template &lt;typename E&gt;
SLinkedList&lt;E&gt;::~SLinkedList()
    { while (!empty()) removeFront(); }
    
template &lt;typename E&gt;
void SLinkedList&lt;E&gt;::addFront(const E& e) {
    SNode&lt;E&gt;* v = new SNode&lt;E&gt;;
    v-&gt;elem = e;
    v-&gt;next = head;
    head = v;
}

template &lt;typename E&gt;
void SLinkedList&lt;E&gt;::removeFront() {
    SNode&lt;E&gt;* old = head;
    head = old-&gt;next;
    delete old;
}
</pre>
                    </div>
                    <div class="section">
                        <h2>Doubly Linked Lists</h2>
<pre>
typedef string Elem;
class DNode {
private:
    Elem elem;
    DNode* prev;
    DNode* next;
    friend class DLinkedList;
};

class DLinkedList {
public:
    DLinkedList();
    ~DLinkedList();
    bool empty() const;
    const Elem& front() const;
    const Elem& back() const;
    void addFront(const Elem& e);
    void addBack(const Elem& e);
    void removeFront();
    void removeBack();
private:
    DNode* header;
    DNode* trailer;
protected:
    void add(DNode* v, const Elem& e);
    void remove(DNode* v);
};

DLinkedList::DLinkedList() {
    header = new DNode;
    trailer = new DNode;
    header-&gt;next = trailer;
    trailer-&gt;prev = header;
}

DLinkedList::~DLinkedList() {
    while (!empty()) removeFront();
    delete header;
    delete trailer;
}

bool DLinkedList::empty() const
    { return (header-&gt;next == trailer); }

const Elem& DLinkedList::front() const
    { return header-&gt;next-&gt;elem; }
    
const Elem& DLinkedList::back() const
    { return trailer-&gt;prev-&gt;elem; }
    
void DLinkedList::add(DNode* v, const Elem& e) {
    DNode* u = new DNode;
    u-&gt;elem = e;
    u-&gt;next = v;
    u-&gt;prev = v-&gt;prev;
    v-&gt;prev-&gt;next = v-&gt;prev = u;
}

void DLinkedList::addFront(const Elem& e)
    { add(header-&gt;next, e); }

void DLinkedList::addBack(const Elem& e)
    { add(trailer-&gt;prev, e); }
    
void DLinkedList::remove(DNode* v) {
    DNode* u = v-&gt;prev;
    DNode* w = v-&gt;next;
    u-&gt;next = w;
    w-&gt;prev = u;
    delete v;
}

void DLinkedList::removeFront()
    { remove(header-&gt;next); }
    
void DLinkedList::removeBack()
    { remove(trailer); }
</pre>
                    </div>
                    <div class="section">
                    <h2>Circularly Linked Lists</h2>
<pre>
typedef string Elem;
class CNode {
private:
    Elem elem;
    CNode* next;
    
    friend class CircleList;
};

class CircleList {
public:
    CircleList();
    ~CircleList();
    bool empty() const;
    const Elem& front() const;
    const Elem& back() const;
    void advance();
    void add(const Elem& e);
    void remove();
private:
    CNode* cursor;
};

CircleList::CircleList()
    : cursor(NULL);
    
CircleList::~CircleList()
    { while (!empty()) remove(); }
    
bool CirclList::empty() const
    { return cursor == NULL; }

const Elem& CircleList::back() const
    { return cursor-&gt;elem; }
    
const Elem& CircleList::front() const
    { return cursor-&gt;next-&gt;elem; }

void CircleList::advance()
    { cursor = cursor-&gt;next; }
    
void CircleList::add(const Elem& e) {
    CNode* v = new CNode;
    v-&gt;elem = e;
    if (cursor == NULL) {
        v-&gt;next = v;
        cursor = v;
    }
    else {
        v-&gt;next = cursor-&gt;next;
        cursor-&gt;next = v;
    }
}

void CircleList::remove() {
    CNode* old = cursor-&gt;next;
    if (old == cursor)
        cursor = NULL;
    else
        cursor-&gt;next = old-&gt;next;
    delete old;
}
</pre>
                </div><!-- /span10 -->
            </div><!-- /row-fluid -->
        </div><!-- /container-fluid -->
    </body>
</html>                