CLI Options

    git subcommand --option "optvalue" -- target/file/path

Config Files (in decreasing precedence)

    .git/config
    ~/.gitconfig
    /etc/gitconfig

Config Values

    git config --global var.prop "value for ~/.gitconfig"
    git config var.prop "value for .git/config"

    git config --unset --global var.prop

Editor Choices (in decreasing precedence)

    GIT_EDITOR
    core.editor
    VISUAL
    EDITOR
    /bin/vi

Command Aliasing
    
    git config --global alias.cmdname 'subcommand --option etc'

Create a Repo

    mkdir my_new_repo;cd my_new_repo
    git init

Working with Files

    touch myfile
    git add myfile          # stage file in the index
    git ls-files --stage    # view staged file info
    git hash-object myfile  # view SHA1 for current state

    git commit --all        # stage and commit all unstaged, tracked file changes

    touch anotherfile
    git rm anotherfile              # will fail, file was not staged
    git add anotherfile             # add it to the index
    git rm --cached anotherfile     # remove it from the index

    git commit -m "Add myfile"      # commit staged file 'myfile'

    git rm myfile                   # remove file, stage removal
    git commit -m "remove myfile"   # commit removal


    touch thirdfile
    git add thirdfile
    git commit -m "adding thirdfile"
    git rm thirdfile                # oops!
    git add thirdfile               # will fail, file is gone
    git checkout HEAD -- thirdfile  # get it back from the repo


    git mv onefile twofile
    git commit -m "moved file"
    git log twofile                 # will only display one revision
    git log --follow twofile        # will trace revisions back through onefile

Getting Info

    git status              # current state of the index and untracked files
    git log filename        # revision history of filename
 
    git log -1 --pretty=oneline HEAD    # last commit
    git log -1 --pretty=oneline 1fbb58  # referencing commit by short SHA1

    # view the log for generations 11 and 10 prior
    git log --pretty=short --abbrev-commit master~12..master~10

    git log -1 -p refname       # print the patch (changes) introduced by the commit

    # enumerates files/lines changed, via --stat
    git log --pretty=short --stat master~12..master~10

    git show HEAD~2                     # display object from the object store
    git show origin/master:Makefile     # view specific blob for Makefile

    # See line by line output of who committed changes
    git blame -L 35, filename

    # Search the history of a file's diffs for a string:
    git log -SstringToSearch --pretty=oneline --abbrev-commit filename

Finding a particular commit with bisect
    * Requirement: given a checked out state of your repo, you must be able to 
      determine whether or not it meets your search requirement.
    * "Does the version of the kernel checked out build and boot?" is a valid
      question type for figuring that out.
    * You also have to bound the bisect with known good and known bad states.
    * The command systematically chooses a new commit in a decreasing range,
      narrowing to pinpoint where the change was introduced.
    * You MUST start the bisect from a clean working directory.
    * Example:

        cd linux-2.6
        git bisect start
        git bisect bad HEAD
        git bisect good v2.6.27

        # git will modify your working directory to be some midpoint
        # now you tell git whether it is good or bad at this point
        git bisect good
        git bisect good
        git bisect bad
        git bisect good
        git bisect bad

        # git maintains a log of answers and commit ids
        git bisect log

        # few more to complete binary search
        git bisect bad
        git bisect good
        git bisect good

        # view the commits still under consideration
        # git uses gitk for this if DISPLAY is set, git log otherwise
        git bisect visualize --pretty=oneline

        # If you view your branch you'll be on a detached HEAD
        git branch

        # when you finish the bisect, you have to tell git
        git bisect reset

        # a subsequent branch check shows you're back on your original branch
        git branch

Format of .gitignore

    Blank lines are ignored.
    Lines starting with # are comments.
    Literal filenames match a file in any directory with that name.
    Directory names are marked by trailing slashes, /.
    Patterns with shell globbing characters will be expanded as globs.
    Initial exclamation points invert the rule.

.gitignore resolution rules

    Any folder can have a .gitignore.

    Precedence:
        patterns specified on the command line
        patterns from .gitignore in the same directory
        patterns in parent directories, preceding upward
        patterns from .git/info/exclude
        patterns from the file specified by the conf value core.excludefile

Refs and Symrefs
    * A ref is an SHA1 hash id referring to an object in the object store.
    * A symref indirectly points to a git object.
    * Local topic branch names, remote tracking branch names, tag names are refs.
    * Symbolic refs have explicit, full names starting with refs/
    * Symrefs are stored hierarchically in .git/refs/
    * Three namespaces in .git/refs/:
        refs/heads/refname      # local branches
        refs/remotes/refname    # remote tracking branches
        refs/tags/refname       # tags
    
    * Examples:
        origin/master   ==>  refs/remotes/origin/master
        dev             ==>  refs/heads/dev
        v2.6.23         ==>  refs/tags/v2.6.23

    * Disambiguation cascade:
        .git/ref
        .git/refs/ref
        .git/refs/tags/ref
        .git/refs/heads/ref
        .git/refs/remotes/ref
        .git/refs/remotes/ref/HEAD

    * Special symrefs:
        HEAD                # most recent commit on current branch
        ORIG_HEAD           # last value of HEAD before a merge or reset
        FETCH_HEAD          # head of the last branch fetched, only valid right after fetch
        MERGE_HEAD          # temp home for tip of the other branch during a merge

    * Relative commit names
        * Besides the root commit, all other commits derive from at least one earlier commit.
        * You can trace the parent hierarchy of commits.
        * The caret is used to select a different parent.
        * For a given commit C with three parents, C^1, C^2, C^3 are the parents.
        * The tilde is used to go back before an ancestral parent to select a preceding generation.
        * For commit C, C~1 is the first parent, C~2 is the first grandparent, etc.
        * For multiple parents, the first parent of the first parent is followed.
        * C^ == C^1, C~ == C~1
        * C^^ == C^1^1 == "first parent of the first parent of commit C" == C~2

    * Viewing branches

        git rev-parse [some form of commit name]  # translates any commit name type to SHA1

        git show-branch --more=35

        git rev-parse master~3^2^2^     # gives the id of that specific commit


Branching
    * Types of branches, by convention
        topic branch -- branch to address a topic or bug
        development branch -- non-prod
        tracking branch -- branch to keep clones of a repo in sync
        integration branch -- branch to merge changes from contributors

    * Tagging vs Branching
        - Tags are static and do not change over time
        - branches are dynamic and move with each commit
        - branch and tag names will not collide, but avoid using the same names
        - key question: is the name static/immutable, or dynamic?

    * Branch names
        - The default branch in a repo is named 'master'
        - master usually contains the main development tree
        - you can delete or rename it, but probably shouldn't
        - Branch names can be hierarchical, may look like paths
        - You could name your bug branches bug/1, bug/2, etc.
        - Since git supports wildcards, using slashes in branch names is useful

    * Branch Naming Rules
        - Cannot end with a forward slash (/)
        - Cannot start with a minus sign (-)
        - No slash-separated name component can start with a dot (eg, 'x/.y' is invalid)
        - Cannot contain two consecutive dots at any point (..)
        - Cannot contain whitespace
        - Cannot contain git special characters: ~ ^ : ? * [
        - Cannot contain an ASCII control character (bytes below \040, or \177 DEL)

    * Using Branches
        - There may be at most one active or current branch.
        - The active branch determines which files are in the working directory.
        - The current branch is often an implicit operand in commands.
        - 'master' is active by default
        - Each branch must have a unique name
        - A branch's name always refers to the HEAD of that branch
        - Older commits on a branch must be referred to by id or relative name
        - To track a particular commit over time, tag it.
        - To find the original commit from which a branch was started:

            git merge-base [original-branch] [new-branch]

    * Creating branches
        - A branch is based on an existing commit that you specify
        - To create a branch off of HEAD:

            git branch myBranch

        - Off a specific commit:

            git branch myBranch2 commit-name

        - Creating a branch does not use that branch as the active branch.

    * Listing Branches
        - The branch subcommand lists branch names in the repo
        - The currently checked out branch is marked with an asterisk
        - With no parameters, only topic branches in the repo are listed
        - Using -r will list remote tracking branches
        - Using -a will list both topic and remote branches

    * Viewing Branches
        - The show-branch subcommand gives detailed output, listing commits for a branch
        - No options shows the topic branches, -r the remote, -a both
        - Output for show-branch is in two sections, separated by a dashed line

    * Checking Out Branches
        - Switching branches has several effects:
            .. Files in the new branch but not the current branch are placed in your working copy
            .. Files in the current branch but not the new branch are removed from the working copy
            .. Files present in both branches are changed to reflect the content of the new branch
        - Git will not switch branches if you have uncommitted changes to tracked files.
        - You can override that if you -f force it.

    * Merging changes into a different branch
        - If you call checkout with -m, git will attempt to put your local changes into the new working dir
        - That does not introduce a merge commit on any branch.
        - Your local changes are merged with the target branch and left in your working directory.
        - Example of making changes while master is active, then realizing they should be committed to a branch:

            echo "some new text" >> newFile
            git show myBranchName:newFile     # view current content of newFile in branch
            git show newFile                  # view current content in active branch (master)
            git checkout -m myBranchName      # carry the local changes to newFile into myBranchName


    * Creating and Checking Out a Branch
        - Using -b with checkout will createa new branch and switch to it

            git checkout -b myNewBranch [startPoint]

        - That's the same as:

            git branch myNewBranch [startPoint]
            git checkout myNewBranch

    * Detached HEAD branches
        - You can check out any commit, though usually you check out the head of a branch
        - Git will create a detached HEAD (kind of an anonymous branch) if you:
            .. Check out a non-HEAD commit
            .. Check out a tracking branch
            .. Check out the commit referenced by a tag.
            .. Start a git bisect operation
            .. Use the git submodule update command
        - If you are on a detached head, and you make changes you want to keep, you must create a new branch:

            # create a branch based on the detached HEAD
            git checkout -b newBranchName

        - If you are on a detached head, 'git branch' will asterisk '(no branch)'
        - To abandon a detached head, convert to a named branch by:

            git checkout branchName

    * Deleting Branches
        - You can delete a branch with 'git branch -d branchName'
        - You cannot remove the current branch.
        - You cannot remove a branch with commits not present on the current branch.
        - If the content is on another branch, check that out first.
        - You can also merge the content from the branch you want to delete into your current branch.
        - You can override the safety check with -D.

Diffs
    Reading the Diff
        * The original file is denoted by --- in the header.
        * The new file is denoted by +++.
        * The @@ line gives you line number context for both versions.
        * A line prefixed with a minus sign must be removed from the original to produce the new.
        * A line prefixed with a plus must be added to the original to produce the new.
        * A line with a space is in both, and is provided by -u as context.
        * A diff provides a formal description of how to transform one file into the other.
        * Git can give you a digest of differences across directories / trees.

    Forms of the command
        * If you compare tree objects, git diff gives all deviations between the two states.
        * Three basic sources of tree/treelike objects for diff:
            - Any tree object in the entire commit graph
            - Your working directory
            - the index
        * Any commit name that identifies a commit can be used in diff args.
        * There are four fundamental comparisons git diff can do:
            - git diff
                .. shows the difference between your working directory and the index
                .. shows you what is changed in your working directory
                .. does not show differences between your index and the repo, or remotes
            - git diff commitIdentifier
                .. summarizes the differences between your working copy and the given commit
                .. often you'll compare to the head of master or another branch
            - git diff --cached commitIdentifier
                .. shows differences between staged changes in the index and the given commit
                .. common to compare to HEAD, which shows how your next commit will alter the current branch
                .. you can also use --staged in place of --cached
            - git diff commitIdentifier1 commitIdentifier2
                .. differences between those two commits
                .. ignores the index and the working directory
                .. can do arbitrary comparisons between any two tree structures

    Useful Options to git diff
        -M      Detects renames, generates a simplified output that records the file
                rename rather than the complete removal and addition of the source file.
        -w      Compares all lines without considering changes in whitespace.
                Synonym is --ignore-all-space.
        --stat  Adds statistics about the differences between tree objects.
        --color Gives colorized output. A unique color represents each of the types of
                changes present in the diff.

    Commit Ranges with diff
        * Two additional forms of git diff:
            
            git diff commitIdentifier1 commitIdentifier2
            git diff commitIdentifier1..commitIdentifier2

        * Those are equivalent, and do NOT represent a range in . They will compare the two versions.
        * Diff doesn't care about histories, it compares states at particular commits.
        * Where this:

            git log a..b

        * Finds all commits in b that are not also in a, this:

            git diff a..b

        * Shows all differences between the head of a and the head of b.
        * The triple dot ellipsis will show a symmetrical difference between commits.
        * It shows all differences between commits that can be reached from either head, but not
          from both heads.

    Path Limiting
        * Default behavior is to run across entire tree structure.
        * Format is:

            git diff branch1 branch2 path/fragment

Merges
    * Merges unify two or more commit history branches.
    * A merge must occur within a single repository.
    * If modifications do not conflict, git computes a merge result and creates a new commit.
    * Git marks conflicting changes as unmerged in the index and leaves reconciliation to the dev.

    * Example of merging 'yourbranch' with 'mybranch':

        git checkout mybranch
        git merge yourbranch

    * Make sure to start a merge with a clean working directory.
    * Example of setting up a repo with a single file, two branches, and a merge:

        git init
        git config user.email "nick@nick.com"
        git config user.name "Nick B"
        echo "blah blah" > file.txt
        git add file.txt
        git commit -m "Initial commit of file."

        echo "foo bar" > other_file.txt
        git add other_file.txt
        git commit -m "Another file."

        git checkout -b alternate master^       # fork master onto alternate, before other_file

        git show-branch                         # tells us we're on alternate

        echo "blaaaaaaah" > file.txt
        git commit -m "change to file.txt"

        git checkout master                     # switching back to master
        git status                              # clean, on master

        git merge alternate                     # do the merge

        # Viewing the changes:
        git log --graph --pretty=oneline --abbrev-commit

    * Example of a merge with a conflict:

        git checkout master
        echo "foo" > file.txt
        git commit -a -m "add a file"

        git checkout alternate

        echo "bar" > file.txt                   # introduce the conflict

        git diff                                # compare current (alternate) to master HEAD

        git commit -a -m "conflict, whoo"

        git checkout master

        git merge alternate                     # does the merge, reports the conflict

        git diff                                # show the conflict

        # edit file to resolve conflict

        git add file.txt
        git commit                              # continue the merge, will drop to EDITOR for message

    * Options during merging

        git status                              # will show status during conflicted merge
        git ls-files -u                         # shows files and their hashes

    * Changes in conflicted files appear between:

        contextline
        <<<<<<< HEAD:filename
        version1
        =======
        version2
        >>>>>>> otherBranch:filename
        contextline

    * Fix the file, then run git add and commit.
    * Running git diff on a conflicted file will give you specific output about the conflict
    * You can also do:

        git diff HEAD
        git diff MERGE_HEAD
        git diff --ours
        git diff --theirs

    * Fixed files disappear from the diff output
    * To see more about the conflict:

        git log --merge --left-right -p         # shows the full commit message, only for conflicted files 

    * git show will show the merge commit (until your next commit)

    * To abort or restart a merge:

        git reset --hard HEAD                   # restores the working directory and index to before git merge
        git reset --hard ORIG_HEAD              # use after the merge commit is done to roll back

    * To blow away resolved but uncommitted conflicts, use:

        git checkout -m                         # acts on the MERGE_HEAD, probably?


Merge Strategies

    Degenerate Merges
        * Degenerate merges do NOT produce a new commit.
        
        Scenario: Already Up to Date
            * When all the commits from the other branch are already present in your target branch,
              even if it has advanced on its own, the target branch is said to be already up to date.
            * Consequently, no new commits are added to your branch.
            * This might happen if you perform a merge and then try to immediately perform the same
              merge again.

        Scenario: Fast Forward
            * Happens when your branch HEAD is already fully present in the other branch.
            * Inverse of already up to date.
            * Git tacks on to your HEAD the new commits from the other branch, and moves your HEAD
              to point to the final, new commit.
            * Common on tracking branches because they just fetch and record remote commits.

    Normal Merges
        * All normal merges produce a final commit, added to your current branch, representing merged state.

        Strategy: Resolve
            * Operates on only two branches, locating the common ancestor as the merge basis.
            * Does a direct three way merge by applying the changes from the merge base to the tip of
              the other branch HEAD onto the current branch.

        Strategy: Recursive
            * Can only join two branches.
            * Handles a scenario with more than one merge base between two branches.
            * Performs a temporary merge of all common merge bases and then uses that as the base.
            * Then throws the temporary merge basis away, and commits final merge state to your target branch.

        Strategy: Octopus
            * Merges more than two branches simultaneously.
            * Calls the recursive strategy multiple times internally, once for each branch.
            * Cannot handle a merge requiring conflict resolution based on user action.
            * If no automatic merge can happen, you must do a series of normal merges.

    Specialty Merges
        * Each of these produces a final commit representing the merged state.

        Strategy: Ours
            * Merges any number of branches.
            * Discards changes from those branches, only uses files from the current branch.
            * Result is identical to the current HEAD, but other named branches are also named parents.
            * Useful if you know you have all changes from a branch but want to have it in the history.

        Strategy: Subtree
            * Merges in another branch, but everything in that branch is inside a subtree of the current tree.

    Applying Merge Strategies
        * If branches > 2, use octopus
        * try already-up-to-date
        * try fast-forward
        * try recursive
        * try others?

    Specifying a merge strategy

        git merge -s resolve tree1 tree2

    Merge Drivers
        * Every merge strategy uses an underlying merge driver to do the actual merging.
        * Merge drivers take the common ancestor name, the target branch version, and the other branch version.
        * The driver modifies the target branch version to have the merged result.

        Text driver
            * uses the usual three way merge markers, <<<<<<<, =======, >>>>>>>
        Binary driver
            * keeps the target branch version, leaves the file marked as a conflict in the index
            * You have to resolve binary files by hand.
        Union driver
            * leaves all the lines from both versions in the merged file

        * Possible to write your own merge drivers if you had to.


Altering Commits

    git reset
        * Changes your repo and working directory to a known state.
        * Adjusts the HEAD ref to a given commit, updates the index to match.
        * Can also modify working directory to mirror the revision of your project at the given commit.
        * Point is to establish and recover known states for HEAD, index, working directory
        * Three main options:

            --soft
                * Changes the HEAD ref to point to the given commit.
                * Index and working directory are unchanged.
                * Changes only the state of the symbolic reference.
            --mixed
                * Points HEAD to the given commit.
                * Index is modified to align with that tree structure.
                * Working directory is left unchanged.
                * It's as if you had just staged all the changes represented by commit.
                * This is the default mode.
            --hard
                * Points HEAD to the given commit.
                * Index is modified to align with that tree structure.
                * Working directory is changed to align with that tree.
                * Modifications are lost, new files removed.
                * Files in the given commit that are not in your working directory are reinstated.

        * reset saves the original HEAD value in ORIG_HEAD
        * reset moves the current HEAD within the commit graph to a specific commit
        * Using reset to eliminate the topmost commit on a branch:

            git init
            echo foo >> master_file
            git commit
            echo "more foo" >> master_file
            git commit master_file
            git show-branch --more=5

            git reset HEAD^                 # reset to the previous commit

        * Using reset with other branches:

            git checkout master
            git checkout -b dev
            echo bar >> dev_file
            git add dev_file
            git commit

            git checkout master
            git rev-parse HEAD
            git rev-parse master            # these two are the same

            git reset --soft dev            # change HEAD to point to the dev commit
            git rev-parse HEAD              # now different from master


Remote Repositories
    Bare and Development Repos
        * A development repo is used for normal, daily development.
        * Development repos hve a current branch, provide a checked out copy of that in a working directory.
        * A bare repo has no working directory.
        * A bare repo has no checked out branch.
        * A bare repo is just the contents of the .git folder.
        * No commits are made to a bare repo.
        * Bare repos serve as an authoritative focal point for collaborative development.
        * Devs clone and fetch from the bare repo, and push to it.
        * Creating a bare repo:

            git clone --bare reponame
            git init --bare reponame

        * Bare repos do not have a reflog by default.
        * Bare repos do not have remotes.
        * If you set up a repo for devs to push changes into, it should be bare.

    Repository Clones
        * In normal git clone use, local development branches of the original repo (in /ref/heads)
          become remote-tracking branches in the new clone, under refs/remotes/.
        * Remotes in the original refs/remotes are not cloned--the new repo doesn't need to know
          what the upstream repo is tracking.
        * Tags are copied into the clone, and so are all objects reachable from cloned refs.
        * Hooks, config files, the reflog, and the stash are not cloned.
        * Each clone by default maintains a link to its parent repo via a remote called origin.
        * The original repo does not maintain links to any clones.
        * You can change the name of the reference with the --origin option to clone.

    Remotes
        * The repo you're working in is the 'local' or 'current' repo.
        * The repo you exchange files with is the 'remote'.
        * The remote repo may or may not be on a separate machine.
        * 'upstream repository' usually refers to the origin repo.
        * The remote ref is a short name for the actual repo url.
        * Remotes form part of the name basis for remote tracking branches for the repo.
        * You can use 'git remote' to create, remove, manipulate, or view a remote.
        * All remotes are recorded in .git/config and can be manipulated with git config
        * Other common commands that refer to remote repositories are:
            git fetch -- gets objects and metadata from a remote repo
            git pull -- like fetch, but also merges changes into the local branch
            git push -- transfers objects and metadata into a remote repo
            git ls-remote -- show a list of references held by a given remote repo

    Tracking Branches
        * You can keep up with changes to an upstream repo even while you make local commits/branches.
        * Any branch in your local repo is a local branch, but there are subcategories:
            - remote-tracking branches -- associated with a remote and have the specific purpose of
                following the changes of each branch in that remote repo.
            - local-tracking branch -- paired with a remote-tracking branch. A form of integration branch
                that collects the changes from your local and the changes from the remote-tracking branch.
            - topic/development branch -- any local, nontracking branch
            - remote branch -- branch in a nonlocal, remote repo. Likely an upstream source for a remote
                tracking branch.

        * During a clone, git creates a remote-tracking branch in the clone for each topic branch in the upstream
        * Those remote-tracking branches are in a new, separate namespace in the local repo
        * They are not branches in a remote--the local uses remote-tracking branches to follow upstream changes.
        * The separation in namespace makes it clear that there are branches made by you (topic branches),
          and branches based on a remote repo (remote-tracking branches)
        * Any op that you can do to a topic branch you can do to a tracking branch.
        * However, you should effectively treat tracking branches as read only.
        * Don't merge or make commits onto a remote-tracking branch.


Referencing Other Repositories
    * Coordinating with another repo means defining a remote, which is a named entity stored in the conf file.
    * The entity consists of two parts: the name (URL) of the remote repo, and a refspec, which specifies how
      a ref (usually a branch) should be mapped from the namespace of one repo into the namespace of the other.

    Referring to Remote Repositories
        * Git supports a couple different forms of URL
        * None entirely conform to the URI spec, but they're usually called 'git URLs'
        * Simplest form refers to the repo on a local filesystem. Two permutations:

            /path/to/repo.git
            file:///path/to/repo.git

        * First uses hard links in the filesystem to directly share the same objects between current and remote.
        * Second copies the objects instead of sharing them directly.
        * file:// is recommended to avoid issues with shared repos
        * Most efficient form of data transfer for a remote is the 'git native protocol':

            git://example.com/path/to/repo.git
            git://example.com/~user/path/to/repo.git

        * git-daemon uses those to publish repos for anonymous read, and you can clone and fetch them.
        * No authentication is used for this format.
        * For authenticated connections, git tunnels through SSH:

            ssh://[user@]example.com[:port]/path/to/repo.git
            ssh://[user@]example.com/path/to/repo.git
            ssh://[user@]example.com/~user2/path/to/repo.git
            ssh://[user@]example.com/~/path/to/repo.git

        * 'user' there is the user whose session is authenticating
        * 'user2' is the user whose home directory is accessed
        * Git also has a URL for with scp-like syntax. Has no way to give a port.

            [user@]example.com:/path/to/repo.git
            [user@]example.com:~user/path/to/repo.git
            [user@]example.com:path/to/repo.git

        * HTTP and HTTPS are also supported:

            http://example.com/path/to/repo.git
            https://example.com/path/to/repo.git

        * Rsync can also be specified:

            rsync://example.com/path/to/repo.git

        * Rsync for this is inferior to other options--don't use it, and if you have to, just use it for clone.

    The refspec
        * A refspec maps branch names in the remote repo to branch names in the local.
        * Typically you use complete names in a refspec.
        * Generic syntax is:

            [+]source:destination

        * Consists of a source ref, a colon, and a destination ref.
        * Plus sign indicates the normal fast forward safety check will not be performed.
        * Asterisk allows a limited form of wildcard matching on branch names.
        * Each part can be optional under some circumstances.
        * Refspecs are used by fetch and push.
        * The roles of source and destination depend on the git operation:

            op      source                      destination
            ------------------------------------------------------------
            push    local ref being pushed      remote ref being updated
            fetch   remote ref being fetched    local ref being updated

        * A fetch might use a refspec like:

            +refs/heads/*:refs/remotes/remote/*

        * Which could be paraphrased as:

            All source branches from a remote repo in namespace 'refs/heads/' are 1) mapped into the
            local repo using a name constructed from the remote name and 2) placed under the 
            'refs/remotes/remote' namespace.

        * It's convention and best practice to put branches for a given remoteName under refs/remotes/remoteName/*
        * The command 'git show-ref' will list the references in the current repo.
        * git ls-remote repositoryName to list the references in a remote repo.
        * Don't make commits or merges onto a remote tracking branch identified on the right side of a pull or
          fetch refspec. Those will be used as remote-tracking branches.

        * During a push, you want to provide/publish the changes you made on your local topic branches.
        * To let others find those after you upload them, your changes must appear in that repo as topic branches.
        * During a typical push, the source branches from your repo are sent to the remote using a refspec like:

            +refs/heads/*:refs/heads/*

        * Which can be paraphrased as:
            
            From the local repo, take each branch name found under the source namespace refs/heads/ and put it
            in a similarly named, matching branch under the destination namespace refs/heads/ in the remote.

        * You can give multiple refspecs on the fetch/push command lines.
        * Inside a remote definition, multiple refspecs of each type can be specified.
        * If you don't give a refspec to a git push command, git assumes you want to use origin.
        * Without a refspec, push will send your commits to the remote for all branches that are common 
          between your repo and the upstream repo.
        * New local branches are not sent upstream unless you name them explicitly.
        * The default refspec makes these equivalent:

            git push origin branchName
            git push origin branchName:refs/heads/branchName

Example using remote repositories
    * Common use scenario: a repo that all devs consider authoritative (by convention)
    * That copy is often put in a special repo called a 'depot' (not 'master' or 'repository', those are special terms)
    * Depot acts as the remote origin for all devs.
    * Example is putting an initial repo in the depot, cloning dev repos out of it, doing work, syncing back to depot.
    
    Creating an Authoritative Repository
        * In this example we'll put a repo in /tmp/Depot--normally you'd host it upstream on a server.
        * This outlines how to transform a repo into another bare clone repo to be an authoritative upstream source.

            # Populating /tmp/Depot with an initial repo:
            mkdir /tmp/Depot;cd /tmp/Depot
            git init --bare public_html.git

            # Making a repo to use that as a remote:
            cd ~/Desktop
            git init public_html
            cd public_html
            echo 'foo' > foo.txt
            git add foo.txt
            git commit -m 'foo'

            # getting the remote added to the .git/config remote section:
            git remote add origin file:///tmp/Depot/public_html.git

            # establish new remote-tracking branches in the non-bare repo to represent
            # the branches from the remote repo
            git remote update

            # Add a second file
            echo 'bar' > bar.txt
            git commit -a -m 'bar'

            # Push the changes to remote
            git push origin master

            # Add a new developer
            cd /tmp/bob
            git clone /tmp/Depot/public_html.git
            cd public_html
             
            # Change a file
            echo 'bar2' > bar.txt
            git commit -m 'bar 2'

            # push from bob's checkout to remote
            git push origin master

            # Go get the updated change
            cd ~/Desktop/public_html
            git pull
