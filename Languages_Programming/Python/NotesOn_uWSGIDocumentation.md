# Notes on uWSGI Documentation

From https://uwsgi-docs.readthedocs.io/en/latest/

# Quickstart for Python/WSGI applications

From https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html

* Install on debian requires `build-essential` and `python-dev`
* May be available as a system package
* With distribution supplied packages uWSGI is probably built with modular plugins, so you'll have to prepend `--plugin python,http` to the examples here
* `helloworld_wsgi_app.py`

    ```Python
    def application(env, start_response):
        start_response('200 OK', [("Content-Type", "text/html")])
        return [b"Hello World from uWSGI"]
    ```

* Running it via the built in `uwsgi` server:

    ```
    uwsgi --http :9090 --wsgi-file helloworld_wsgi_app.py
    ```

* Don't use `--http` when using a frontend or doing benchmarking, use `--http-socket`
* The above starts a single process and single thread, to add concurrency:

    ```shell
    uwsgi --http :9090 --wsgi-file helloworld_wsgi_app.py --processes 4 --threads 2
    ```

* Spawns 4 processes each with two threads, a master process, and hte HTTP router
* Enabling the stats subsystem lets you export uWSGI's internal stats as JSON:

    ```shell
    UWSGI_OPTS="--http :9090 --wsgi-file helloworld_wsgi_app.py --processes 4 --threads 2"
    UWSGI_OPTS+=" --stats 127.0.0.1:9191"
    uwsgi "$UWSGI_OPTS"
    ```

* You can install `uwsgitop` as a monitoring tool
* Alternatively, make a request to the server then telnet to 9191
* Bind the stats socket to a private address.

## Putting behind a full webserver

* Nginx config meaning "pass every request to server bound to 3031 speaking the uwsgi protocol":

    ```
    location / {
        include_uwsgi_params;
        uwsgi_pass 127.0.0.1:3031;
    }
    ```

* Spawning the server to natively speak the uwsgi protocol:

    ```shell
    UWSGI_OPTS="--socket 127.0.0.1:3031 --wsgi-file helloworld_wsgi_app.py "
    UWSGI_OPTS+="--master --processes 4 --threads 2 --stats 127.0.0.1:9191"
    uwsgi "$UWSGI_OPTS"
    ```

* The HTTP router doesn't start in that example, because the workers (processes assigned to uWSGI) natively speak the uwsgi protocol
* If the proxy/webserver/router speaks HTTP, you have to tell uWSGI to natively speak that, by subbing in `--http-socket` for `--socket` in the above
* For deploying Flask, the `Flask` app object is the WSGI function, so you have to tell uWSGI to use it by providing the name of that object as an arg to `--callable`

    ```
    uwsgi --socket 127.0.0.1:3031 --wsgi-file myflaskapp.py --callable app [...]
    ```

* If you start uWSGI without threads, the Python GIL is not enabled, so threads generated by your appliation will never run.
* If you want to maintain Python threads support without starting multiple threads for your app, add `--enable-threads` or `enable-threads = true` in the ini file
* You can configure uWSGI to search for Python modules in a virtualenv with `virtualenv = <somepath>`
* NEVER run your instances as root
* The `uid = <someuser>` and `gid = <somegroup>` options drop privileges
* For binding to privileged ports, use shared sockets. Those are created before dropping privileges and can be referenced with the `=N` syntax, where `N` is the socket number:

    ```ini
    [uwsgi]
    shared-socket = :443
    https = =0,foobar.crt,foobar.key
    uid = foo
    gid = bar
    master = true
    processes = 8
    ```

* Common problem is stuck requests, where all threads/workers are stuck (blocked on request) and your app can't accept more requests
* You can set a `harakiri` timer, which is a monitor managed by the master process that destroys processes stuck more than the specified seconds: `harakiri = 30`
* The uWSGI offloading subsystem lets you free your workers as soon as possible when some specific pattern matches and can be delegated to a pure-C thread. Stuff like sending a static file from the filesystem, transferring data from the network to the client, etc.
* It's very complicated, but you can try it with `--offload-threads <n_cpus>`
* 
    

# Managing the uWSGI Server

From https://uwsgi-docs.readthedocs.io/en/latest/Management.html

* How to best start uWSGI services at boot depends on your OS
* It's Systemd on most linux variants other than old Ubuntu
* If you use the `safe-pidfile` option, uWSGI will write the master process PID to a file
* The server responds to the following signals:
    * `SIGHUP` - graceful reload of all workers and master
    * `SIGTERM` - brutally reload all workers and master
    * `SIGINT` - immediately kill entire stack
    * `SIGQUIT` - immediately kill entire stack
    * `SIGUSR1` - print statistics
    * `SIGUSR2` - print worker status or wakeup spooler
    * `SIGURG` - restore a snapshot
    * `SIGTSTP` - pause/suspend/resume an instance
    * `SIGWINCH` - wake up a worker blocked in a syscall (internal use only)
    * `SIGFPE` - generate C traceback
    * `SIGSEGV` - generate C traceback
* When running with the `master` process mode, the server can be gracefully restarted without closing the main sockets, which lets you patch/upgrade the server without closing the connection with the webserver and losing requests.
* Sending `SIGHUP` to master process gets it to try gracefully stopping all workers, then it "closes all the eventually opened file descriptors not related to uWSGI."
* Then it binary patches the uWSGI pocess image with a new one, inheriting all previous file descriptors. It knows its a reloaded instance, skips the socket init process
* Ways to make uWSGI gracefully restart:

    ```
    # using kill to send the signal
    kill -HUP `cat /tmp/project-master.pid`
    # or with --reload option
    uwsgi --reload /tmp/project-master.pid
    # or if it was started with touch-reload=/tmp/touchfile
    touch /tmp/touchfile
    ```

* From within a Python app, import `uwsgi` and call `uwsgi.reload()`
* For stopping backgrounded uwsgi processes you need to use the master pidfile:

    ```
    kill -INT `cat /tmp/project-master.pid`
    # or
    uwsgi --stop /tmp/project-master.pid
    ```

# Nginx Support 

From https://uwsgi-docs.readthedocs.io/en/latest/Nginx.html

* Generally you only need to include the `uwsgi_params` file and set the address of the uWSGI socket with `uwsgi_pass`:

    ```
    uwsgi_pass unix:///tmp/uwsgi.sock;
    include uwsgi_params;
    ```

* For TCP sockets:

    ```
    uwsgi_pass 127.0.0.1:3031;
    include uwsgi_params;
    ```

## What is the `uwsgi_params` file?



# Things to know, best practices and issues

From https://uwsgi-docs.readthedocs.io/en/latest/ThingsToKnow.html

* Never expose a socket speaking the uwsgi protocol to the public network. It allows arbitrary code execution, and is meant to be sanitized/validated by a proxy like nginx or the uWSGI routers.
* `http` and `http-socket` are entirely different.
    * `http` spawns an additional process forwarding requests to a series of workers
    * `http-socket` sets workers to natively speak the http protocol
* If exposing uWSGI to the public use `http`, if proxied `http-socket`
* Use `uwsgitop` via the stats server to monitor app health
* Features can be included in the core or as loadable plugins. System package distributions of uWSGI tend to be modular. Within those, be sure to load plugins you need via the `plugins` option.
* Config files support limited inheritance, variables, and flow control. 
* To route requests to a specific plugin the webserver needs to pass a magic number known as a 'modifier' to uWSGI instances. By default it's set to 0, which is mapped to Python. 
* No magic rule for number of processes/threads. Monitor and experiment.
* If an HTTP request has a body, you have to read/consume it in your app. If you don't, the communication socket with the webserver can get clobbered. If you're lazy you can use the `post-buffering` option that autoreads data for you.
* Always check the memory usage of your apps. `memory-report` option can be useful.
* If you're using Unix sockets rather than TCP, remember that they are standard filesystem objects, so they have permissions, and your server must have write access.
* Never run uWSGI instances as root. Drop privileges with `uid` and `gid`
* uWSGI tries to use the Copy on Write semantics of `fork()` whenever possible.
    * By default it will fork after having loaded your apps, to share as much of their memory as possible.
    * If that's not what you want, use `lazy-apps` option, which instructs uWSGI to load the apps after each worker's `fork()`
* By default the Python plugin doesn't initialize the GIL, so your app-generated threads won't run. If you need threads, enable them with `enable-threads`
* Running in multithreading mode with `threads` automatically enables threading support.
* If you spawn a new process during a request, it inherits the file descriptors of the workers that spawns it, including the socket connected with the webserver/router. If you don't want that, set `close-on-exec`
* Do not build plugins using a different config than used to build the uWSGI binary.
* If a linux system seems to have lots of idle workers but performance is still sub-par, you may want to look at the value of `ip_conntrack_max` (`/proc/sys/net/ipv4/ip_conntrack_max`) and increase it to see if that helps
* By default, stdin is remapped to `/dev/null` on uWSGI startup. If you need a valid stdin for debugging, piping, etc., add `--honour-stdin`
* You can add non-existent options to your config files, which is fine for placeholders, custom stuff, whatever, but can lead to headaches if you make typos. Use `--strict` to disallow the feature and only tolerate uWSGI options.
* Some plugins (Python and Perl) have code auto-reloading. You MUST use them only under development, as they are very expensive.
* `wsgi.file_wrapper` is an optimization of the WSGI standard that you can disable by setting `wsgi-disable-file-wrapper` to `true`

# Configuring uWSGI

From https://uwsgi-docs.readthedocs.io/en/latest/Configuration.html

* Each command line option maps 1:! with entries in the config files
* You can load config files over several methods that aren't files

    ```
    uwsgi --ini http://uwsgi.it/config/myapp.ini    # HTTP
    uwsgi --xml -                                   # standard in
    uwsgi --yaml fd://0                             # file descriptor
    uwsgi --json 'exec://nc 192.168.11.2:33000'     # arbitrary executable
    ```

* Config files can include magic vars prefixed with a percent sign
* These are the variables, accessible in Python via `uwsgi.magic_table`
    * `%v` - vassals directory (pwd)
    * `%V` - uWSGI version
    * `%h` - hostname
    * `%o` - original config filename as specified on command line
    * `%p` - absolute path of config file
    * `%s` - filename of the config file
    * `%d` - absolute path of parent directory of config file
    * `%e` - extension of the config file
    * `%n` - filename without extension
    * `%c` - name of parent directory of config file (version 1.3+)
    * `%t` - epoch time in seconds, gathered at instance startup
    * `%T` - epoch time in microseconds, gathered at instance startup
    * `%x` - current section identifier, like `config.ini:section`
    * `%i` - inode number of the file
    * `%0 ... %9` - specific component of the full path of the parent directory of hte config file
    * `%[` - ANSI escape `\033`, useful for printing colors
    * `%k` - detected CPU cores
    * `%u` - uid of the user running the process
    * `%U` - username if available of the user running the process
    * `%g` - gid of the user running the process
    * `%G` - group name if available
    * `%j` - hex representation of the djb33x hash of the config path
* The following are the same as their lowercase version, but refer to the first non-template config file: `%O %P %S %D %E %N %C %X %J`
* The first non-template config file is the first one not loaded by `--include` or `--inherit`, but instead loaded by `--ini`, `--yaml` or `--config`

## Placeholders

* Placeholders are custom magic variables defined during configuration time

    ```
    [uwsgi]
    ; These are placeholders...
    my_funny_domain = uwsgi.it
    set-ph = max_customer_address_space=64
    set-placeholder = customers_base_dir=/var/www
    ; These are not
    socket = /tmp/sockets/%(my_funny_domain).sock
    chdir = %(customers_base_dir)/%(my_funny_domain)
    limit-as = %(max_customer_address_space)
    ```

* You can assign them directly, or use `set-placeholder` / `set-ph`, which make it more explicit
* You can set them on the command line via `--set-placeholder foo=bar`
* Using `set-placeholder` / `set-ph` allows placeholders under strict mode
* In app code, they're accessible via `uwsgi.opt['customers_base_dir']`
* The `@` character lets you include the contents of a file:

    ```
    [uwsgi]
    foo = @(/tmp/somefile)
    ```

* You can load settings from env vars if they are prefixed with `UWSGI_` and dashes are swapped for underscores

## INI files

* By default uWSGI uses the `[uwsgi]` file section
* You can specify an alternate section: `uwsgi --ini myfile.ini:somesection`
* You can load another section from the same file by omitting the filename and specifying just the section name, but it always loads from the last loaded file

    ```
    [uwsgi]
    # loads the app1 section
    ini = :app1
    # loads the defaults.ini file
    ini = defaults.ini
    # loads app2 section from defaults.ini!!!

    [app1]
    plugin = rack

    [app2]
    plugin = php
    ```

* Whitespace is insignificant within lines
* Comments start with semicolon or hash
* Booleans may be set without the value part, so `master` is equivalent to `master=true`
* uWSGI recognizes bare `.ini` args specially, so `uwsgi myconf.ini` is equivalent to `uwsgi --ini myconf.ini`

# Fallback configuration

From https://uwsgi-docs.readthedocs.io/en/latest/FallbackConfig.html

* Fallback conf is a reset-to-defaults / "I've borked my conf" tool
* Common problem is screwing up the port the instance listens on
* Binding to a privileged port: `uwsgi --uid 1000 --http-socket :80`
* Causes an exit with `bind(): Permission denied`
* If you want to allow the instance to automatically bind to 8080 if the user supplied config fails, you can set up a config file `safe.ini` with `http-socket = :8080`
* Then rerun the instance with `uwsgi --fallback-config safe.ini --uid 1000 --http-socket :80`

This is the dumbest feature ever.

# Configuration logic

From https://uwsgi-docs.readthedocs.io/en/latest/ConfigLogic.html

* Supported statements:
    * `for` ... `endfor`
    * `if-dir` / `if-not-dir`
    * `if-env` / `if-not-env`
    * `if-exists` / `if-not-exists`
    * `if-file` / `if-not-file`
    * `if-opt`/ `if-not-opt`
    * `if-reload` / `if-not-reload` - undocumented? WTF
* Each of those exports a context value you can access with the placeholder `%(_)`, so the for loop sets that to the current iterated value
* For example:

    ```
    [uwsgi]
    master = true
    ; iterate over a list of ports
    for = 3031 3032 3033 3034 3035
    socket = 127.0.0.1:%(_)
    endfor = 
    module = helloworld
    ```

* The for loop is applied to each line in the block separately, so

    ```
    for = a b c
    foobar = %(_)
    barfoo = %(_)
    endfor =
    ```

* expands to

    ```
    foobar = a
    foobar = b
    foobar = c
    barfoo = a
    barfoo = b
    barfoo = c
    ```

# uWSGI Options

From https://uwsgi-docs.readthedocs.io/en/latest/Options.html

Okay, there are a ton of options, many of which are stupid. I'm going to try and list the ones that are potentially useful or need attention.

## uWSGI Core

* `socket` - bind to socket using default protocol
* `uwsgi-socket` - bind to specified unix/tcp socket using uwsgi protocol
* `http-socket` - bind to socket using HTTP protocol
* `https-socket` - bind using HTTPS
* `socket-protocol` - set default protocol for sockets
* `processes` / `workers` - number of workers
* `harakiri` - locked process reap timeout in seconds
* `config` - load config using pluggable system
* `fallback-config` - re-exec uwsgi with this config if exit code is 1 from original conf
* `strict` - only allow uwsgi options in config
* `set-placeholder` / `set-ph` - set a placeholder
* `resolve` - place result of a dns query in the specified placeholder
* `blacklist` / `whitelist` ???
* `inherit` - use specified file as config template
* `include` - include file as immediate config options
* `daemonize` - daemonize uWSGI
* `daemonize2` - daemonize after app loading
* `listen` - set socket listen queue size
* `buffer-size` - set internal buffer size, it's the max request size excepting body, default 4k
* `memory-report` - enable memory report
* `profile` - enable specified profiler
* `chmod-socket` - ???
* `chown-socket`
* `enable-threads` - ???
* `procname-prefix` - add prefix to process names
* `procname` - set process names
* `procname-master`
* `need-app` - exit if no app can be loaded
* `master` - enable master process
* `honour-stdin` - do not remap stdin to /dev/null
* `reload-mercy` - max time in seconds to wait for workers to die during reload/shutdown
* `die-on-term` - exit instead of brutal reload on SIGTERM
* `reaper` - call `waitpid(-1,...)` after each request to kill zombies
* `max-requests` - reload workers after specified amount of managed requests
* `min-worker-lifetime` / `max-worker-lifetime` - seconds worker must run before reload (default 60) / reload after this many seconds
* `socket-timeout` - set internal sockets timeout
* `cache` - create a shared cache with given elements
* `pidfile` - create pidfile before privilege drop
* `pidfile2` - create pidfile after privilege drop
* `safe-pidfile` / `safe-pidfile2` - create safe pidfile before / after priv drop
* `chroot` - chroot to specified dir
* `uid` / `gid` - set uid/gid for running user, to drop from root privs
* `no-server` - force no-server mode
* `tcp-nodelay` - enable TCP NODELAY on each request
* `so-keepalive` - enable TCP KEEPALIVE
* `touch-reload` - reload uwsgi if specified file is touched
* `limit-post` - limit request body
* `metric` - add custom metric
* `stats` - enable stats server on the specified address
* `logto` - set logfile / udp address
* `logto2` - log to specified file or udp address after priv drop
* `log-format` - set advanced format for request logging
* `logfile-chown` / `logfile-chmod`
* `log-syslog` - log to syslog
* `log-socket` - send logs to specified socket
* `logger` - set/append a logger
* `log-slow` - log requests slower than N ms
* `log-4xx` - log requests for 4xx
* `log-5xx` - log requests for 5xx
* `log-sendfile`
* `log-big`
* `chdir` - chdir to specified dir before apps loading
* `chdir2` - chdir to specified dir after apps loading
* `lazy-apps` - load apps in each worker instead of master
* `cheap` - spawn workers only after first request
* `mount` - load application under mountpoint
* `threads` - run each worker in prethreaded mode with specified number of threads
* `route` - add a route
* `add-header` - automatically add HTTP headers to response
* `rem-header` - strip specified header from response
* `plugins` / `plugin`
* `need-plugins` / `need-plugin`

## Plugin: python

* `wsgi-file` - load .wsgi file
* `callable` - set default name of WSGI callable
* `home` - set PYTHONHOME/virtualenv
* `virtualenv` - set PYTHONHOME/virtualenv
* `pythonpath` - add directory or glob to pythonpath
* `pyargv` - manually set `sys.argv`
* `optimize` - set python optimization level
* `reload-os-env` - force reload of `os.environ` at each request
* `py-autoreload` - monitor python files to trigger reload (DEVELOPMENT ONLY)
