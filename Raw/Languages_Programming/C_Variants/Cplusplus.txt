Notes on Data Structures and Algorithms in C++

Chapter 1: A C++ Primer

1.1 Basic C++ Programming Elements

    1.1.1 a Simple C++ Program
        * Create a source file, run the compiler to get a machine code version, then a 
            linker to include libraries
        * Example:
       
            #include <cstdlib>
            #include <iostream>
            /* Inputs two numbers x and y and outputs the sum */
            int main() {
                int x, y;
                std::cout << "Please enter two numbers: ";
                std::cin >> x >> y;
                int sum = x + y;
                std::cout << "Their sum is " << sum << std::endl;
                return EXIT_SUCCESS;
            }
           
        1.1.1.1 Program Elements
   
    1.1.2 Fundamental Types
        bool, char, short, int, long, float, double
        1.1.2.1 Characters
        1.1.2.2 Integers
        1.1.2.3 Enumerations
            * user defined type, can hold any set of discrete values
            * Meaningful names for a set of related values
            * Example:
           
                enum Day { SUN, MON, TUE, WED, THU, FRI, SAT };
                enum Mood { HAPPY = 3, SAD = 1, ANXIOUS = 4, SLEEPY = 2 };
               
                Day today = THU;        // today may be any of SUN...SAT
                Mood myMood = SLEEPY;   // myMood may be any of HAPPY ... SLEEPY
               
        1.1.2.4 Floating Point
       
    1.1.3 Pointers, Arrays, and Structures
        1.1.3.1 Pointers
            * & is the "Address-of" operator, returns the address of an object in memory
            int a = 1;
            int* b = &a;
            cout << *b;  // prints 1
        1.1.3.2 Arrays
        1.1.3.3 Pointers and Arrays
            * Name of an array is the same as a pointer to the array's first element
        1.1.3.4 Strings
            * Double quoted strings are 'C style strings'
            * To add string operations, use the string type from the Standard Template Library
            * Add the header file <string> to do that
            * Example:
           
                #include <string>
                using std::string;
                // ...
                string s = "to be";
                string t = "not" + s;
                string u = s + " or " + t;
                if (s > t)
                    cout << u;
                   
        1.1.3.5 C-Style Structures
            * Multi-member aggregations, heterogeneous types
            * Example:
           
                enum MealType { NO_PREF, REGULAR, LOW_FAT, VEGETARIAN };
               
                struct Passenger {
                    string   name;
                    MealType mealpref;
                    bool     isFreqFlyer;
                    string   freqFlyerNo;
                };
               
                Passenger pass = { "John Smith", VEGETARIAN, true, "293145" };
                pass.name = "Pocahontas";
                pass.mealPref = REGULAR;
               
        1.1.3.6 Pointers, Dynamic Memory, and the "new" operator
            * C++ runtime reserves a large block of memory called the "free store"
            * 'new' operator dynamically allocates the correct amount of storage
                for any given type of object from the free store, returns a pointer
            * pointers can be taken to any data type, or other pointers
            * the -> operator is equivalent to the dot operator:
           
                pointer_name->member  is equivalent to  (*pointer_name).member
               
            * Example of initializing a "passenger" object:
           
                Passenger *p;
                // ...
                p = new Passenger;
                p->name = "Pocahontas";
                p->mealPref = REGULAR;
                p->isFreqFlyer = false;
                p->freqFlyerNo = "NONE";
               
            * The delete operator destroys an object and returns its space to the free store:
           
                delete p;  // destroy the object p points to
               
            * delete should only be used on object allocated via 'new'
            * C++ has no automatic garbage collection
            * Arrays can be allocated with 'new' as well, and you get a pointer to the first element
            * dynamically allocated arrays of type T would be declared being of type *T
            * you cannot use 'delete' on arrays allocated in that manner, but must use 'delete[]'
            * Example:
           
                char* buffer = new char[500];
                buffer[3] = 'a';
                delete [] buffer;
               
        1.1.3.7 Memory Leaks
            * If an object is allocated with 'new', it should eventually be disallocated with 'delete'
           
        1.1.3.8 References
            * A reference is an alternative name for an object
            * Defined as being of type T&
            * Must be initialized at declaration
            * Example:
           
                string author = "Samuel Clemens";
                string& penName = author;
                penName = "Mark Twain";
                cout << author;                     // outputs "Mark Twain"
               
    1.1.4 Named Constants, Scope, and Namespaces
        1.1.4.1 Constants and Typedef
            * Adding 'const' to a declaration makes a value stored in an object immutable
            * You can associate a name with a type via 'typedef':
           
                typedef char* BufferPtr;            // Type BufferPtr is a pointer to char
                typedef double Coordinate;          // type Coordinate is a double
               
                BufferPtr p;                        // p is a pointer to char
                Coordinate x, y;                    // x and y are of type double
               
        1.1.4.2 Local and Global Scopes
            * Things declared outside of any block are global
            * Otherwise stuff has block scope
           
        1.1.4.3 Namespaces
            * Lets you define a group of related names in one place:
           
                namespace myglobals {
                    int cat;
                    string dog = "bow wow";
                }
               
                myglobals::cat;             // fully qualified name
               
        1.1.4.4 The Using Statement
            * To avoid having to enter namespace specifiers, we can use a specific specifier:
           
                using std::string;              // makes just std::string available
                using std::cout;                // makes just std::cout available
               
                using namespace myglobals;      // makes all of myglobals available
               
1.2 Expressions
    * Combines variables and literals with operators to create new values
    1.2.1
        1.2.1.1 Member Selection and Indexing
            * Some operators access a member of a structure, class, or array
               
                class_name.member
                pointer->member
                array[exp]
               
        1.2.1.2 Arithmetic Operators
            * Operators are: + - * / %
            * Unary ops: + -
           
        1.2.1.3 Increment and Decrement Operators
            * Pre and post ++ and --
           
        1.2.1.4 Relational and Logical Operators
            * Relational ops are: < > <= >= == !=
            * Logical ops are: ! && ||
           
        1.2.1.5 Bitwise Operators
            * Ops are: ~ (bitwise complement)
                       & (bitwise and)
                       ^ (bitwise xor)
                       | (bitwise or)
                      << (bitwise left shift)
                      >> (bitwise right shift)
                     
        1.2.1.6 Assignment Operators
            * Ops are: = += -= *= /= %=
           
        1.2.1.7 Other Operators
            * Class scope resolution:   class_name::member
            * Namespace resolution:     namespace::member
            * Ternary operator:         bool ? if_true : if_false
            * Stream input              stream >> var
            * Stream output             stream << exp
           
        1.2.1.8 Operator Precedence
       
    1.2.2 Changing Types through Casting
        1.2.2.1 Traditional C-Style Casting
            * For some expression exp and some type T, to cast the value of the 
                expression to type T: (T)exp
            * If the desired type is a type name instead of a type expression, a 
                functional style cast is T(exp)
            * Examples
           
                int     cat = 14;
                double  dog = (double) cat;     // traditional C-style cast
                double  pig = double (cat);     // C++ functional cast
               
        1.2.2.2 Explicit Cast Operators
            * Casting operators that make the safety of the cast explicit:
                static_cast
                dynamic_cast
                const_cast
                reinterpret_cast
               
        1.2.2.3 Static Casting
            * Used when a conversion is made between two related types
            * Syntax is:    static_cast <desired type> (expression)
            * Example of double to int:
           
                double  d1 = 3.2;
                double  d2 = 3.9999;
                int     i1 = static_cast<int>(d1);      // i1 has value 3
                int     i2 = static_cast<int>(d2);      // i2 has value 3
               
        1.2.2.4 Implicit Casting
            * Will insert a cast into the machine code if one is not provided
            * Better to be explicit
           
1.3 Control Flow
    1.3.1
        1.3.1.1 If Statement
            * Syntax:
               
                if (condition)
                    true_statement
                else if (condition)
                    else if statement
                else
                    else_statement
                   
        1.3.1.2 Switch Statement
            * Example: 
           
                char command;
                cin >> command;
                switch (command) {
                    case 'I':
                        editInsert();
                        break;
                    case 'D':
                        editDelete();
                        break;
                    case 'R':
                        editReplace();
                        break;
                    default:
                        cout << "Unrecognized command\n";
                        break;
                }
               
        1.3.1.3 While and Do-While Loops
            * Syntax:
           
                while (condition)
                    loop_body
                   
                do
                    loop_body
                while (condition)
               
        1.3.1.4 For Loop
            * Syntax:
               
                for (initialization; condition; increment)
                    loop_body
                   
            * Example:
           
                const int NUM_ELEMENTS = 100;
                double b[NUM_ELEMENTS];
                // ...
                for (int i = 0; i < NUM_ELEMENTS; i++) {
                    if (b[i] > 0)
                        cout << b[i] << '\n';
                }
               
        1.3.1.5 Break and Continue Statements
            * break breaks out of a loop or switch
            * continue goes to the next iteration
           
1.4 Functions
    * To define a function, we have to supply to the compiler a return type, function 
        name, arg list, and function body
    * Two steps: declaration and definition
    * Example:
   
        bool evenSum(int a[], int n);       // declaration
       
        bool evenSum(int a[], int n) {      // definition
            int sum = 0;
            for (int i = 0; i < n; i++)
                sum += a[i];
            return (sum % 2) == 0;
        }
       
    1.4.1 Argument Passing
        * By default, arguments are passed by value
        * Example showing one by value, one by reference:
       
            void f(int value, int& ref) {
                value++;                    // no effect on actual argument
                ref++;                      // modifies actual argument
                cout << value << endl;
                cout << ref << endl;
            }
           
            int main() {
                int cat = 1;
                int dog = 5;
                f(cat, dog);
                cout << cat << endl;
                cout << dog << endl;
                return EXIT_SUCCESS;
            }
           
        1.4.1.1 Constant References as Arguments
            * Passing a structure or class by value makes a copy of something large
            * Since most function arguments are not modified, you can pass an arg 
                as a 'constant reference'
            * Even though it's passed by reference, the compiler knows its immutable
            * Example:
           
                void someFunction(const &Passenger pass) {
                    pass.name = "new name";         // ILLEGAL--pass is declared const
                }

        1.4.1.2 Array Arguments
            * When an array is passed to a function, it is converted to a pointer 
                to its initial element
            * T[] is converted to T*
           
    1.4.2 Overloading and Inlining
        * overloading is defining two or more functions or operators that have the same name
   
        1.4.2.1 Function Overloading
            * Used when you need to be able to deal with two different types of arguments
            * Example:
           
                void print (int x) { cout << x; }
               
                void print (const Passenger& pass) {
                    cout << pass.name << " " << pass.mealPref;
                    if (pass.isFreqFlyer)
                        cout << " " << pass.freqFlyerNo;
                }
               
        1.4.2.2 Operator Overloading
            * Example of overloading the equality operator:
           
                bool operator==(const Passenger& x, const Passenger& y) {
                    return x.name        == y.name
                        && x.mealPref    == y.mealPref
                        && x.isFreqFlyer == y.isFreqFlyer
                        && x.freqFlyerNo == y.freqFlyerNo;
                }
               
        1.4.2.3 Inline Functions
            * Hint to the compiler to expand the function code in place rather than 
                using call-return mechanism
            * Example:
           
                inline int min (int x, int y) { return (x < y ? x : y); }
               
1.5 Classes
    1.5.1 Class Structure
        * Classes have data members and member functions / methods
        * Example:
       
            class Counter {
                public:
                    Counter();
                    int getCount();
                    void increaseBy(int x);
                private:
                    int count;
            };
           
        * Definitions of member functions:
       
            Counter::Counter()              // constructor
                { count = 0; }
            int Counter::getCount()
                { return count; }
            void Counter::increaseBy(int x)
                { count += x; }
               
        * Constructors have the same name as the class itself
        * Invocation uses dot syntax, as in:
       
            Counter ctr;
            cout << ctr.getCount() << endl;
            ctr.increaseBy(3);
            cout << ctr.getCount() << endl;
            ctr.increaseBy(5);
            cout << ctr.getCount() << endl;
           
        1.5.1.1 Access Control
            * Members can be public or private
            * All access goes through the public interface
            * If no access specifier is given, members are private by default
           
        1.5.1.2 Member Functions
            * Example code:
           
                class Passenger {
                public:
                    Passenger();                            // constructor
                    bool isFrequentFlyer() const;           // accessor, const indicates 
                                                            //   will not change data
                    void makeFrequentFlyer(const string& newFreqFlyerNo);
                private:
                    string      name;
                    MealType    mealPref;
                    bool        isFreqFlyer;
                    string      freqFlyerNo;
                };
               
            * Method definitions can/should be outside the class body:
           
                bool Passenger::isFrequentFlyer() const {
                    return isFreqFlyer;
                }
               
                void Passenger::makeFrequentFlyer(const string& newFreqFlyerNo) {
                    isFreqFlyer = true;
                    freqFlyerNo = newFreqFlyerNo;
                }
               
            * Note the bare use of member variables inside function defs--no "this" equivalent
           
        1.5.1.3 In-Class Function Definitions
            * When a member function is defined inside a class it is compiled inline
            * Reserve this for short functions with no loops or conditionals
           
    1.5.2 Constructors and Destructors
        1.5.2.1 Constructors
            * Same name as the class name
            * No return type
            * Normal to overload the constructor to deal with diff initializations
            * Three constructors, one default (no args), one with args, one to copy an existing obj:
           
                class Passenger {
                private:
                    // ...
                public:
                    Passenger();
                    Passenger(const string& nm, MealType mp, const string& ffn = "NONE");
                    Passenger(const Passenger& pass);
                    // ...
                };
               
                // Default:
                Passenger::Passenger() {
                    name = "--NO NAME--";
                    mealPref = NO_PREF;
                    isFreqFlyer = false;
                    freqFlyerNo = "NONE";
                }
               
                // constructor with values:
                Passenger::Passenger(const string& nm, MealType mp, const string& ffn) {
                    name = nm;
                    mealPref = mp;
                    isFreqFlyerNo = (ffn != "NONE");
                    freqFlyerNo = ffn;
                }
               
                // Copy constructor:
                Passenger::Passenger(const Passenger& pass) {
                    name = pass.name;
                    mealPref = pass.mealPref;
                    isFreqFlyer = pass.isFreqFlyer;
                    freqFlyerNo = pass.freqFlyerNo;
                }
               
        1.5.2.2 Initializing Class Members with Initializer Lists
            * If a class does not have an assignment operator defined for it, C++ lets 
                you use an initializer list
            * List is placed between the constructors argument list and the body
            * consists of a colon followed by a comma separated list of the form 
                member_name(initial_value)
            * Example:
           
                Passenger::Passenger(const string& nm, Mealtype mp, string ffn)
                    : name(nm), mealPref(mp), isFreqFlyer(ffn != "NONE")
                    { freqFlyerNo = ffn; }
                   
        1.5.2.3 Destructors
            * Called when a class object ceases to exist, called when 'delete' is used
            * Destructor for class T is denoted ~T
            * No arguments, no return type
            * Responsibility is to return resources to the system
            * Example of a class Vect:
           
                class Vect {
                public:
                    Vect(int n);            // constructor
                    ~Vect();                // destructor
                private:
                    int*        data;       // array holding the vector
                    int         size;       // number of array entries
                };
               
                Vect::Vect(int n) {
                    size = n;
                    data = new int[n];
                }
               
                Vect::~Vect() {
                    delete [] data;         // free the allocated array
                }
           
            * Not strictly required to create one, but good to do so to avoid memory leaks
           
    1.5.3 Classes and Memory Allocation
        * It's a problem to allow memory leaks via non-deleted objects, but also to have 
            undefined copy routines
        * Example:
       
            Vect a(100);            // a is a vector of size 100
            Vect b = a;             // initialize b from a (Danger!)
            Vect c;                 // c is a vector, default size 10
            c = a;                  // assign a to c (Danger!)
           
        * By default this is two shallow copies of a
        * For b, b.data is set to a.data, which is a pointer to a.data
        * For c, c.data is created as a 10 element array, but then overwritten with a 
            pointer to a.data
        * c.data's original memory structure is unreferenced but not deallocated, 
            creating a memory leak
        * If a class allocates memory, you should provide a copy constructor and 
            assignment operator
        * A copy constructor for class T is typically declared to take a single argument, 
            a const reference to a T obj
        * Syntax of that is typically T(const T& t)
        * Example of a copy constructor:
       
            Vect::Vect(const Vect& a) {
                size = a.size;
                data = new int[size];
                for (int i = 0; i < size; i++) {
                    data[i] = a.data[i];
                }
            }       
           
        * In an overload definition for an = operator, 'this' is the address of the instance
        * Example of overloading the = operator:
       
            Vect& Vect::operator=(const Vect& a) {
                if (this != &a) {                           // avoid self assignment
                    delete [] data;                         // delete old array
                    size a.size;                            // set new size
                    data = new int[size];                   // allocate new array
                    for (int i = 0; i < size; i++) {        // copy vector contents
                        data[i] = a.data[i];
                    }
                }
                return *this;
            }
           
        * Every class that allocates its own object using 'new' should:
            - Define a destructor to free allocated objects
            - Define a copy constructor
            - Define an assignment operator
           
    1.5.4 Class Friends and Class Members
        * We can declare a function as a 'friend', meaning the function may access 
            a class's private data
        * Example where requirements prevent us defining a member function:
       
            class SomeClass {
            private:
                int secret;
            public:
                // ...
                friend ostream& operator<<(ostream& out, const SomeClass& x);
            };
           
            ostream& operator<<(ostream& out, const SomeClass& x)
                { cout << x.secret; }
               
        * Also appropriate when two classes are closely related
        * Example using vectors and matrices:
       
            class Vector {
            public:  //... public members omitted
            private:
                double coord[3];                        // storage for coordinates
                friend class Matrix;                    // give Matrix access to coord
            };
           
            class Matrix {                              // a 3x3 matrix
            public:
                Vector multiply(const Vector& v);       // multiply by vector v
                // ... other public members omitted
            private:
                double a[3][3];                         // matrix entities
            };
           
            Vector Matrix::multiply(const Vector& v) {  // multiply by vector v
                Vector w;
                for (int i = 0; i < 3; i++)
                    for (int j = 0; j < 3; j++)
                        w.coord[i] += a[i][j] * v.coord[j];
                return w;
            }
           
        1.5.4.1 Nesting Classes and Types within Classes
            * Example:
               
                class Book {
                public:
                    class Bookmark {
                        // .. bookmark definition here
                    };
                    // remainder of Book definition
                }
               
    1.5.5 The Standard Template Library
        * Collection of useful classes
        * Data structures for the following standard containers:
            stack, queue, deque, vector, list, priority queue, set, map
           
        1.5.5.1 Templates and the STL Vector Class
            * A class whose definition depends on a user-specified type is called a 'template'
            * Type of the object being stored in the container in angle brackets
            * Example using the generic vector class:
           
                #include <vector>
                using namespace std;
               
                vector<int> scores(100);
                vector<char> buffer(500);
                vector<Passenger> passenList(20);
               
            * Superior to arrays in many ways
            * Elements can be accessed via [], and the at() member function, which 
                does range checking
            * vector's size is given by the size() member function
            * One vector can be assigned to another, which deep copies
           
        1.5.5.2 More on STL Strings
            * Some additional string methods:
                s.find(p)
                s.find(p, i)
                s.substr(i, m)
                s.insert(i, p)
                s.erase(i, m)
                s.replace(i, m, p)
                getline(is, s)
               
1.6 C++ Program and File Organization
    * A typical program consists of many files
    1.6.1
        1.6.1.1 Source Files
            * Two common file types: source files and header files
            * Different compilers have different naming conventions, may have suffixes 
                like .cc, .ccp, .C
            * Each nonconstant global variable and function may be defined only once
            * To indicate that a global variable is defined in another file, extern is added
            * Example:
           
                file 1:
                   
                    int cat = 1;
                    int foo(int x) { return x+1; }
                   
                file 2:
                   
                    extern int cat;
                    int foo(int x);
                   
        1.6.1.2 Header Files
            * Since source files using shared objects must provide indentical declarations, 
                we store them in a header file
            * header files are brought in via an #include statement
            * typically contains many declarations of classes, structures, constants, 
                enumerations, and typedefs
            * Typically do not contain function bodies, except inline functions
            * Most header files have the .h suffix
            * STL header files are indicated with <file>, locally defined with double quotes
           
    1.6.2 An Example Program
        1.6.2.1 The CreditCard Class
            * CreditCard.h:
           
                #ifndef CREDIT_CARD_H
                #define CREDIT_CARD_H
               
                #include <string>
                #include <iostream>
               
                class CreditCard {
                public:
                    CreditCard(const std::string& no, const std::string& nm, int lim, double bal=0);
                    std::string     getNumber() const   { return number; }
                    std::string     getName()   const   { return name; }
                    double          getBalance() const  { return balance; }
                    int             getLimit()  const   { return limit; }
                   
                    bool chargeIt(double price);
                    void makePayment(double payment);
                private:
                    std::string number;
                    std::string name;
                    int         limit;
                    balance     double;
                };
                   
                std::ostream& operator<<(std::ostream& out, const CreditCard& c);
                #endif
               
        1.6.2.2 The Main Test Program
            * CreditCard.cpp
           
                #include "CreditCard.h"
               
                using namespace std;
               
                CreditCard::CreditCard(const string& no, const string& nm, int lim, double bal) {
                    number = no;
                    name = nm;
                    balance = bal;
                    limit = lim;
                }
               
                bool CreditCard::chargeIt(double price) {
                    if (price+balance > double(limit))
                        return false;
                    balance += price;
                    return true;
                }
               
                void CreditCard::makePayment(double payment) {
                    balance -= payment;
                }
               
                ostream& operator<<(ostream& out, const CreditCard& c) {
                    out << "Number = " << c.getNumber()     << "\n"
                        << "Name = " << c.getName()         << "\n"
                        << "Balance = " << c.getBalance()   << "\n"
                        << "Limit = " << c.getLimit()       << "\n";
                    return out;
                }
               
            * TestCard.cpp:
           
                #include <vector>
                #include "CreditCard.h"
               
                using namespace std;
               
                void testCard() {
                    vector<CreditCard*> wallet(10);
                    wallet[0] = new CreditCard("5391 0375 9387 5309", "John Bowman", 2500);
                    wallet[1] = new CreditCard("3485 0399 3395 1954", "John Bowman", 3500);
                    wallet[2] = new CreditCard("6011 4902 3294 2994", "John Bowman", 5000);
                   
                    for (int j=1; j <= 16; j++) {
                        wallet[0]->chargeIt(double(j));
                        wallet[1]->chargeIt(2 * j);
                        wallet[2]->chargeIt(double(3 * j));
                    }
                   
                    cout << "Card payments:\n";
                    for (int i=0; i < 3; i++) {
                        cout << *wallet[i];
                        while (wallet[i]->getBalance() > 100.0) {
                            wallet[i]->makePayment(100.0);
                            cout << "New balance = " << wallet[i]->getBalance() << "\n";
                        }
                        cout << "\n";
                        delete wallet[i];
                    }
                }
               
                int main() {
                    testCard();
                    return EXIT_SUCCESS;
                }
               
1.7 Writing a C++ Program
    1.7.1 Design
        * Responsibilities: divide work into different "actors" each with a 
            different responsibility
        * Independence: make classes as independent as possible
        * Behaviors: define the behaviors of each class throughly
       
    1.7.2 Pseudo-Code
        * Expressions: standard mathematic and boolean ops, <- as assignment operator, 
            = as equality
        * Function declarations: Algorithm name (arg1, arg2,...)
        * Decision structures: if condition then ture-actions [else false-actions]
        * While-loops: while condition do actions
        * Repeat-loops: repeat actions until condition
        * For-loops: for variable-increment-definition do actions
        * Array indexing: A[i] represents the ith cell in A, zero indexed
        * Member function calls: object.method(args)
        * Function returns: return value
        * Comments: { Comment goes here. }
       
    1.7.3 Coding
        * Discussion of design patterns
        * CRC cards: Class-Responsibility-Collaborator cards are index cards dividing 
            work of a program
        * UML, Unified Modeling Language diagrams express the organization of a program
        * IDE, integrated development environment
       
        1.7.3.1 Readability and Style
            * Use meaningful identifier names
            * Use named constants and enumerations instead of embedded values
            * Indent statement blocks
            * Organize each class in a consistent order:
                - Public types and nested classes
                - Public member functions
                - Protected member functions (internal utilities)
                - Private member data
            * Use good comments
           
    1.7.4 Testing and Debugging
        1.7.4.1 Testing
            * Make sure every method is tested at least once (method coverage)
            * Make sure each statement is executed at least once (statement coverage)
            * Consider edge cases
            * Two main test strategies: top down and bottom up
            * Top-down typically goes with stub methods
       
        1.7.4.2 Debugging
            * Simplest method is just print statements
            * Run the program inside a debugger, that monitors the execution
            * Basic functionality is to set breakpoints, some give you conditional breakpoints
        1.6.2.3 Avoiding Multiple Header Extensions
           
           

Chapter 2: Object-Oriented Design

2.1 Goals, Principles, and Patterns
    2.1.1 Object-Oriented Design Goals
        2.1.1.1 Robustness: capable of handling unexpected inputs that are not explicitly 
            defined for its application
        2.1.1.2 Adaptability: change gracefully over time
        2.1.1.3 Reusability: same code should be usable as a component of different 
            systems in various applications
       
    2.1.2 Object-Oriented Design Principles
        2.1.2.1 Abstraction
        2.1.2.2 Encapsulation
        2.1.2.3 Modularity
        2.1.2.4 Hierarchical Organization
       
    2.1.3 Design Patterns
        * Algorithmic design patterns:
            * Recursion
            * Amortization
            * Divide-and-conquer
            * Prune-and-search / decrease-and-conquer
            * Brute Force
            * The greedy method
            * Dynamic programming
        * Software engineering design patterns
            - Position
            - Adapter
            - Iterator
            - Template method
            - Composition
            - Comparator
            - Decorator
           
2.2 Inheritance and Polymorphism
    2.2.1 Inheritance in C++
        * Terminology: base/parent/super class, derived/child/sub class
        * Example:
       
            class Person {
            private:
                string  name;
                string  idNum;
            public:
                void print();
                string  getName();
            };
           
            class Student : public Person {
            private:
                string  major;
                int     gradYear;
            public:
                void print();
                void changeMajor(const string& newMajor);
            };
           
        * Keyword 'public' specifies public inheritance
        * Creates an implied 'is a' relationship between them
       
        2.2.1.1 Member Functions
            * Person obj can access the public members of Person
            * Student obj can access the public members of Person and Student, will use 
                its own in case of overloading
            * To explicitly choose one or the other, use the class scope operator, ::
            * Example of calling a base class method:
           
                void Person::print() {
                    cout << "Name " << name << endl;
                    cout << "IDnum " << idNum <<endl;
                }
               
                void Student::print() {
                    Person::print();
                    cout << "Major " << major << endl;
                    cout << "Year " << gradYear << endl;
                }
               
        2.2.1.2 Protected Members
            * Derived classes do not have access to private members of base classes
            * You can declar things as 'protected' rather that private or public
            * protected members are public to derived classes, otherwise private
           
        2.2.1.3 Illustrating Class Protection
            * Example:
           
                class Base {
                    private:    int priv;
                    protected:  int prot;
                    public:     int publ;
                };
               
                class Derived : public Base {
                    void someMemberFunction() {
                        cout << priv;           // ERROR: private member
                        cout << prot;           // okay
                        cout << publ;           // okay
                    }
                };
               
                class Unrelated {
                    Base X;
                   
                    void anotherMemberFunction() {
                        cout << X.priv;         // ERROR: private member
                        cout << X.prot;         // ERROR: protected member
                        cout << X.publ;         // okay
                    }
                };
               
        2.2.1.4 Constructors and Destructors
            * Constructor of a base class should be called in the initializer list of 
                the derived class
            * Example:
           
                Person::Person(const string& nm, const string& id)
                    : name(nm),
                      idNum(id) {}
                     
                Student::Student(const string& nm, const string& id, const string& major, int year)
                    : Person(nm, id), major(maj), gradYear(year) {}
                   
            * Putting class initializations in the initialization list is generally 
                more efficient
            * You should define destructors, but you don't have to call ~Person from 
                ~Student, it's done automatically
           
        2.2.1.5 Static Binding
            * Derived classes are "subtypes" of the base class, so you can use them where 
                the base class is used
            * Example:
           
                Person* pp[100];
                pp[0] = new Person(...);
                pp[1] = new Student(...);
               
            * If you call a method common to both classes, the version in the class of 
                the array will be invoked
               
        2.2.1.6 Dynamic Binding and Virtual Functions
            * To specify that a member function should use dynamic binding, use the 
                keyword 'virtual'
            * A dynamically bound member will use an object's contents to determine which 
                member function to call
            * Example:
           
                class Person {
                    virtual void print() { ... }
                };
               
                class Student : public Person {
                    virtual void print() { ... }
                };
               
                Person* pp[100];
                pp[0] = new Person(...);
                pp[1] = new Student(...);
                pp[0]->print();                 // calls Person::print()
                pp[1]->print();                 // class Student::print()
               
        2.2.1.7 Virtual Destructors
            * No such thing as a virtual constructor--wouldn't make sense
            * If you had a non virtual destructor for Student and deleted each array item, 
                it would call ~Person
           
    2.2.2 Polymorphism
        * A variable p declared to be a pointer to some class S implies that p can point 
            to any object belonging to any derived class T of S
        * If p points to an object of type T, p->a() will invoke T::a, and override S::a
        * Caller of p->a() does not have to know whether the pointer p refers to an 
            instance of S or T
        * A pointer p that points to a class object that has at least one virtual function 
            is said to be polymorphic.
       
        2.2.2.1 Specialization
            * Derived classes make a general class more specialized
           
        2.2.2.2 Extension
            * Add new functionality to the base class
           
    2.2.3 Examples of Inheritance in C++
        * example using class Progression, to define generic members and functions of 
            a numeric progression
        * Has a constructor, destructor, and firstValue(), nextValue(), and 
            printProgression(n)
        * Code:
       
            class Progression {
            public:
                Progression(long f=0)
                    : first(f), cur(f) {}
                virtual ~Progression() { };
                void printProgression(int n);
            protected:
                virtual long firstValue();
                virtual long nextValue();
            protected:
                long first;
                long cur;
            };
           
        * Public printProgression:
       
            void Progression::printProgression(int n) {
                cout << firstValue();
                for (int i = 2; i <= n; i++)
                    cout << ' ' << nextValue();
                cout << endl;
            }
           
        * Internal utilities, only invoked inside class or descendants:
       
            long Progression::firstValue() {
                cur = first;
                return cur;
            }
           
            long Progression::nextValue() {
                return ++cur;
            }
           
        2.2.3.1 Derived class ArithProgression:
            * code:
                class ArithProgression : public Progression {
                public:
                    ArithProgression(long i = 1);
                protected:
                    virtual long nextValue();
                protected:
                    long inc
                };
               
            * Constructor and nextValue:
           
                ArithProgression::ArithProgression(long i)
                    : Progression(), inc(i) {}
                   
                long ArithProgression::nextValue() {
                    cur += inc;
                    return cur;
                }
           
        2.2.3.2 Geometric Progression Class
            * code:
               
                class GeomProgression : public Progression {
                public:
                    GeomProgression(long b=2);
                protected:
                    virtual long nextValue();
                protected:
                    long base;
                };
               
                GeomProgression::GeomProgression(long b)
                    : Progression(1), base(b) { }
                   
                long GeoProgression::nextValue() {
                    cur *= base;
                    return cur;
                }
               
        2.2.3.3 A Fibonacci Progression Class
            * Code:
           
                class FibonacciProgression : public Progression {
                public:
                    FibonacciProgression(long f = 0, long s = 1);
                protected:
                    virtual long firstValue();
                    virtual long nextValue();
                protected:
                    long second;
                    long prev;
                };
               
                FibonacciProgression::FibonacciProgression(long f, long s)
                    : Progression(f), second(s), prev(second - first) { }
                   
                long FibonacciProgression::firstValue() {
                    cur = first;
                    prev = second - first;
                    return cur;
                }
               
                long FibonacciProgression::nextValue() {
                    long temp = prev;
                    prev = cur;
                    cur += temp;
                    return cur;
                }
               
        2.2.3.4 Combining the Progression Classes

    2.2.4 Multiple Inheritance and Class Casting
        2.2.4.1 Multiple and Restricted Inheritance
            * Single inheritance is used almost exclusively
            * Most inheritance is public
            * Two other types: protected and private
            * Protected inheritance: public fields in the base class become protected 
                in the child class
            * Private inheritance: public fields and protected fields in the base become 
                private in the child class
            * Example:
           
                class Base {
                    protected:  int foo;
                    public:     int bar;
                };
               
                class Derive1 : public Base {
                    // foo is protected and bar is public
                };
               
                class Derive2 : protected Base {
                    // both foo and bar are protected
                };
               
                class Derive3 : private Base {
                    // both foo and bar are private
                };
               
        2.2.4.2 Casting in an Inheritance Hierarchy
            * Case where you'd want to perform a cast:
           
                Person* pp[100];
                pp[0] = new Person(...);
                pp[1] = new Student(...);
                pp[1]->changeMajor("English");      // ERROR!
               
            * To access Student::changeMajor(), we need to cast the pp[1] pointer from 
                type Person* to type Student*
            * We need to determine whether this cast is legal, with a dynamic cast, 
                which has the syntax:
           
                dynamic cast < desired type > (expression)
               
            * Can only be applied to polymorphic objects
            * Syntax for this particular case:
           
                Student* sp = dynamic cast<Student*>(pp[1]);    // cast pp[1] to Student*
                sp->changeMajor("Chemistry");                   // now changeMajor is legal
               
            * If an illegal pointer cast is attempted the result is a null pointer
            * Example of dynamic casting as necessary across an array:
           
                for (int i = 0; i < 100; i++) {
                    Student *sp = dynamic cast<Student*>(pp[i]);
                    if (sp != NULL)
                        sp->changeMajor("Undecided");
                }
   
    2.2.5 Interfaces and Abstract Classes
        * Objects have to know about each other's members in order to interact
        * An API / interface defines what objects present to other objects
        * C++ has no formal interface specifier, but this book uses informal interfaces
        * Example of a minimal interface for a stack of integers:
       
            class Stack {
            public:
                bool isEmpty() const;
                void push(int x);
                int pop();
            };
           
        2.2.5.1 Abstract Classes
            * A class used only as a base class for inheritance
            * If you have to define a function as "pure virtual", which is to say entirely 
                abstract, use =0 as the body
            * C++ does not allow the creation of objects with pure virtual functions
            * All descendant classes must declare virtual versions of the abstract function
       
        2.2.5.2 Interfaces and Abstract Base Classes
            * Can construct a class for an interface in which all the functions are pure virtual:
           
                class Stack {
                public:
                    virtual bool isEmpty() const = 0;
                    virtual void push(int x) = 0;
                    virtual int pop() = 0;
                };
               
                class ConcreteStack : public Stack {
                public:
                    virtual bool isEmpty() { ... }
                    virtual void push(int x) { ... }
                    virtual int pop() { ... }
                private:
                    // ...
                };
               
2.3 Templates
    2.3.1 Function Templates
        * Function returning the minimum of two integers:
       
            int integerMin(int a, int b)
                { return (a < b ? a : b); }
               
        * If we wanted longMin, shortMin, floatMin, doubleMin, we'd have multiple 
            separate declarations of type
        * C++ lets you have a function template that produces a generic function for 
            an arbitrary type T
        * A genericMin function template:
       
            template <typename T>
            T genericMin(T a, T b) {
                return (a < b ? a : b);
            }
           
        * You can then use the generic template and the compiler will infer from the data 
            types what to do:
       
            cout << genericMin(3, 4) << ' '         // genericMin<int>(3,4)
                 << genericMin(1.1, 3.1) << ' '     // genericMin<double>(1.1,3.1)
                 << genericMin('t', 'g') << endl;   // genericMin<char>('t','g')
       
    2.3.2 Class Templates
        * Template for a restricted class BasicVector that stores a vector of elements, 
            overloading the [] indexing operator:
       
            template <typename T>
            class BasicVector {
            public:
                BasicVector(int capac = 10);            // constructor
                T& operator[](int i)                    // access element at index i
                    { return a[i]; }
                // ... other public members
            private:
                T* a;                                   // array storing the elements
                int capacity;                           // length of array a
            };
           
        * Definition for the constructor outside the class body:
       
            template <typename T>
            BasicVector<T>::BasicVector(int capac) {
                capacity = capac;
                a = new T[capacity];
            }
           
        * Instantiating concrete instances of BasicVector:
       
            BasicVector<int>        iv(5);
            BasicVector<double>     dv(20);
            BasicVector<string>     sv(10);
           
        2.3.2.1 Templated Arguments
            * Argument in the instantiation of a class template can itself be a templated type
            * Example of a BasicVector of BasicVector<int>'s:
           
                BasicVector<BasicVector<int> > xv(5);
                xv[2][8] = 15;
               
2.4 Exceptions
    2.4.1 Exception Objects
        * Example:
       
            class MathException {
            public:
                MathException(const string& err)
                    : errMsg(err) { }
                string getError() { return errMsg; }
            private:
                string errMsg;
            }
           
        2.4.1.1 Using Inheritance to Define New Exception Types
            * Example:
           
                class ZeroDivide : public MathException {
                public:
                    ZeroDivide(const string& err)
                        : MathException(err) { }
                };
               
                class NegativeRoot : public MathException {
                public:
                    NegativeRoot(const string& err)
                        : MathException(err) { }
                };
               
    2.4.2 Throwing and Catching Exceptions
        * Uses try blocks and catch blocks
        * Example:
       
            try {
                // ... application computations
                if (divisor == 0)
                    throw ZeroDivide("Divide by zero in Module X");
            }
            catch (ZeroDivide& zde) {
                // handle division by zero
            }
            catch (MathException& me) {
                // handle any math exception other than division by zero
            }
           
    2.4.3 Exception Specification
        * When declaring a function, you should specify the exceptions it might throw
        * Example:
       
            void calculator() throw(zeroDivide, NegativeRoot) {
                // function body ...
            }
           
        * If you declare them, you don't need to catch them in your function
        * Example of an exception that's passed through:
       
            void getReadyForClass() throw(ShoppingListTooSmallException, OutOfMoneyException) {
                goShopping();       // don't have to try or catch the exceptions
                                    // which goShopping might throw because
                                    // getReadyForClass will just pass these along
                makeCookiesForTA();
            }
           
        * If a function has no declared throw specification, it may throw any exception
       
        2.4.3.1 Generic Exception Class
            * Example:
           
                class RuntimeException {
                private:
                    string errorMsg;
                public:
                    RuntimeException (const string& err) { errorMsg = err; }
                    string getMessage() const { return errorMsg; }
                };
               
Chapter 3: Arrays, Linked Lists, and Recursion
   
3.1 Using Arrays
    3.1.1 Storing Game Entries in an Array
        * Example setup:
       
            class GameEntry {
            public:
                GameEntry(const string& n="", int s=0);
                string getName() const;
                int getScore() const;
            private:
                string name;
                int score;
            };
           
            GameEntry::GameEntry(const string& n, int s)
                : name(n), score(s) { }
               
            string GameEntry getName() const { return name; }
            int GameEntry::getScore() const { return score; }
           
            class Scores {
            public:
                Scores(int maxEnt = 10);
                ~Scores();
                void add(const GameEntry& e);
                GameEntry remove(int i)
                    throw(IndexOutOfBounds);
            private:
                int maxEntries;
                int numEntries;
                GameEntry* entries;
            };
           
            Scores::Scores(int maxEnt) {
                maxEntries = maxEnt;
                entries = new GameEntry[maxEntries];
                numEntries = 0;
            }
           
            Scores::~Scores() {
                delete[] entries;
            }
           
        * Example of how to insert at a sorted position:
       
            void Scores::add(const GameEntry& e) {
                int newScore = e.getScore();
                if (numEntries == maxEntries) {
                    if (newScore <= entries[maxEntries-1].getScore())
                        return;                                         // if it's smaller than the last element, do nothing
                }
                else numEntries++;
               
                int i = numEntries - 2;                                 // start with next to last
                while (i >= 0 && newScore > entries[i].getScore() ) {
                    entries[i+1] = entries[i];                          // move everything to the right
                    i--;
                }
                entries[i+1] = e;                                       // put the new value into the empty spot
            }
           
        3.1.1.3 Object Removal
            * Example of how to remove and heal the array:
           
                GameEntry Scores::remove(int i) throw(IndexOutOfBounds) {
                    if ((i < 0) || (i >= numEntries))
                        throw IndexOutOfBounds("Invalid Index");
                    GameEntry e = entries[i];
                    for (int j = i + 1; j < numEntries; j++)
                        entries[j-1] = entries[j];
                    numEntries--;
                    return e;
                }
                   
    3.1.2 Sorting an Array
        * Start with insertion sort
        * High level outline:
            - Start with the first element in the array, which definitionally 
                is sorted when by itself
            - Move to the next element
            - If it's smaller than the first, we swap them
            - Move to the third element
            - Swap it leftward until it is in proper order with the first two
            - Repeat until the array is exhausted of elements
        * C++ implementation:
       
            void insertionSort(char* A, int n) {
                for (int i = 1; i < n; i++) {
                    char cur = A[i];
                    int j = i - 1;
                    while ((j >= 0) && (A[j] > cur)) {
                        A[j + 1] = A[j];
                        j--;
                    }
                    A[j + 1] = cur;
                }
            }
           
    3.1.3 Two-Dimensional Arrays and Positional Games
        * A two dimensional array is defined via: int M[8][10]
       
        3.1.3.1 Dynamic Allocation of Matrices
            * If the dimensions of a two dimensional array aren't known in advance, 
                you have to allocate it dynamically
            * A dynamic array is a pointer to its first element, so each row in a 2d 
                matrix would be of type int*
            * The matrix itself is an array of row pointers, which makes the matrix itself 
                of type int**, a pointer to a pointer of ints
            * Example allocation:
           
                int** M = new int*[n];          // allocate an array of row pointers
                for (int i = 0; i < n; i++)
                    M[i] = new int[m];          // allocate the i-th row
           
            * To deallocate:
           
                for (int i = 0; i < n; i++)
                    delete[] M[i];              // delete the i-th row
                delete[] M;                     // delete the array of row pointers
               
        3.1.3.2 Using STL Vectors to Implement Matrices
            * Example of using vectors to create an nxm matrix as a vector of vectors:
           
                vector< vector<int> > M (n, vector<int>(m));
                cout << M[i][j] << endl;
               
        3.1.3.3 Tic-Tac-Toe
            * A program for playing tic tac toe between two players, on a 3x3 matrix:
           
                #include <cstdlib>
                #include <iostream>
                using namespace std;
               
                const int X = 1, O = -1, EMPTY = 0;
                int board[3][3];
                int currentPlayer;
               
                void clearBoard() {
                    for (int i = 0; i < 3; i++)
                        for (int j = 0; j < 3; j++)
                            board[i][j] = EMPTY;
                    currentPlayer = X;
                }
               
                void putMark(int i, int j) {
                    board[i][j] = currentPlayer;
                    currentPlayer = -currentPlayer;
                }
               
                bool isWin(int mark) {
                    int win = 3*mark;
                    return ((board[0][0] + board[0][1] + board[0][2] == win)
                        ||  (board[1][0] + board[1][1] + board[1][2] == win)
                        ||  (board[2][0] + board[2][1] + board[2][2] == win)
                        ||  (board[0][0] + board[1][0] + board[2][0] == win)
                        ||  (board[0][1] + board[1][1] + board[2][1] == win)
                        ||  (board[0][2] + board[1][2] + board[2][2] == win)
                        ||  (board[0][0] + board[1][1] + board[2][2] == win)
                        ||  (board[2][0] + board[1][1] + board[0][2] == win));
                }
               
                int getWinner() {
                    if (isWin(X)) return X;
                    else if (isWin(O)) return O;
                    else return EMPTY;
                }
               
                void printBoard() {
                    for (int i = 0; i < 3; i++) {
                        for (int j = 0; j < 3; j++) {
                            switch (board[i][j]) {
                            case X:             cout << "X"; break;
                            case O:             cout << "O"; break;
                            case EMPTY:         cout << " "; break;
                            }
                            if (j < 2) cout << "|";
                        }
                        if (i < 2) cout << "\n-+-+-\n";
                    }
                }
               
                int main() {
                    clearBoard();
                    putMark(0,0);
                    putMark(1,1);
                    putMark(0,1);
                    putMark(0,2);
                    putMark(2,0);
                    putMark(1,2);
                    putMark(2,2);
                    putMark(2,1);
                    putMark(1,0);
                    printBoard();
                   
                    int winner = getWinner();
                    if (winner != EMPTY)
                        cout << " " << (winner == X ? 'X' : 'O') << " wins" << endl;
                    else
                        cout << " Tie" << endl;
                    return EXIT_SUCCESS;
                }
               
3.2 Singly Linked Lists
    * A linked list is a collection of nodes that together form a linear ordering
    * Each node stores a pointer, called next, to the next node, and each node stores an element
    * The tail has a null next pointer
   
    3.2.1 Implementing a Singly Linked List
        * Example of node and list classes:
       
            class StringNode {
            private:
                string elem;
                StringNode* next;
               
                friend class StringLinkedList;
            }
           
            class StringLinkedList {
            public:
                StringLinkedList();
                ~StringLinkedList();
                bool empty() const;
                const string& front() const;
                void addFront(const string& e);
                void removeFront();
            private:
                StringNode* head;
            };
           
            StringLinkedList::StringLinkedList()
                : head(NULL) { }
               
            StringLinkedList::~StringLinkedList()
                { while (!empty()) removeFront(); }
               
            bool StringLinkedList::empty() const
                { return head == NULL; }
               
            const string& StringLinkedList::front() const
                { return head->elem; }
               
    3.2.2 Insertion to the Front of a Singly Linked List
        * Code:
       
            void StringLinkedList::addFront(const string& e) {
                StringNode* v = new StringNode;
                v->elem = e;
                v->next = head;
                head = v;
            }
           
    3.2.3 Removal from the Front of a Singly Linked List
        * Code:
       
            void StringLinkedList::removeFront() {
                StringNode* old = head;
                head = old->next;
                delete old;
            }
           
    3.2.4 Implementing a Generic Singly Linked List
        * Templates:
       
            template <typename E>
            class SNode {
            private:
                E elem;
                SNode<E>* next;
                friend class SLinkedList<E>;
            };
           
            template <typename E>
            class SLinkedList {
            public:
                SLinkedList();
                ~SLinkedList();
                bool empty() const;
                const E& front() const;
                void addFront(const E& e);
                void removeFront();
            private:
                SNode<E>* head;
            };
           
            template <typename E>
            SLinkedList<E>::SLinkedList()
                : head(NULL) { }
               
            template <typename E>
            bool SLinkedList<E>::empty() const
                { return head == NULL; }
               
            template <typename E>
            const E& SLinkedList<E>::front() const
                { return head->elem; }
               
            template <typename E>
            SLinkedList<E>::~SLinkedList()
                { while (!empty()) removeFront(); }
               
            template <typename E>
            void SLinkedList<E>::addFront(const E& e) {
                SNode<E>* v = new SNode<E>;
                v->elem = e;
                v->next = head;
                head = v;
            }
           
            template <typename E>
            void SLinkedList<E>::removeFront() {
                SNode<E>* old = head;
                head = old->next;
                delete old;
            }
           
3.3 Doubly Linked Lists
    * Has a next pointer and a previous pointer
    3.3.1
        3.3.1.1 Header and Trailer Sentinels
            * Good to have special nodes at both ends of a doubly linked list: a header 
                node and a trailer node
            * These 'sentinel' nodes don't store elements, they just give you quick 
                access to the ends
           
    3.3.2 Insertion into a Doubly Linked List
        * Basic process for a node v, a new node z to be after v, and w as the node 
            currently after v:
            - Make z's prev link point to v
            - make z's next link point to w
            - make w's prev link point to z
            - make v's next link point to z
           
    3.3.3 Removal from a Doubly Linked List
        * Process for removing a node v, where u is the node prior to v and w is 
            the node after v:
            - Make w's prev link point to u
            - Make u's next link point to w
            - Delete node v
           
    3.3.4 A C++ Implementation
       
        typedef string Elem;
        class DNode {
        private:
            Elem elem;
            DNode* prev;
            DNode* next;
            friend class DLinkedList;
        };
       
        class DLinkedList {
        public:
            DLinkedList();
            ~DLinkedList();
            bool empty() const;
            const Elem& front() const;
            const Elem& back() const;
            void addFront(const Elem& e);
            void addBack(const Elem& e);
            void removeFront();
            void removeBack();
        private:
            DNode* header;
            DNode* trailer;
        protected:
            void add(DNode* v, const Elem& e);
            void remove(DNode* v);
        };
       
        DLinkedList::DLinkedList() {
            header = new DNode;
            trailer = new DNode;
            header->next = trailer;
            trailer->prev = header;
        }
       
        DLinkedList::~DLinkedList() {
            while (!empty()) removeFront();
            delete header;
            delete trailer;
        }
       
        bool DLinkedList::empty() const
            { return (header->next == trailer); }
       
        const Elem& DLinkedList::front() const
            { return header->next->elem; }
           
        const Elem& DLinkedList::back() const
            { return trailer->prev->elem; }
           
        void DLinkedList::add(DNode* v, const Elem& e) {
            DNode* u = new DNode;
            u->elem = e;
            u->next = v;
            u->prev = v->prev;
            v->prev->next = v->prev = u;
        }
       
        void DLinkedList::addFront(const Elem& e)
            { add(header->next, e); }
       
        void DLinkedList::addBack(const Elem& e)
            { add(trailer, e); }
           
        void DLinkedList::remove(DNode* v) {
            DNode* u = v->prev;
            DNode* w = v->next;
            u->next = w;
            w->prev = u;
            delete v;
        }
       
        void DLinkedList::removeFront()
            { remove(header->next); }
           
        void DLinkedList::removeBack()
            { remove(trailer->prev); }
           
           
3.4 Circularly Linked Lists and List Reversal
    3.4.1 Circularly Linked Lists
        * Same kind of nodes, next pointers eventually take us all the way through
        * Has a node marked specially as a 'cursor', which gives an entry point for 
            starting traversal
        * Element referenced by the cursor is the "back", element following it is 
            the "front"
        * Implementation:
       
            typedef string Elem;
            class CNode {
            private:
                Elem elem;
                CNode* next;
               
                friend class CircleList;
            };
           
            class CircleList {
            public:
                CircleList();
                ~CircleList();
                bool empty() const;
                const Elem& front() const;
                const Elem& back() const;
                void advance();
                void add(const Elem& e);
                void remove();
            private:
                CNode* cursor;
            };
           
            CircleList::CircleList()
                : cursor(NULL);
               
            CircleList::~CircleList()
                { while (!empty()) remove(); }
               
            bool CirclList::empty() const
                { return cursor == NULL; }
           
            const Elem& CircleList::back() const
                { return cursor->elem; }
               
            const Elem& CircleList::front() const
                { return cursor->next->elem; }
           
            void CircleList::advance()
                { cursor = cursor->next; }
               
            void CircleList::add(const Elem& e) {
                CNode* v = new CNode;
                v->elem = e;
                if (cursor == NULL) {
                    v->next = v;
                    cursor = v;
                }
                else {
                    v->next = cursor->next;
                    cursor->next = v;
                }
            }
           
            void CircleList::remove() {
                CNode* old = cursor->next;
                if (old == cursor)
                    cursor = NULL;
                else
                    cursor->next = old->next;
                delete old;
            }
           
        3.4.1.1 Maintaining a Playlist for a Digital Audio Player
       
    3.4.2 Reversing a Linked List
        * Given a list L, first copy the contents of L in reverse order into a temporary 
            list T, then copy T back into L
        * Repeatedly extract the first element of L and copy it to the front of T
        * Implementation:
       
            void listReverse(DLinkedList& L) {
                DLinkedList T;
                while (!L.empty()) {
                    string s = L.front();
                    L.removeFront();
                    T.addFront(s);
                }
                while (!T.empty()) {
                    string s = T.front();
                    T.removeFront();
                    L.addBack(s);
                }
            }
           
3.5 Recursion
    3.5.1
        3.5.1.1 The Factorial Function
        3.5.1.2 A Recursive Implementation of the factorial function
            * Code:
           
                int recursiveFactorial(int n) {
                    if (n==0) return 1;
                    else return n * recursiveFactorial(n-1);
                }
               
        3.5.1.3 Drawing an English Ruler
        3.5.1.4 A Recursive Approach to ruler drawing
            * Code:
           
                // one tick with optional label
                void drawOneTick(int tickLength, int tickLabel = -1) {
                    for (int i = 0; i < tickLength; i++)
                        cout << "-";
                    if (tickLabel >= 0) cout << " " << tickLabel;
                    cout << "\n";
                }
               
                void drawTicks(int tickLength) {
                    if (tickLength > 0) {
                        drawTicks(tickLength-1);
                        drawOneTick(tickLength);
                        drawTicks(tickLength-1);
                    }
                }
               
                void drawRuler(int nInches, int majorLength) {
                    drawOneTick(majorLength, 0);
                    for (int i = 1; i <= nInches; i++) {
                        drawTicks(majorLength-1);
                        drawOneTick(majorLength, i);
                    }
                }
           
        3.5.1.5 Illustrating Ruler Drawing Using a Recursion Trace
        3.5.1.6 Further Illustrations of Recursion
       
    3.5.2 Linear Recursion
        * Simplest version of recursion, where a function makes at most one recursive call
            each time it's invoked
        * Useful when we view an algorithmic problem in terms of a first or last element 
            plus a remaining set with the same structure as the original set
       
        3.5.2.1 Summing the Elements of an Array Recursively
            * Given an array A of n integers to sum, we can observe that the sum of all 
                n integers is equal to A[0] if n = 1 or the sum of the first n - 1 
                integers in A plus the last element in A
            * Algorithm for summing the elements in an array with linear recursion:
           
                Algorithm LinearSum(A,n):
                    Input: An integer array A and an integer n >= 1, such that A has at 
                            least n elements
                    Output: The sum of the first n integers in A
                    if n = 1 then
                        return A[0]
                    else
                        return LinearSum(A, n-1) + A[n-1]
                       
            * Recursive functions should always terminate, helps to write one final 
                non recursive statement
            * In general, an algorithm that uses linear recursion typically has the 
                following form:
                - Test for base cases: every possible chain of recursive calls should 
                    reach a base case, and the base case should be handled non-recursively
                - Recur: after testing for base cases, we make a single recursive call, 
                    possibly choosing one call from several. Each recursive call should 
                    make progress towards a base case
                   
        3.5.2.2 Analyzing Recursive Algorithms using Recursion Traces
            * Draw it out by creating a box for every instance of the function
            * Label it with the parameters of the function
            * Draw an arrow from the box of the calling function to the box of the 
                called function
           
        3.5.2.3 Reversing an Array by Recursion
            * Algorithm:
           
                Algorithm ReverseArray(A, i, j):
                    Input: An array A and nonnegative integer indices i and j
                    Output: The reversal of the elements in A starting at i and ending at j
                    if i < j then
                        Swap A[i] and A[j]
                        ReverseArray(A, i+1, j-1)
                    return
                   
        3.5.2.4 Defining Problems in Ways that Facilitate Recursion
            * Think of how to subdivide the problem to define problems with the same 
                structure as the original problem
           
        3.5.2.5 Tail Recursion
            * Each recursive call has to be kept track of in memory
            * Possible to use a stack to convert a recursive algorithm into a 
                nonrecursive algorithm
            * An algorithm uses 'tail recursion' if it uses linear recursion and the 
                algorithm makes a recursive call as its last operation
            * The above algorithm reversal uses tail recursion
            * Additionally, the recursive call has to be absolutely the last thing 
                the function does
            * If a function is using tail recursion, we can convert the recursive 
                algorithm into a nonrecursive one by iterating through the recursive 
                calls rather than calling them explicitly
            * Example:
           
                Algorithm ReverseArray(A, i, j):
                    Input: An array A and nonnegative integer indices i and j
                    Output: The reversal of the elements in A starting at i and ending at j
                    while i < j do
                        Swap A[i] and A[j]
                        i <- i+1
                        j <- j-1
                    return
                   
    3.5.3 Binary Recursion
        * When an algorithm makes two recursive calls, it uses binary recursion
        * Example of summing an array with binary recursion:
       
            Algorithm BinarySum(A, i, n):
                Input: An array A and integers i and n
                Output: The sum of the n integers in A starting at i
                if n = 1 then
                    return A[i]
                return BinarySum(A, i, n/2) + BinarySum(A, i+n/2, n/2)
               
        * Halves the depth of the recursion
        * Run time is the same, but memory use is lower
       
        3.5.3.1 Computing Fibonacci Numbers via Binary Recursion
            * Algorithm:
           
                Algorithm BinaryFib(k):
                    Input: Nonnegative integer k
                    Output: The kth Fibonacci number Fk
                    if k = 1 then
                        return k
                    else
                        return BinaryFib(k - 1) + BinaryFib(k - 1)
                       
            * That actually takes an exponential number of calls to compute
           
        3.5.3.2 Computing Fibonacci Numbers via Linear Recursion
            * Algorithm:
           
                Algorithm LinearFibonacci(k):
                    Input: A nonnegative integer k
                    Output: Pair of fibonacci numbers (Fk, Fk-1)
                    if k <= 1 then
                        return (k, 0)
                    else
                        (i, j) <- LinearFibonacci(k-1)
                        return (i + j, i)
                       
    3.5.4 Multiple Recursion
        * When a function may make multiple recursive calls, with that number being 
            potentially more than two
        * One of the most common cases is to enumerate various configurations in order 
            to solve a combinatorial puzzle
        * For puzzles like:
       
            pot + pan = bib
            dog + cat = pig
            boy + girl = baby
           
        * You replace each letter with a digit until the equation works
        * If the problem space is not too large, we can enumerate all possibilities 
            and test each one
        * Below is an algorithm that enumerates and tests all k- length sequences 
            without repetitions of the elements of a set U
        * We build the sequences of k elements by the following steps:
            1. Recursively generating the sequences of k-1 elements
            2. Appending to each such sequence an element not already contained in it
        * We use the set U to keep track of the elements not contained in the current 
            sequence, so e has not been used if e is in U
        * It enumerates every possible size-k ordered subset of U and tests each subset 
            for being a possible solution
        * For summation puzzles, U = {0,1,2,3,4,5,6,7,8,9}
        * Algorithm:
           
            Algorithm PuzzleSolve(k, S, U):
                Input: An integer k, sequence S, and set U
                Output: An enumeration of all k-length extensions to S using elements 
                        in U without repetitions
               
                for each e in U do
                    Remove e from U
                    Add e to the end of S
                    if k = 1 then
                        Test whether S is a configuration that solves the puzzle
                        if S solves the puzzle then
                            return "solution found: " S
                    else
                        PuzzleSolve(k-1, S, U)
                    Add e back to U
                    Remove e from the end of S
                   
Chapter 4: Analysis Tools

4.1 The Seven Functions Used in this Book
    * Seven most important functions used in the analysis of algorithms
   
    4.1.1 The Constant Function
        * Simplest one:
       
            f(n) = c
           
        * For some fixed constant c
        * For any argument n, the constant function f(n) assigns the value c--doesn't matter what n is, f(n) is always c
        * Most fundamental constant function is g(n) = 1, and any other constant function can be written c * g(n)
       
    4.1.2 The Logarithm Function
        * Defined as follows:
       
            f(n) = log-b n, for some constant b > 1
           
        * Also stated as:
       
            x = log-b n if and only if b^x = n
           
        * Most common base for log in CS is base 2, so for us log n = log-2 n
       
        4.1.2.1
       
            4.1.2.1.1 Proposition 4.1 (Logarithm Rules)
                * Given real numbers a > 0, b > 1, c > 0, d > 1, we have:
                    1.  log-b ac    = log-b a + log-b c
                    2.  log-b a/c   = log-b a - log-b c
                    3.  log-b a^c   = c * log-b a
                    4.  log-b a     = (log-d a) / log-d b
                    5.  b^log-d^a   = a^log-d^b
       
    4.1.3 The Linear Function
        * Linear function: f(n) = n
        * Given an input n, the linear function f assigns the value n itself
        * Comes up any time we have to do a single basic operation for each of n elements
        * Best running time for any algorithm that processes a collection of n objects that are not already in memory
       
    4.1.4 The N-Log-N Function
        * N-log-n function: f(n) = n log-n
        * Assigns to an input n the value of n times the log base 2 of n
        * Grows faster than the linear function, slower than the quadratic
        * If you can go from quadratic to n log n, it's much faster
       
    4.1.5 The Quadratic Function
        * Quadratic function: f(n) = n^2
        * Given an input n, f assigns the product of n with itself (n squared)
        * Many algorithms have nested loops, where the inner loop does a linear number of ops and the outer loop is a linear number
        * Thus the algorithm performs n * n = n^2 ops
       
        4.1.5.1 Nested Loops and the Quadratic Function
            * Can also arise in the context of nested loops where the first iteration of a loop uses one op, the second uses two, etc
            * Total number of ops is 1 + 2 + 3 + ... + (n - 2) + (n - 1) + n
            * Identity: For any integer n >= 1, we have:
           
                                                            n (n + 1)
                1 + 2 + 3 + ... + (n - 2) + (n - 1) + n  =  ---------
                                                                2
                                                               
            * If there's an algorithm with nested loops such that the ops in the inner loop increase by one each time, the total ops is quadratic in the number of times, n, we perform the outer loop--total ops will be (n^2)/2 + n/2
           
    4.1.6 The Cubic Function and Other Polynomials
        * Cubic function: f(n) = n^3
        * For an input of n assigns the product of n with itself 3 times
       
        4.1.6.1 Polynomials
            * Function of the form:
           
                f(n) = a0 + a1n + a2n^2 + a3n^3 + ... + adn^d
               
        4.1.6.2 Summations
       
              b
              E f(i) = f(a) + f(a + 1) + f(a + 2) + ... + f(b)
             i=a
            
            * Where a and b are integers and a <= b
            * Formula of the above identity as a summation:
           
                  n      n(n+1)
                  E i =  ------
                 i=1       2
           
    4.1.7 The Exponential Function
        * Exponential function: f(n) = b^n
        * Where b is a positive constant (the base) and n is the exponent
       
        4.1.7.1
            4.1.7.1.1 Exponent Rules
                * Given postive integers a, b, and c:
                    1.  (b^a)^c = b^ac
                    2.  b^a * b^c = b^a+c
                    3.  b^a / b^c = b^a-c
                   
        4.1.7.2 Geometric Sums
            * Suppose a loop where each iteration takes a multiplicative factor longer
            * Can be analyzed with the following proposition:
           
                For any integer n >= 0 and any real number a
                such that a > 0 and a != 1, consider the summation
                               
                  n
                  E a^i = 1 + a + a^2 + ... + a^n
                 i=0
                
                which is equal to (a^n+1)-1 / a-1
               
    4.1.8 Comparing Growth Rates
        * Classes of functions, assuming that a > 1:
       
            Constant        1
            logarithm       log n
            linear          n
            n-log-n         n log n
            quadratic       n^2
            cubic           n^3
            exponential     a^n
           
        4.1.8.1 The Ceiling and Floor Functions
            * Notation for floor is something like |_x_|
                                                      _ _
            * Notation for ceiling is something like | x |
           
4.2 Analysis of Algorithms
    * A data structure is a systematic way of organizing and accessing data
    * An algorithm is a step by step procedure for performing some task in a finite amount of time
    * Main axis of analysis is run time, with space being a secondary consideration
    * In general, run time increases with input size
    * Interested in characterizing an algorithm's running time as a function of input size
   
    4.2.1 Experimental Studies
        * Repeated trials with different input sizes are useful
        * Three major limitations:
            - Can only be done on a limited set of test inputs, rather than all possible inputs
            - Difficult to compare two trials if hardware/software environments differ
            - Have to fully implement and execute an algorithm to study it experimentally
        * Would like to have an analysis tool that:
            - Takes into account all possible inputs
            - Measures efficiency independent of hardware/software environment
            - Can be performed on pseudocode rather than a full implementation
        * Aims at associating each algorithm with a function f(n) that characterizes the run time
       
    4.2.2 Primitive Operations
        * Primitive ops are things like:
            - Assigning a value to a variable
            - calling a function
            - performing an arithmetic operation
            - comparing two numbers
            - indexing into an array
            - following an object reference
            - returning from a function
           
        4.2.2.1 Counting Primitive Operations
            * A primitive op corresponds to a low level instruction with a constant execution time
            * We count primitive ops as number t, use it as a measure of run time
            * Each op takes a fixed amount of time on any particular computer, so t is proportional to the overall run time
            * Since different inputs may take different times, we want an "average-case" analysis
            * Average-case can be tough, since you need a probability distribution
           
        4.2.2.2 Focusing on the Worst Case
            * Rather than focusing on the probability of inputs, we focus on the worst case
            * Worst case analysis is way easier than average case
           
    4.2.3 Asymptotic Notation
        * We analyze algorithms using a mathematical notation for functions that disregards
            constant factors. We characterize run times using functions that map the size of n
            to values corresponding to the main factor determining the groth rate in terms of n
        * Algorithm arrayMax:
           
            Algorithm arrayMax(A, n):
                Input:  An array A storing n >= 1 integers
                Output: The maximum element in A
               
                currMax <- A[0]
                for i <- 1 to n - 1 do
                    if currMax < A[i] then
                        currMax <- A[i]
                return currMax
               
        4.2.3.1 The Big-Oh Notation
            * Let f(n) and g(n) be functions mapping nonnegative integers to real numbers
            * f(n) is O(g(n)) if there is a real constant c > 0 and an integer constant n0 >= 1
                such that:
               
                    f(n) <= cg(n), for n >= n0
                   
            * Called "f(n) is big-Oh of g(n)" or "f(n) is order of g(n)"
           
        4.2.3.2 Example 4.6
            * The function g(n) = 8n - 2 is O(n)
            * Justified because any c greater than 8 and n0 >= 1 make f(n) <= g(n)
       
        4.2.3.3 Characterizing Running Times using the Big-O Notation
            * For arrayMax, n denotes the number of array elements
            * For any computer, arrayMax runs in O(n) time
            * Since the primitive ops per iteration is constant, it's O(n)
           
        4.2.3.4 Some Properties of the Big-Oh Notation
            * Focuses on main components of a function that affect its growth
           
            4.2.3.4.1 Example 4.8
           
                5n^4 + 3n^3 + 2n^2 + 4n + 1 is O(n^4)
               
                Since 5n^4 + 3n^3 + 2n^2 + 4n + 1 <= (5 + 3 + 2 + 4 + 1)n^4 = cn^4 for c=15,
                    when n >= n0 = 1, the growth rate can be characterized as O(n^4)
                   
                If a polynomial is of degree d, and a sub d > 0, then f(n) is O(n^d)
                Highest degree in a polynomial determines the asymptotic growth rate
               
            4.2.3.4.2 Example 4.10
           
                5n^2 + 3nlogn + 2n + 5 is O(n^2)
               
                Justification: 5n^2 + 3nlogn + 2n + 5 <= (5 + 3 + 2 + 5)n^2 = cn^2 for c = 15,
                    when n >= n0 = 2
                   
            4.2.3.4.3 Example 4.11
           
                20n^3 + 10nlogn + 5 is O(n^3)
               
                Justification: 20n^3 + 10nlogn + 5 <= 35n^3, for n >= 1
               
            4.2.3.4.4 Example 4.12
           
                3 log n + 2 is O(log n)
               
                Justification: 3 log n + 2 < 5 log n, for n >= 2
               
            4.2.3.4.5 Example 4.12
           
                2^(n+2) is O(2^n)
               
                Justification: 2^(n+2) = 2^n * 2^2 = 4 * 2^n, hence c=4 and n0 = 1
               
            4.2.3.4.6 Example 4.14
           
                2n + 100 log n is O(n)
               
                Justification: 2n + 100 log n <= 102n, for n >= n0 = 2
               
        4.2.3.5 Characterizing Functions in Simplest Terms
            * Try to categorize the growth in reasonable terms, not extreme ones
            * Typically we use the names of the 7 functions to categorize algorithms,
                like saying 4n^2 + n log n is a quadratic-time algorithm, since it's O(n^2)
               
        4.2.3.6 Big-Omega
            * Implies that a function grows at a rate "greater than or equal to" another,
                rather than the O() notation's meaning "less than or equal to"
            * Let f(n) and g(n) be functions mapping nonnegative integers to real numbers
            * f(n) is omega(g(n)) if g(n) is O(f(n))
           
            4.2.3.6.1 Example 4.15
           
                3n log n + 2n is omega(n log n)
               
                Justification: 3n log n + 2n >= 3n log n, for n >= 2
               
        4.2.3.7 Big-Theta
            * Lets you say that two functions grow at the same rate up to constant factors
            * f(n) is theta(g(n)) if f(n) is O(g(n)) and f(n) is omega(g(n))
            * which is to say there are real constants c' > 0 and c" > 0, and an int n0 >= 1,
                such that:
               
                    c' g(n) <= f(n) <= c" g(n), for n >= n0
                   
            4.2.3.7.1 Example 4.16
           
                3n log n + 4n + 5 log n is theta(n log n)
               
                Justification: 3n log n <= 3n log n + 4n + 5 log n <= (3+4+5) n log n for n >= 2
               
    4.2.4 Asymptotic Analysis
        * We use big O notation to order classes of functions by asymptotic growth rate
        * Sequence is
           
            1 < log n < n < n log n < n^2 < n^3 < 2^n
           
    4.2.5 Using the Big-Oh Notation
        * Best syntax is to say f(n) is O(g(n)), rather than f(n) = O(g(n))
       
        4.2.5.1 Some Words of Caution
            * The notation can be misleading if the constants it obscures are very large
            * Any algorithm running in O(n log n) time (with a reasonable constant factor) is
                considered efficient, and even O(n^2) may be fast for small values of n
               
        4.2.5.2 Exponential Running Times
            * Huge distinction between algorithms that run in polynomial time and exponential time
           
        4.2.5.3 Two Examples of Asymptotic Algorithm Analysis
            * Problem is to compute "prefix averages" of a sequence of numbers
            * Given an array X storing n numbers, we want to compute an array A such that A[i] is the average of X[0]...X[i]
            * For i=0,...n-1, that is:
           
                        i
                        E  X[j]
                       j=0
                A[i] = --------
                         i + 1
                        
        4.2.5.4 A Quadratic-Time Algorithm
            * Algorithm that computes every element of A separately:
           
                Algorithm prefixAverages1(X):
                    Input: An n-element array X of numbers
                    Output: An n-element array A of numbers such that A[i] is the average of X[0]...X[i]
                   
                    Let A be an array of n numbers
                    for i <- 0 to n-1 do
                        a <- 0
                        for j <- 0 to i do
                            a <- a + X[j]
                        A[i] <- a / (i+1)
                    return array A
                   
            * Analysis:
                - Initializing and returning A at the beginning and end can be done
                    with a constant number of primitive ops, takes O(n) time
                - There are two nested for loops controlled by i and j. The outer loop is
                    executed n times for i=0 through n-1, so the statements a=0 and A[i] = a/(i+1)
                    are executed n times each. Since each has a set number of primitive ops,
                    this is also in O(n) time
                - The inner loop is executed i+1 times depending on the current value of the
                    outer loop's i. Since 1+2+3+...+n = n(n+1)/2, this is O(n^2) time
                   
            * The running time is given by the sum of three terms, O(n), O(n) and O(n^2)
            * The degree of that polynomial is 2, so the overall function is O(n^2)
           
        4.2.5.5 A Linear-Time Algorithm
            * To compute averages more effectively, we observe that A[i-1] and A[i] are similar
            * Second algorithm:
           
                Algorithm prefixAverages2(X):
                    Input: An n-element array X of numbers
                    Output: An n-element array A of numbers such that A[i] is the average of X[0]...X[i]
                   
                    Let A be an array of n numbers
                    s <- 0
                    for i <- 0 to n-1 do
                        s <- s + X[i]
                        A[i] <- s / (i+1)
                    return Array A
                   
            * Analysis:
                - Initializing and returning A is constant, so takes O(n) time
                - Initializing variable s takes O(1) time
                - The single for loop executes n times, so is O(n) time
           
            * Running time is given by the sum of three terms, O(n), O(1) and O(n)--overall is O(n)
           
    4.2.6 A Recursive Algorithm for Computing Powers
        * The power function p(x,n) is defined as p(x,n) = x^n
        * Recursive definition based on linear recursion:
       
            p(x,n) = | 1                if n = 0
                     | x * p(x, n-1)    otherwise
                    
        * Algorithm:
       
            Algorithm Power(x, n):
                Input: A number x and integer n = 0
                Output: The value x^n
               
                if n = 0 then
                    return 1
                if n is odd then
                    y <- Power(x, (n-1)/2)
                    return x * y * y
                else
                    y <- Power(x, n/2)
                    return y * y
                   
        * Each recursive call divides the exponent n by two, so there are O(log n) recursive calls
       
    4.2.7 Some More Examples of Algorithm Analysis
        4.2.7.1 A Constant-Time Method
            * Consider the function:
           
                int capacity(const vector<int>& arr) {
                    return arr.size();
                }
               
            * The running time is O(1), because it calls once regardless of the size of the array
           
        4.2.7.2 Revisiting the Method for Finding the Maximum in an Array
            * Consider the function:
           
                int findMax(const vector<int>& arr) {
                    int max = arr[0];
                    for (int i = 1; i < arr.size(); i++) {
                        if (max < arr[i]) max = arr[i];
                    }
                    return max;
                }
               
            * Running time is O(n), because it runs once for every element in the array
           
        4.2.7.3 Further Analysis of the Maximum Finding Algorithm
            * If each number in the array is higher than the previous, we update max n times, so O(n)
            * If the array's contents are randomly distributed, the probability that element i is greater than max is 1/i
            * The expected number of times we update then is:
           
                      n
                Hn =  E 1/i
                     i=1
               
            * Which is the nth harmonic number. Hn is O(log n), which means the max is updated about O(log n)
           
        4.2.7.4 Three-Way Set Disjointness
            * Suppose three sets, A, B, and C, stored in three different integer arrays a, b, and c
            * The problem is to determine if the sets are disjoint: whether there is no element x that is an element of A, B and C
            * A simple C++ function to determine this property:
           
                bool areDisjoint(const vector<int>& a, const vector<int>& b, const vector<int>& c) {
                    for (int i = 0; i < a.size(); i++)
                        for (int j = 0; j < b.size(); j++)
                            for (int k = 0; k < c.size(); k++)
                                if ((a[i] == b[j]) && (b[j] == c[k])) return false;
                    return true;
                }
               
            * This method is O(n^3) due to the triply nested loop
           
        4.2.7.5 Recursion Run Amok
            * Next samples are for the element uniqueness problem
            * We are given a range, i, i+1, ..., j, of indices for an array A which we assume is an STL vector
            * We want to determine if the elements in the given range are all unique
            * Recursive but very inefficient method:
           
                bool isUnique(const vector<int>& arr, int start, int end) {
                    if (start >= end) return true;
                    if (!isUnique(arr, start, end-1))
                        return false;
                    if (!isUnique(arr, start+1, end))
                        return false;
                    return (arr[start] != arr[end]);
                }
               
            * For a set of n size, you'll get two calls on ranges of size n-1, each of which will make two calls on n-2, etc
            * Method is O(2^n)
           
        4.2.7.6 An Iterative Method for Solving the Element Uniqueness Problem
            * Iterative version:
           
                bool isUniqueLoop(const vector<int>& arr, int start, int end) {
                    if (start >= end) return true;
                    for (int i = start; i < end; i++)
                        for (int j = i+1; j <= end; j++)
                            if (arr[i] == arr[j]) return false;
                    return true;
                }
               
            * Compares all element pairs using nested for loops, is O(n^2)
           
        4.2.7.7 Using Sorting as a Problem-Solving Tool
            * Better approach is to sort and then compare, since any duplicates will be next to each other post sort
            * Method:
           
                bool isUniqueSort(const vector<int>& arr, int start, int end) {
                    if (start >= end) return true;
                    vector<int> buf(arr);
                    sort(buf.begin()+start, buf.begin()+end);
                    for (int i = start; i < end; i++)
                        if (buf[i] == buf[i+1]) return false;
                    return true;
                }
               
            * Sort runs in O(n log n) time, and the other steps run in O(n), so the overall is O(n log n)
           
4.3 Simple Justification Techniques
    4.3.1 By Example
        4.3.1.1
            4.3.1.1.1 Example 4.17
                * Disproving a generality is done by finding a counter example
               
    4.3.2 The "Contra" Attack
        * Two methods: contrapositive and contradiction
        * To justify the statement "if p is true then q is true", establish that "if q is not true, p is not true" instead
        * The latter of the two is the contrapositive of the first
       
        4.3.2.1
            4.3.2.1.1 Example 4.18
                * Claim: Let a and b be integers. If ab is even, then a is even or b is even.
                * Justification: Consider contrapositive: if a is odd and b is odd then ab is odd
               
        4.3.2.2 Contradiction
            * Establish that a statement q is true by first supposing that q is false and then showing that that leads to a contradiction
           
            4.3.2.2.1 Example 4.19
                * Claim: Let a and b be integers. If ab is odd, then a is odd and b is odd
                * Justification: Let ab be odd. We wish to show that a is odd and b is odd, so assume the opposite, that a is even or b is even
               
    4.3.3 Induction and Loop Variants
        4.3.3.1 Induction
            * Induction amounts to showing that for any particular n >= 1, there is a finite sequence of implications
                that starts with something known to be true and ultimately leads to showing that q(n) is true
            * Show that q(n) is true for n=1 (and other values up to some constant k), then we justify that q(n) is true for i < k
            * Proposition 4.20:
                Claim: Consider teh Fibonacci function F(n) where F(1) = 1, F(2) = 2, F(n) = F(n-1) + F(n-2) for n > 2
                Justification: Show that our claim is right by induction

        4.3.3.2 Loop Invariants
            * To prove some statement S about a loop is correct, define S in terms of a series of smaller statements S0, S1, ..., Sk, where:
                - The initial claim, S0, is true before the loop begins
                - If Si-1 is true before iteration i, then Si is true after iteration i
                - The final statement, Sk, implies the statement S that we wish to be true
            * Using the loop invariant method to justify the correctness of arrayFind:
           
                Algorithm arrayFind(x, A):
                    Input: An element x and an n-element array, A
                    Output: The index i such that x = A[i] or -1 if no element of A is equal to x
                   
                    i <- 0
                    while i < n do
                        if x = A[i] then
                            return i
                        else
                            i <- i+1
                    return -1
                   
            * We claim that the following is true at the beginning of iteration i of the while loop:
               
                Si: x is not equal to any of the first i elements of A
               
            * That's true at the beginning of the first iteration of the loop, since there are no elements among the first 0 in A
            * In iteration i, we compare x to A[i] and return i if they are equal
            * If x and A[i] are not equal, we have found one more element not equal to x and we increment i
            * Thus Si is true for the new value of i; hence it is true at the beginning of the next iteration
           
Chapter 5: Stacks, Queues, and Deques

5.1 Stacks
    * A stack is a container of objects that are inserted and removed according to the last-in first out (LIFO) principle
    * You push onto the stack, and pop off of it, both from the front
   
    5.1.1
        5.1.1.1
            5.1.1.1.1 Example 5.1
                * The history of a browser is a stack--go back and you pop the last site off, go forward and push one on
               
            5.1.1.1.2 Example 5.2
                * Text editor change histories go into a stack
               
    5.1.2 The Stack Abstract Data Type
        * A stack is an ADT that supports the following ops: push(e), pop(), top(), size(), empty()
       
        5.1.2.1
            5.1.2.1.1 Example 5.3
                * Specific examples of method calls on a stack
               
    5.1.3 The STL Stack
        * STL gives you a stack based on STL vectors
        * To use a stack, you do:
       
            #include <stack>
            using std::stack;           // make Stack accessible
            stack<int> myStack;         // a stack of integers
           
    5.1.4 A C++ Stack Interface
        * When defining an ADT, we want to define an API or interface
        * No simple C++ method of defining interfaces
        * Illustration of a stack interface, not a complete C++ class:
       
            template <typename E>
            class Stack {
            public:
                int size() const;
                bool empty() const;
                const E& top() const throw(StackEmpty);
                void push(const E& e);
                void pop throw(StackEmpty);
            }
           
        * Exception thrown by pop and top when called on an empty stack:
       
            class StackEmpty : public RuntimeException {
            public:
                StackEmpty(const string& err) : RuntimeException(err) {}
            };
           
    5.1.5 A Simple Array-Based Stack Implementation
        * Can implement a stack by storing elements in an array
        * These consist of an N-element array S plus an integer variable t that gives the index of the top element in the array S
        * Fragment describing stack operations:
       
            Algorithm size():
                return t+1
            Algorithm empty():
                return (t < 0)
            Algorithm top():
                if empty() then
                    throw StackEmpty exception
                return S[t]
            Algorithm push(e):
                if size() = N then
                    throw StackFull exception
                t <- t + 1
                S[t] <- e
            Algorithm pop():
                if empty() then
                    throw StackEmpty exception
                t <- t-1
               
        5.1.5.1 A C++ Implementation of a Stack
            * ArrayStack class:
           
                template <typename E>
                class ArrayStack {
                    enum { DEF_CAPACITY = 100 };
                public:
                    ArrayStack(int cap = DEF_CAPACITY);
                    int size() const;
                    bool empty() const;
                    const E& top() const throw(StackEmpty);
                    void push(const E& e) throw(StackFull);
                    void pop() throw (StackEmpty);
                    // ... housekeeping functions omitted
                private:
                    E* S;
                    int capacity;
                    int t;
                };
               
            * Methods:
           
                template <typename E> ArrayStack<E>::ArrayStack(int cap)
                    : S(new E[cap]), capacity(cap), t(-1) { }
                   
                template <typename E> int ArrayStack<E>::size() const
                    { return (t+1); }
                   
                template <typename E> bool ArrayStack<E>::empty() const
                    { return (t < 0); }
                   
                template <typename E>
                const E& ArrayStack <E>::top() const throw(StackEmpty) {
                    if (empty()) throw StackEmpty("Top of empty stack");
                    return S[t];
                }
               
                template <typename E>
                void ArrayStack<E>::push(const E& e) throw(StackFull) {
                    if (size() == capacity) throw StackFull("Push to full stack");
                    S[++t] = e;
                }
               
                template <typename E>
                void ArrayStack<E>::pop() throw(StackEmpty) {
                    if (empty()) throw StackEmpty("Pop from empty stack");
                    --t;
                }
               
            * The STL stack class, based on STL vector, is automatically expanded when the stack overflows
           
    5.1.6 Implementing a Stack with a Generic Linked List
        * The LinkedStack class:
       
            typedef string Elem;
            class LinkedStack {
            public:
                LinkedStack();
                int size() const;
                bool empty() const;
                const Elem& top() const throw(StackEmpty);
                void push(const Elem& e);
                void pop() throw (StackEmpty);
            private:
                SLinkedList<Elem> S;
                int n;
            };
           
            LinkedStack::LinkedStack()
                : S(), n(0) {}
               
            int LinkedStack::size() const
                { return n; }
               
            bool LinkedStack::empty() const
                { return n == 0; }
               
            const Elem& LinkedStack::top() const throw(StackEmpty) {
                if (empty()) throw StackEmpty("Top of empty stack");
                return S.front();
            }
           
            void LinkedStack::push(const Elem& e) {
                ++n;
                S.addFront(e);
            }
           
            void LinkedStack::pop() throw (StackEmpty) {
                if (empty()) throw StackEmpty("Pop from empty stack");
                --n;
                S.removeFront();
            }
           
    5.1.7 Reversing a Vector Using a Stack
        * A stack can non recursively reverse the elements in a vector:
       
            template <typename E>
            void reverse(vector<E>& V) {
                ArrayStack<E> S(V.size());
                for (int i = 0; i < V.size(); i++)
                    S.push(V[i]);
                for (int i = 0; i < V.size(); i++) {
                    V[i] = S.top(); S.pop();
                }
            }
           
    5.1.8 Matching Parentheses and HTML Tags
        5.1.8.1 An Algorithm for Parentheses Matching
            * Suppose a sequence X = x0 x1 x2 ... xn-1, where each xi is a token that
                can be a grouping symbol, a variable name, an arithmetic operator, or a number
            * Process the tokens in X in order
            * Every time you encounter an opening symbol, push it onto a stack S
            * Each time you encounter a closing symbol, pop the top symbol off the stack, check that they're corresponding types
            * If the stack is empty when you finish X, the symbols matched
            * Algorithm:
           
                Algorithm ParenMatch(X, n):
                    Input: An array X of n tokens, each of which is either a grouping symbol, var, arithmetic op, or a number
                    Output: true if and only if all grouping symbols in X match
                   
                    Let S be an empty stack
                    for i <- 0 to n - 1 do
                        if X[i] is an opening grouping symbol then
                            S.push(x[i])
                        else if X[i] is a closing grouping symbol then
                            if S.empty() then
                                return false
                            if S.top() does not match the type of X[i] then
                                return false
                            S.pop()
                    if S.empty() then
                        return true
                    else
                        return false

        5.1.8.2 Matching Tags in an HTML Document
            * Code to get a vector of html tags from the input and store them in a vector of strings
           
                vector<string> getHtmlTags() {
                    vector<string> tags;
                    while (cin) {
                        string line;
                        getline(cin, line);
                        int pos = 0;
                        int ts = line.find("<", pos);
                        while (ts != string::npos) {
                            int te = line.find(">", ts+1);
                            tags.push_back(line.substr(ts, te-ts+1));
                            pos = te + 1;
                            ts = line.find("<", pos);
                        }
                    }
                    return tags;
                }
               
5.2 Queues
    * A queue is a first in first out (FIFO) container
    * Elements enter at the rear, are removed from the front
   
    5.2.1 The Queue Abstract Data Type
        * First element is the front
        * End of the sequence is the rear
        * The queue ADT supports the following ops:
            enqueue(e)
            dequeue()
            front()
            size()
            empty()
           
        5.2.1.1
            5.2.1.1.1 Example 5.4
           
    5.2.2 The STL Queue
        * The STL queue is based on STL vector
        * To use it:
       
            #include <queue>
            using std::queue;
            queue<float> myQueue;
           
        * Methods:
            size()
            empty()
            push(e)
            pop()
            front()
            back()
           
    5.2.3 A C++ Queue Interface
        * Informal interface:
       
            template <typename E>
            class Queue {
            public:
                int size() const;
                bool empty() const;
                const E& front() const throw(QueueEmpty);
                void enqueue(const E& e);
                void dequeue() throw(QueueEmpty);
            };
           
        * Exception class:
       
            class QueueEmpty : public RuntimeException {
            public:
                QueueEmpty(const string& err) : RuntimeException(err) { }
            };
           
    5.2.4 A Simple Array-based Implementation
        * A queue via an array Q with capacity N
        * Main issue is how to keep track of the front and rear
        * Not efficient to treat it as a linear stack but backwards
       
        5.2.4.1 Using an Array in a Circular Way
            * To avoid moving objects once they're in Q, we defined three variables f, r, n:
                - f is the index of the cell of Q storing the front of the queue
                - r is an index of the cell of Q following the rear of the queue
                - n is the current number of elements in the queue
               
        5.2.4.2 Using the Modulo Operator to Implement a Circular Array
            * Algorithm:
           
                Algorithm size():
                    return n
                Algorithm empty():
                    return (n = 0)
                Algorithm front():
                    if empty() then
                        throw QueueEmpty exception
                    return Q[f]
                Algorithm dequeue():
                    if empty() then
                        throw QueueEmpty exception
                    f <- (f + 1) mod N
                    n = n - 1
                Algorithm enqueue(e):
                    if size() = N then
                        throw QueueFull exception
                    Q[r] <- e
                    r <- (r + 1) mod N
                    n = n + 1
                   
    5.2.5 Implementing a Queue with a Circularly Linked List
        * Implementation:
       
            typedef string Elem;
            class LinkedQueue {
            public:
                LinkedQueue();
                int size() const;
                bool empty() const;
                const Elem& front const throw(QueueEmpty);
                void enqueue(const Elem& e);
                void dequeue() throw(QueueEmpty);
            private:
                CircleList C;
                int n;
            };
           
            LinkedQueue::LinkedQueue()
                : C(), n(0) { }
               
            int LinkedQueue::size() const
                { return n; }
               
            bool LinkedQueue::empty() const
                { return n == 0; }
           
            const Elem& LinkedQueue::front() const throw(QueueEmpty) {
                if (empty())
                    throw QueueEmpty("front of empty queue");
                return C.front();
            }
           
            void LinkedQueue::enqueue(const Elem& e) {
                C.add(e);
                C.advance();
                n++;
            }
           
            void LinkedQueue::dequeue() throw(QueueEmpty) {
                if (empty())
                    throw QueueEmpty("dequeue of empty queue");
                C.remove();
                n--;
            }
           
5.3 Double Ended Queues
    * Also called a 'deque', pronounced "deck"
   
    5.3.1 The Deque Abstract Data Type
        * Methods:
       
            insertFront(e)
            insertBack(e)
            eraseFront()
            eraseBack()
            front()
            back()
            size()
            empty()
           
        5.3.1.1
            5.3.1.1.1 Example 5.5--example usage of a deque
           
    5.3.2 The STL Deque
        * To use:
       
            #include <deque>
            using std::deque;
            deque<string> myDeque;
           
        * Methods:
            size()
            empty()
            push_front(e)
            push_back(e)
            pop_front()
            pop_back()
            front()
            back()
           
    5.3.3 Implementing a Deque with a Doubly Linked List
        * Class structure:
       
            typedef string Elem;
            class LinkedDeque {
            public:
                LinkedDeque();
                int size() const;
                bool empty() const;
                const Elem& front() const throw(DequeEmpty);
                const Elem& back() const throw(DequeEmpty);
                void insertFront(const Elem& e);
                void insertBack(const Elem& e);
                void removeFront() throw(DequeEmpty);
                void removeBack() throw(DequeEmpty);
            private:
                DLinkedList D;
                int n;
            };
           
            void LinkedDeque::insertFront(const Elem& e) {
                D.addFront(e);
                n++;
            }
           
            void LinkedDeque:insertBack(const Elem& e) {
                D.addBack(e);
                n++;
            }
           
            void LinkedDeque::removeFront() throw(DequeEmpty) {
                if (empty())
                    throw DequeEmpty("removeFront of empty deque");
                D.removeFront();
                n--;
            }
           
            void LinkedDeque::removeBack() throw(DequeEmpty) {
                if (empty())
                    throw DequeEmpty("removeBack of empty deque");
                D.removeBack();
                n--;
            }
           
    5.3.4 Adapters and the Adapter Design Pattern
        * An adapter (or 'wrapper') is a data structure that translates one interface to another
       

Chapter 6: List and Iterator ADTs

6.1 Vectors
    * Suppose a collection S of n elements stored in a linear order--this is a list or sequence
    * Index is the zero indexed position, rank is the 1 indexed
    * A sequence that supports access to elements by index is a vector
   
    6.1.1 The Vector Abstract Data Type
        * Fundamental functions:
       
            at(i)
            set(i, e)
            insert(i, e)
            erase(i)
           
        6.1.1.1
            6.1.1.1.1 Example of vector operations
           
    6.1.2 A Simple Array-Based Implementation
        * Algorithms
       
            Algorithm insert(i, e):
                for j = n-1, n-2, ..., i do
                    A[j+1] <- A[j]
                A[i] <- e
                n <- n + 1
           
            Algorithm erase(i):
                for j = i+1, i+2, ..., n - 1 do
                    A[j-1] <- A[j]
                n <- n-1
       
        6.1.2.1 The Performance of a simple array-based implementation
            * size(), empty, at, set are all O(1), insert and erase are O(n)
           
    6.1.3 An Extendable Array Implementation
        * Major weakness is having to use a fixed size array for storage
        * Method to compensate for an overflow:
            1.  Allocate a new array B of capacity N
            2.  Copy A[i] to B[i], for i = 0,...,n-1
            3. Deallocate A and reassign A to point to the new array B
           
        * Known as an extendable array
        * A vector implementation using an extendable array:
       
            typedef int Elem;
            class ArrayVector {
            public:
                ArrayVector();
                int size() const;
                bool empty() const;
                Elem& operator[] (int i);
                Elem& at(int i) throw(IndexOutOfBounds);
                void erase(int i);
                void insert(int i, const Elem& e);
                void reserve(int N);
                // ... housekeeping functions omitted
            private:
                int capacity;
                int n;
                Elem* A;
            };
           
            ArrayVector::ArrayVector()
                : capacity(0), n(0), A(NULL) { }
               
            int ArrayVector::size() const
                { return n; }
               
            bool ArrayVector::empty() const
                { return size() == 0; }
               
            Elem& ArrayVector::operator[](int i)
                { return A[i]; }
               
            Elem& ArrayVector::at(int i) throw(IndexOutOfBounds) {
                if (i < 0 || i >= n)
                    throw IndexOutOfBounds("illegal index in function at()");
                return A[i];
            }
           
            void ArrayVector::erase(int i) {
                for (int j = i+1; j < n; j++)
                    A[j-1] = A[j];
                n--;
            }
           
            void ArrayVector::reserve(int N) {
                if (capcity >= N) return;
                Elem* B = new Elem[N];
                for (int j = 0; j < n; j++)
                    B[j] = A[j];
                if (A != NULL) delete [] A;
                A = B;
                capacity = N;
            }
           
            void ArrayVector::insert(int i, const Elem& e) {
                if (n >= capacity)
                    reserve(max(1, 2 * capacity));
                for (int j = n-1; j >= i; j--)
                    A[j+1] = A[j];
                A[i] = e;
                n++;
            }
           
    6.1.4 STL Vectors
        * To use:
       
            #include <vector>
            using std::vector;
           
            vector<int> myVector(100);
           
        * The vector's base type is the type of its individual elements
        * Elements are initialized to the base type's default value
        * Additional features of vectors over arrays:
            - item access via at() in addition to [], at() does range checking
            - Can be dynamically resized, new elements efficiently appended or removed from the end
            - When an STL vector of class objects is destroyed, it automatically calls the destructor for each of them
            - Number of useful functions that operate on entire vectors rather than individual elements
           
        * Principal member functions of the vector class:
            vector(n)
            size()
            empty()
            resize(n)
            reserve(n)
            operator[i]
            at(i)
            front()
            back()
            push_back()
            pop_back()
           
6.2 Lists
    * Given a list L implemented with a singly or doubly linked list, can be more efficient to use
        a 'node' than an index as a means of identifying where to access and update a list
   
    6.2.1 Node-Based Operations and Iterators
        * Let L be a singly or doubly linked list
        * We want to define functions for L that take nodes of the list as parameters and provide nodes as return types
        * Indexing requires searching incrementally
        * Using a node can make remove() and insert(v,e) operate in O(1) time rather than O(n)
        * To abstract the storage, we create a data type for the relative position or place of an element in a list
        * That's called a 'position', and since it moves around we'll call it an 'iterator'
       
        6.2.1.1 Containers and Positions
            * A container is a data structure that stores any collection of elements
            * A position is an ADT associated with a particular container, and supports the function element()
            * element() returns a reference to the element stored at that position
            * We can overload the dereference operator * so that given a position variable p, the associated element is *p
            * Positions are always defined relative to neighbors
           
        6.2.1.2 Iterators
            * Useful to be able to navigate through a container by advancing positions
            * An iterator is an extension of a position that supports the ability to access a node's element,
                and go forwards and possibly backwards through the container
            * Could define an operation next() for an iterator ADT, but overloading ++ is better
            * Assume each container has begin and end iterator values
           
    6.2.2 The List Abstract Data Type
        * Assume a list L and an iterator p with functions:
            begin()
            end()
            insertFront(e)
            insertBack(e)
            insert(p, e)
            eraseFront()
            eraseBack()
            erase(p)
           
        * Errors occur if: 
            p was never initialized or was set to a position in a different list
            p was previously removed from the list
            p results from an illegal operation such as attempting to perform ++p where p = L.end()
           
        6.2.2.1
            6.2.2.1.1 Example of list ops
           
        * Useful in a number of settings:
            - models several people playing a game of cards, by making each person's hand a list
            - text editor embeds the notion of positional insertion and removal, relative to a cursor
           
    6.2.3 Doubly Linked List Implementation
        * Implementing a list ADT in C++ can look like a doubly linked list
        * Node implementation:
       
            struct Node {
                Elem elem;
                Node* prev;
                Node* next;
            };
           
        * Iterator class:
       
            class Iterator {
            public:
                Elem& operator*();
                bool operator==(const Iterator& p) const;
                bool operator!=(const Iterator& p) const;
                Iterator& operator++();
                Iterator& operator--();
                friend class NodeList;
            private:
                Node* v;
                Iterator(Node* u);
            };
           
            NodeList::Iterator::Iterator(Node* u)
                { v = u; }
               
            Elem& NodeList::Iterator::operator*()
                { return v->elem; }
               
            bool NodeList::Iterator::operator==(const Iterator& p) const
                { return v == p.v; }
               
            bool NodeList::Iterator::operator!=(const Iterator& p) const
                { return v != p.v; }
               
            NodeList::Iterator& Nodelist::Iterator::operator++()
                { v = v->next(); return *this; }
               
            NodeList::Iterator& NodeList::Iterator::operator--()
                { v = v->prev; return *this; }
               
        * NodeList class:
       
            typedef int Elem;
            class NodeList {
            private:
                // insert Node declaration here
            public:
                // insert Iterator declaration here
            public:
                NodeList();
                int size() const;
                bool empty() const;
                Iterator begin() const;
                Iterator end() const;
                void insertFront(const Elem& e);
                void insertBack(const Elem& e);
                void insert(const Iterator& p, const Elem& e);
                void eraseFront();
                void eraseBack();
                void erase(const Iterator& p);
                // housekeeping functions omitted
            private:
                int n;
                Node* header;
                Node* trailer;
            };
           
            NodeList::NodeList() {
                n = 0;
                header = new Node;
                trailer = new Node;
                header->next = trailer;
                trailer->prev = header;
            }
           
            int NodeList size() const
                { return n; }
               
            bool NodeList::empty() const
                { return (n == 0); }
               
            NodeList::Iterator NodeList::begin() const
                { return Iterator(header->next); }
               
            NodeList::Iterator NodeList::end() const
                { return Iterator(trailer); }
               
            void NodeList::insert(const NodeList::Iterator& p, const Elem& e) {
                Node* w = p.v;
                Node* u = w->prev;
                Node* v = new Node;
                v->elem = e;
                v->next = w;
                w->prev = v;
                v->prev = u;
                u->next = v;
                n++;
            }
           
            void NodeList::insertFront(const Elem& e)
                { insert(begin(), e); }
               
            void NodeList::insertBack(const Elem& e)
                { insert(end(), e); }
               
            void NodeList::erase(const Iterator& p) {
                Node* v = p.v;
                Node* w = v->next;
                Node* u = v->prev;
                u->next = w;
                w->prev = u;
                delete v;
                n--;
            }
           
            void NodeList::eraseFront()
                { erase(begin()); }
           
            void NodeList::eraseBack()
                { erase(--end()); }
               
    6.2.4 STL Lists
        * To use:
       
            #include <list>
            using std::list;
            list<float> myList;
           
        * Methods:
            list(n)
            size()
            empty()
            front()
            back()
            push_front(e)
            push_back(e)
            pop_front()
            pop_back()
           
    6.2.5 STL Containers and Iterators
        * Available STL containers:
            vector, deque, list, stack, queue, priority_queue, set, multiset, map, multimap
           
        6.2.5.1 STL Iterators
            * Every container class has a special associated iterator class
            * Increment the iterator to move to the next element
           
        6.2.5.2 Using Iterators
            * Example of using an iterator to sum the elements of a vector:
           
                int vectorSum2(vector<int> V) {
                    typedef vector<int>::iterator Iterator;
                    int sum = 0;
                    for (Iterator p = V.begin(); p != V.end(); ++p)
                        sum += *p;
                    return sum;
                }
               
            * Some iterators let you do things like p+3 to get randomly accessed positions
           
        6.2.5.3 Const Iterators
            * You can use a read only iterator, called a const iterator, because many STL implementations will
                generate an error message if you attempt to use a regular iterator with a constant vector reference
            * If p is a const iterator, it is possible to read the value of *p, but not change it
            * const iterator type for our vector type is denoted
               
                vector<int>::const_iterator
               
            * Using a constant iterator to sum the elements of a vector:
           
                int vectorSum3(const vector<int>& V) {
                    typedef vector<int>::const_iterator ConstIterator;
                    int sum = 0;
                    for (ConstIterator p = V.begin(); p != V.end(); ++p)
                        sum += *p;
                    return sum;
                }
               
        6.2.5.4 STL Iterator Based Container Functions
            * vector(p, q)          create a new vector by iterating between p and q
            * assign(p, q)          delete the contents of V, assign new contents between p and q
            * insert(p, e)          insert a copy of e just prior to the position given by p
            * erase(p)              remove and destroy the element at p
            * erase(p, q)           iterate between p and q, removing and destroying elements
            * clear()               delete all elements of V
           
        6.2.5.5 STL Vectors and Algorithms
            * To use, #include <algorithm>
            * Letting p and q be iterators of the same base type, and e is an object of the base type
            * Ops apply to the range [p,q):
                sort(p, q)              sort in ascending order, using < as comparator
                random_shuffle(p,q)     rearrange the elements in random order
                reverse(p,q)            reverse the elements in range from p to q
                find(p,q,e)             return an iterator to the first thing equal to e, else q
                min_element(p,q)        return an iterator to the min element from p to q
                max_element(p,q)        return an iterator to the max element from p to q
                for_each(p, q, f)       apply function f to the elements from p to q
               
        6.2.5.6 An Illustrative Example
            * Short example program for functionality of STL vector:
           
                #include <cstdlib>
                #include <iostream>
                #include <vector>
                #include <algorithm>
               
                using namespace std;
               
                int main() {
                    int a[] = { 17, 12, 33, 15, 62, 45 };
                    vector<int> v(a, a + 6);
                    cout << v.size() << endl;                   // outputs 6
                    v.pop back();
                    cout << v.size() << endl;                   // outputs 5
                    v.push back(19);
                    cout << v.front() << " " << v.back() << endl;
                    sort(v.begin(), v.begin() + 4);
                    v.erase(v.end() - 4, v.end - 2);
                    cout << v.size() << endl;
                   
                    char b[] = {'b', 'r', 'a', 'v', 'o'};
                    vector<char> w(b, b+5);
                    random_shuffle(w.begin(), w.end());
                    w.insert(w.begin(), 's');
                   
                    for (vector<char>::iterator p = w.begin; p != w.end(); ++p)
                        cout << *p << " ";
                    cout << endl;
                    return EXIT_SUCCESS;
                }
               
6.3 Sequences
    6.3.1 The Sequence ADT
        * It's an ADT that supports all the functions of the list ADT, but also gives access by index
        * Interface is that of the list ADT plus atIndex(i) and indexOf(p)
       
    6.3.2 Implementing a Sequence with a Doubly Linked List
        * A sequence based on a doubly linked list will make all ops run in O(1), and atIndex and indexOf less efficiently
        * definition for class NodeSequence:
       
            class NodeSequence : public NodeList {
            public:
                Iterator atIndex(int i) const;
                int indexOf(const Iterator& p) const;
            };
           
            NodeSequence::Iterator NodeSequence::atIndex(int i) const {
                Iterator p = begin();
                for (int j = 0; j < i; j++) ++p;
                return p;
            }
           
            int NodeSequence::indexOf(const Iterator& p) const {
                Iterator q = begin();
                int j = 0;
                while (q != p) {
                    ++q; ++j;
                }
                return j;
            }
           
    6.3.3 Implementing a Sequence with an Array
        * Store the ordering separately from the storage
       
6.4 Case Study: Bubble-Sort on a Sequence
    6.4.1 The Bubble-Sort Algorithm
        * Consider a sequence of n elements such that any two can be compared according to an order relation
        * The sorting problem is to reorder the sequence so that the elements are in nondecreasing order
        * Bubble sort works by performing a series of passes over the sequence
        * In each pass, the elements are scanned by increasing rank, from rank 0 to the end
        * At each position in a pass, an element is compared with its neighbor, and if they're ordered wrong, swapped
        * Sequence is sorted by completing n such passes
        * The algorithm has the following properties:
            - In the first pass, once the largest element is swapped, it keeps on being swapped until it moves to the end
            - In the second pass, same happens for second largest
            - In general, at the end of the ith pass, the rightmost i elements are in final position
           
    6.4.2 A Sequence-Based Analysis of Bubble-Sort
        * Assume the implementation of the sequence is such that access and swaps are O(1)
        * Thus the running time of the ith pass is O(n - i + 1)
        * Overall running time of the bubble sort is:
       
               /  n         \
            O |   E  (n-i+1) |
               \ i=1        /
              
        * Which converts to n + (n-1) + ... + 2 + 1, which converts to (n(n+1)) / 2, which is O(n^2)
        * Example of bubble sort based on indices:
       
            void bubbleSort1(Sequence& S) {
                int n = S.size();
                for (int i = 0; i < n; i++) {
                    for (int j = 1; j < n-i; j++) {
                        Sequence::Iterator prec = S.atIndex(j-1);
                        Sequence::Iterator succ = S.atIndex(j);
                        if (*prec > *succ) {
                            int tmp = *prec; *prec = *succ; *succ = tmp;
                        }
                    }
                }
            }
           
        * Second implementation:
       
            void bubbleSort2(Sequence& S) {
                int n = S.size();
                for (int i = 0; i < n; i++) {
                    Sequence::Iterator prec = S.begin();
                    for (int j = 1; j < n-i; j++) {
                        Sequence::Iterator succ = prec;
                        ++succ;
                        if (*prec > *succ) {
                            int tmp = *prec; *prec = *succ; *succ = tmp;
                        }
                        ++prec;
                    }
                }
            }
           
        * In general, bubble sort is easy to implement but too inefficient compared to sorting in O(n log n) time
       
                   
           
Chapter 7: Trees
    7.1 General Trees
        * Trees are a nonlinear data structure
        * Relationships in a tree are hierarchical, parent-child type
       
    7.1.1 Tree Definitions and Properties
        * A "tree" is an ADT that stores elements hierarchically
        * Every element in a tree has a "parent" element and zero or more "child" elements
        * Top element is the "root" of the tree, drawn at the top
       
        7.1.1.1 Formal Tree Definition
            * Formally, tree T is a set of 'nodes' storing elements in a 'parent-child' relationship with these properties:
                - If T is nonempty, it has a special node, called the 'root' of T, that has no parent
                - Each node v of T different from the root has a unique parent node w
                - every node with parent w is a 'child' of w
               
        7.1.1.2 Other Node Relationships
            * Two nodes that are children of the same parent are 'siblings'
            * A node v is 'external' if v has no children
            * A node v is 'internal' if it has one or more children
            * External nodes are also known as 'leaves'
           
            7.1.1.2.1 Example 7.1 -- Filesystem Example
           
        7.1.1.3 Edges and Paths in Trees
            * An 'edge' of tree T is a pair of nodes (u,v) such that u is the parent of v or vice versa
            * A 'path' of T is a sequence of nodes such that any two consecutive nodes in the sequence form an edge
           
            7.1.1.3.1 Example 7.2 -- inheritance patterns in c++ classes
           
        7.1.1.4 Ordered Trees
            * A tree is 'ordered' if there is a linear ordering defined for the children of each node:
                first child, second child, third child, etc.
           
            7.1.1.4.1 Example 7.3 -- example of document structure in a book as ordered
           
    7.1.2 Tree Functions
        * The tree ADT stores elements at the nodes of the tree, which have no public access
        * Each node is associated with a position object, which gives public access
        * The public interfaces of the tree ADT use p as the notation, not v
        * We overload * to give access to the element represented by p
        * We define a 'position list' as a list whose elements are tree positions
        * Given a position p of tree T, we define the following:
            p.parent()
            p.children()
            p.isRoot()
            p.isExternal()
           
        * The tree itself has the following functions:
            size()
            empty()
            root()
            positions()
           
    7.1.3 A C++ Tree Interface
        * Informal interface:
       
            template <typename E>
            class Position<E> {
            public:
                E& operator*();
                Position parent() const;
                PositionList children() const;
                bool isRoot() const;
                bool isExternal() const;
            };
           
            template <typename E>
            class Tree<E> {
            public:
                class Position;
                class PositionList;
            public:
                int size() const;
                bool empty() const;
                Position root() const;
                PositionList positions() const;
            };
           
    7.1.4 A Linked Structure for General Trees
        * Represent each node of T as a position object p with the following fields:
            - reference to the node's element
            - link to the node's parent
            - a collection to store links to the node's children
           
7.2 Tree Traversal Algorithms
    7.2.1 Depth and Height
        * Let p be a node of tree T: the 'depth' of p is the number of ancestors of p excluding p itself
        * The depth of p's node can be recursively defined as:
            - If p is the root, the depth of p is 0
            - Otherwise, the depth of p is one plus the depth of the parent of p
        * Algorithm for computing depth:
           
            Algorithm depth(T, p):
                if p.isRoot() then
                    return 0
                else
                    return 1 + depth(T, p.parent())
                   
        * C++ implementation of that:
           
            int depth(const Tree& T, const Position& p) {
                if (p.isRoot())
                    return 0;
                else
                    return 1 + depth(T, p.parent());
            }
           
        * That performs in O(d sub p) time, because it's a constant time for each recursive step of p's depth
        * The 'height' of a node p can also be defined recursively:
            - If p is external, the height of p is 0
            - Otherwise the height of p is one plus the maximum height of a child of p
        * The height of a tree T is the height of the root of T, equal to the maximum depth of its external nodes
        * Algorithm for finding height(T):
       
            Algorithm height1(T):
                h = 0
                for each p in T.positions() do
                    if p.isExternal() then
                        h = max(h, depth(T, p))
                return h
               
        * C++ implementation of that, assuming that Iterator is the iterator class for PositionList
       
            int height1(const Tree& T) {
                int h = 0;
                PositionList nodes = T.positions();
                for (Iterator q = nodes.begin(); q != nodes.end(); ++q) {
                    if (q->isExternal())
                        h = max(h, depth(T, *q);
                }
                return h;
            }
           
        * That runs in O(n^2), because it's scanning each external node in T for depth
        * Second algorithm for more efficiently finding height:
       
            Algorithm height2(T, p):
                if p.isExternal() then
                    return 0
                else
                    h = 0
                    for each q in p.children() do
                        h = max(h, height2(T, q))
                    return 1 + h
           
        * In C++:
       
            int height2(const Tree& T, const Position& p) {
                if (p.isExternal()) return 0;
                int h = 0;
                PositionList ch = p.children();
                for (Iterator q = ch.begin(); q != ch.end(); ++q)
                    h = max(h, height2(T, *q));
                return 1 + h;
            }
           
        * More efficient than height1, runs recursively
        * Proposition 7.5: Let T be a tree with n nodes, and let cp denote the number of children of a node p of T
            then sum-p(cp) = n-1
        * Each node of T with the exception of the root, is a child node of another node, and contributes one to the sum
       
    7.2.2 Preorder Traversal
        * A traversal is a systematic way of accessing or visiting all nodes of T
        * A preorder traversal of T:
            - root of T is visited first
            - subtrees rooted at T.root's children are traversed recursively
            - If T is ordered, the subtrees are traversed in order of the children
        * Algorithm for preorder traversal:
       
            Algorithm preorder(T, p):
                perform the "visit" action for node p
                for each child q of p do
                    recursively traverse the subtree rooted at q by calling preorder(T, q)
                   
        7.2.2.1
            7.2.2.1.1 Example 7.6 -- traversing a tree
                * Method for a preorder traversal print of a tree:
               
                    void preorderPrint(const Tree& T, const Position& p) {
                        cout << *p;
                        PositionList ch = p.children();
                        for (Iterator q = ch.begin(); q != ch.end(); ++q) {
                            cout << " ";
                            preorderPrint(T, *q);
                        }
                    }
                   
                * Variation of preorder is the parenthetic string representation P(T) of tree T:
                    - If T.size() = 1, P(T) = *p
                    - Else, P(T) = *p + "("+P(T1)+P(T2)+...+P(Tk)+")",
               
                * Implementation of parenPrint:
               
                    void preorderPrint(const Tree& T, const Position& p) {
                        cout << *p;
                        if (!p.isExternal()) {
                            PositionList ch = p.children();
                            cout << "( ";
                            for (Iterator q = ch.begin(); q != ch.end(); ++q) {
                                if (q != ch.begin()) cout << " ";
                                parenPrint(T, *q);
                            }
                            cout << " ";
                        }
                    }
                   
    7.2.3 Postorder Traversal
        * Opposite of preorder, since it recursively traverses the subtrees
            rooted at the children of the root first, then visits the root
        * Algorithm for performing postorder traversal:
           
            Algorithm postorder(T, p):
                for each child q of p do
                    recursively traverse the subtree rooted at q by calling postorder(T, q)
                perform the "visit" action for node p
       
        * C++ function for postorder traversal:
       
            void postorderPrint(const Tree& T, const Position& p) {
                PositionList ch = p.children();
                for (Iterator q = ch.begin(); q != ch.end(); ++q) {
                    postorderPrint(T, *q);
                    cout << " ";
                }
                cout << *p;
            }
           
        * Most useful when computing a property for p involves already having computed it for p.children
       
        7.2.3.1
            7.2.3.1.1 Example 7.7
                * A filesystem tree T, where external nodes represent files and internal nodes represent directories
                * If we want to compute the disk space used by a directory, which is recurisvely the sum of:   
                    - the size of the directory itself
                    - the sizes of the files in the directory
                    - the space used by the children directories
                   
                * Example code:
               
                    int diskSpace(const Tree& T, const Position& p) {
                        int s = size(p);
                        if (!p.isExternal()) {
                            PositionList ch = p.children();
                            for (Iterator q = ch.begin(); q != ch.end(); ++q)
                                s += diskSpace(T, *q);
                            cout << name(p) << ": " << s << endl;
                        }
                        return s;
                    }
                   
        7.2.3.2 Other Kinds of Traversals
            * Preorder is good for performing an action for a node and then its children
            * Postorder is good for performing an action on descendants of a node and then the node
            * A breadth-first traversal would visit all the nodes at depth d before going on to depth d+1
            * Binary trees support "inorder traversal" as well
           
7.3 Binary Trees
    * A binary tree is an ordered tree in which every node has at most two children
        - Every node has at most two children
        - Each child node is labeled as being either a left child or a right child
        - A left child precedes a right child in the ordering of children of a node
    * The subtree rooted at a left or right child of an internal node is called the node's left subtree or right subtree
    * A binary tree is 'proper' or 'full' if each node has zero or two children, otherwise it is 'improper'
   
    7.3.1
        7.3.1.1
            7.3.1.1.1 Example 7.8
                * Decision trees are binary trees where each node is associated with a question, and children are yes/no
            7.3.1.1.2 Example 7.9
                * An arithmetic expression can be represented by a tree whose external
                    nodes are associated with variables or constants, and whose internal nodes are operators
                    - If a node is external, then its value is that of its variable or constant
                    - If a node is internal then its value is defined by applying its operation to the values of its children
                   
    7.3.2
        7.3.2.1 A Recurisve Binary Tree Definition
            * A binary tree can be defined recursively as empty or consists of:
                - A node r called the root of T, and storing an element
                - A binary tree called the left subtree of T
                - A binary tree called the right subtree of T
               
    7.3.3 The Binary Tree ADT
        * Each node stores an element, is associated with a position object, * is overloaded to let *p give p.elem()
        * Each Position supports the following operations:
            p.left()
            p.right()
            p.parent()
            p.isRoot()
            p.isExternal()
        * The tree itself supports:
            size()
            empty()
            root()
            positions()
           
    7.3.4 A C++ Binary Tree Interface
        * Informal interface for position and tree:
       
            template <typename E>
            class Position<E> {
            public:
                E& operator*();
                Position left() const;
                Position right() const;
                Position parent() const;
                bool isRoot() const;
                bool isExternal() const;
            };
           
            template <typename E>
            class BinaryTree<E> {
            public:
                class Position;
                class PositionList;
            public:
                int size() const;
                bool empty() const;
                Position root() const;
                PositionList positions() const;
            };
           
    7.3.5 Properties of Binary Trees
        * Set of all nodes of T at the depth d is the "level" d of T
        * Level 0 has one node, level 1 has at most two, 2 has at most 4, etc
        * Level d has at most 2^d nodes
        * Maximum nodes grows exponentially as you descend the tree
        * Proposition 7.10:
            Let T be a nonempty binary tree
            Let n, nE, nI, and h denote the number of nodes, external nodes, internal nodes, and height of T
            T then has the following properties:
           
                1.  h + 1 <= n <= 2^(h+1) - 1
                2.  1 <= nE <= 2^h
                3.  h <= nI <= 2^h - 1
                4.  log(n+1) - 1 <= h <= n-1
               
            If T is proper, it also has the following properties:
           
                1.  2h + 1 <= n <= 2^(h+1) - 1
                2.  h + 1 <= nE <= 2^h
                3.  h <= nI <= 2^h - 1
                4.  log(n+1) - 1 <= h <= (n-1)/2
               
        * Proposition 7.11: In a nonemtpy binary tree T, the number of external nodes is one more than the number of internal
       
    7.3.6 A Linked Structure for Binary Trees
        * Implementation of T as a linked structure, called LinkedBinaryTree
        * Each node v of T is a node object
        * For simplicity, we assume the tree is proper
        * Structure for a Node:
       
            struct Node {
                Elem elt;
                Node* par;
                Node* left;
                Node* right;
                Node() : elt(), par(NULL), left(NULL), right(NULL) { }
            };
           
        * Position class:
       
            class Position {
            private:
                Node* v;
            public:
                Position(Node* _v = NULL) : v(_v) { }
                Elem& operator*()
                    { return v->elt; }
                Position left() const
                    { return Position(v->left); }
                Position right() const
                    { return Position(v->right); }
                Position parent() const
                    { return Position(v->par); }
                bool isRoot() const
                    { return v->par == NULL; }
                bool isExternal() const
                    { return v->left == NULL && v->right == NULL; }
                friend class LinkedBinaryTree;
            };
            typedef std::list<Position> PositionList;
           
        * LinkedBinaryTree:
       
            typedef int Elem;
            class LinkedBinaryTree {
            protected:
                // insert Node declaration here
            public:
                // insert Position declaration here
            public:
                LinkedBinaryTree();
                int size() const;
                bool empty() const;
                Position root() const;
                PositionList positions() const;
                void addRoot();
                void ExpandExternal(const Position& p);
                Position removeAboveExternal(const Position& p);
                // housekeeping functions omitted
            protected:
                void preorder(Node* v, PositionList& pl) const;
            private:
                Node* _root;
                int n;
            };
           
            LinkedBinaryTree::LinkedBinaryTree()
                : _root(NULL), n(0) { }
            int LinkedBinaryTree::size() const
                { return n; }
            bool LinkedBinaryTree::empty() const
                { return size() == 0; }
            LinkedBinaryTree::Position LinkedBinaryTree::root() const
                { return Position(_root); }
            void LinkedBinaryTree::addRoot()
                { _root = new Node; n = 1; }
               
        7.3.6.1 Binary Tree Update Functions
            * expandExternal(p): transform p from an external node to an internal node by creating two
                new external nodes and making them the left and right children of p, respectively
            * removeAboveExternal(p): remove the external node p together with its parent q, replacing q
                with the sibling of p
               
            * Function definitions:
           
                void LinkedBinaryTree::ExpandExternal(const Position& p) {
                    Node * v = p.v;
                    v->left = new Node;
                    v->left->par = v;
                    v->right = new Node;
                    v->right->par = v;
                    n += 2;
                }
               
                LinkedBinaryTree::Position LinkedBinaryTree::removeAboveExternal(const Position& p) {
                    Node* w = p.v;
                    Node* v = w->par;
                    Node* sib = (w == v->left ? v->right : v->left);
                    if (v == root) {
                        _root = sib;
                        sib->par = NULL;
                    }
                    else {
                        Node* gpar = v->par;
                        if (v == gpar->left) gpar->left = sib;
                        else gpar->right = sib;
                        sib->par = gpar;
                    }
                    delete w; delete v;
                    n -= 2;
                    return Position(sib);
                }
               
                LinkedBinaryTree::PositionList LinkedBinaryTree::positions() const {
                    PositionList pl;
                    preorder(_root, pl);
                    return PositionList(pl);
                }
               
                void LinkedBinaryTree::preorder(Node* v, PositionList& pl) const {
                    pl.push back(Position(v));
                    if (v->left != NULL)
                        preorder(v->left, pl);
                    if (v->right != NULL)
                        preorder(v->right, pl);
                }
               
        7.3.6.2 Performance of the LinkedBinaryTree Implementation
            * left, right, parent, isRoot, isExternal are all O(1)
            * by accessing the member variable n, size and empty are also O(1)
            * accessor function root is O(1)
            * Update functions expandExternal and removeAboveExternal visit a constant number of nodes, so are O(1)
            * Positions does a preorder traversal, which is O(n)
           
    7.3.7 A Vector-based Structure for Binary Trees
        * Structure for representing T is based on a way of numbering the nodes of T
        * For every node v of T, let f(v) be the integer defined as follows:
            - If v is the root of T, f(v) = 1
            - If v is the left child of node u, then f(v) = 2f(u)
            - If v is the right child of node u, then f(v) = 2f(u) + 1
        * Function f() is a level numbering of the nodes in T, numbers left to right possibly skipping some
        * Can be implemented as a vector S such that node v of T is associated with the element of S at rank f(v)
        * Typically built using an extendable array
        * root, parent, left, right, sibling, isExternal and isRoot are all arithmetic on f(v) for each v
       
    7.3.8 Traversals of a Binary Tree
        7.3.8.1 Preorder Traversal of a Binary Tree
            * Algorithm binaryPreorder:
           
                Algorithm binaryPreorder(T, p):
                    perform the "visit" action for node p
                    if p is an internal node then
                        binaryPreorder(T, p.left())
                        binaryPreorder(T, p.right())
                       
        7.3.8.2 Postorder traversal of a binary tree
            * Algorithm binaryPostorder(T, p):
                if p is an internal node then
                    binaryPostorder(T, p.left())
                    binaryPostorder(T, p.right())
                perform the "visit" action for the node p
               
        7.3.8.3 Evaluating an Arithmetic Expression
            * Postorder traversal can solve the expression evaluation problem
            * Given an arithmetic-expression tree, compute the value of the arithmetic expression represented by the tree
            * Algorithm evaluateExpression:
           
                Algorithm evaluateExpression(T, p):
                    if p is an internal node then
                        x <- evaluateExpression(T, p.left())
                        y <- evaluateExpression(T, p.right())
                        Let # be the operator assocated with p
                        return x # y
                    else
                        return the value stored at p
                       
        7.3.8.4 Inorder Traversal of a Binary Tree
            * Algorithm inorder:
           
                Algorithm inorder(T, p):
                    if p is an internal node then
                        inorder(T, p.left())                { recursively traverse left subtree }
                    perform the "visit" action for node p
                    if p is an internal node then
                        inorder(T, p.right())               { recursively traverse right subtree }
                       
        7.3.8.5 Binary Search Trees
            * Let S be a set whose elements have an order relation, like a set of integers
            * A binary search tree for S is a proper binary tree T such that:
                - each internal node p of T stores an element of S, denoted with x(p)
                - for each internal node p of T, the elements stored in the left subtree of p are
                    less than or equal to x(p) and the elements in the right are greater than or equal to x(p)
                - the external nodes of T do not store any element
            * We can use a binary search tree T to locate an element with a certain value x by traversing down the tree T
            * At each node we compare the value of the current node to x
            * If x is smaller, we continue into the left subtree, if larger, the right subtree, if equal, terminate success
            * If we reach an empty node, terminate failure
           
        7.3.8.6 Using Inorder Traversal for Tree Drawing
            * inorder traversal can create a drawing of a binary tree, by assigning xy coords to a node p using these rules:
                - x(p) is the number of nodes visited before p in the inorder traversal of T
                - y(p) is the depth of p in T
               
        7.3.8.7 The Euler Tour Traversal of a Binary Tree
            * If we relax the rule that each node be visited exactly once, we can have a Euler tour traversal
            * Allows for more general kinds of algorithms to be expressed easily
            * Can be defined as a "walk" around T where we start from the root to its left child,
                viewing the edges of T as "walls" that we always keep to our left
            * Each node is encountered three times:
                - On the left (before the euler tour of p's left subtree)
                - From below (between the euler tours of p's two subtrees)
                - On the right (after the euler tour of p's right subtree)
               
            * Pseudocode for a Euler tour of the subtree at node p:
           
                Algorith eulerTour(T, p):
                    perform the action for visiting node p on the left
                    if p is an internal node then
                        recursively tour the left subtree of p by calling eulerTour(T, p.left())
                    perform the action for visiting node p from below
                    if p is an internal node then
                        recursively tour the right subtree of p by calling eulerTour(T, p.right())
                    perform the action for visiting node p on the right
                   
            * Typically, if a node visit is O(1), a euler tour is O(n) for an n node tree
            * Pseudocode for printing the arithmetic expression with the subtree of an arithmetic-expression tree T rooted at p:
               
                Algorithm printExpression(T, p):
                    if p.isExternal() then
                        print the value stored at p
                    else
                        print "("
                        printExpression(T, p.left())
                        print the operator stored at p
                        printExpression(T, p.right())
                        print ")"
                       
    7.3.9 The Template Function Pattern
        * A design pattern describing a generic computation mechanism that can be specialized for a particular application
            by redefining certain steps
           
        7.3.9.1 Euler Tour with the Template Function Pattern
            * Example:
           
                Algorithm templateEulerTour(T, p):
                    r <- initResult()
                    if p.isExternal() then
                        r.finalResult <- visitExternal(T, p, r)
                    else
                        visitLeft(T, p, r)
                        r.leftResult <- templateEulerTour(T, p.left())
                        visitBelow(T, p, r)
                        r.rightResult <- templateEulerTour(T, p.right())
                        visitRight(T, p, r)
                    return returnResult(r)
           
        7.3.9.2 Template Function Examples
        7.3.9.3 C++ Implementation
        * EulerTour class:
       
            template <typename E, typename R>                       // element and result types
            class EulerTour {
            protected:
                struct Result {                                     // stores tour results
                    R leftResult;                                   // result from left subtree
                    R rightResult;                                  // result from right subtree
                    R finalResult;                                  // combined result
                };
                typedef BinaryTree<E> BinaryTree;                   // the tree
                typedef typename BinaryTree::Position Position;     // a position in the tree
            protected:
                const BinaryTree* tree;                             // pointer to the tree
            public:
                void initialize(const BinaryTree& T)
                    { tree = &T; }
            protected:
                int eulerTour(const Position& p) const;             // perform the tour functions given by subclasses
                virtual void visitExternal(const Position& p, Result& r) const { }
                virtual void visitLeft(const Position& p, Result& r) const { }
                virtual void visitBelow(const Position& p, Result& r) const { }
                virtual void visitRight(const Position& p, Result& r) const { }
                Result initResult() const { return Result(); }
                int result(const Result& r) const { return r.finalResult; }
            };
           
        * Principal member function eulerTour:
       
            template<typename E, typename R>
            int EulerTour<E, R>::eulerTour(Const Position& p) const {
                Result r = initResult();
                if (p.isExternal()) {
                    visitExternal(p, r);
                }
                else {
                    visitLeft(p, r);
                    r.leftResult = eulerTour(p.left());
                    visitBelow(p, r);
                    r.rightResult = eulerTour(p.right());
                    visitRight(p, r);
                }
                return result(r);
            }
           
        * Implementation of EvaluateExpressionTour that subclasses EulerTour:
       
            template <typename E, typename R>
            class EvaluateExpressionTour : public EulerTour<E, R> {
            protected:                                                      // shortcut type names:
                typedef typename EulerTour<E, R>::BinaryTree BinaryTree;
                typedef typename EulerTour<E, R>::Position Position;
                typedef typename EulerTour<E, R>::Result Result;
            public:
                void execute(const BinaryTree& T) {
                    initialize(T);
                    std::cout << "The value is: " << eulerTour(T.root()) << "\n";
                }
            protected:
                virtual void visitExternal(const Position& p, Result& r) const      // leaf: return value
                    { r.finalResult = (*p).value(); }
                virtual void visitRight(vonst Position& p, Result& r) const
                    { r.finalResult = (*p).operation(r.leftResult, r.rightResult); }    // internal: do operation
            };
           
        * Second example, that prints the expression:
       
            template <typename E, typename R>
            class PrintExpressionTour : public EulerTour<E, R> {
            protected: // ... same type name shortcuts
            public:
                void execute(const BinaryTree& T) {
                    initialize(T);
                    cout << "Expression: "; eulerTour(T.root()); cout << endl;
                }
            protected:
                virtual void visitExternal(const Position& p, Result& r)
                    { (*p).print(); }
                   
                virtual void visitLeft(const Position& p, Result& r) const
                    { cout << "("; }
                   
                virtual void visitBelow(const Position& p, Result& r) const
                    { (*p).print(); }
                   
                virtual void visitRight(const Position& p, Result& r) const
                    { cout << ")"; }
            };
           
    7.3.10 Representing General Trees with Binary Trees
        * To transform a general tree T into a binary tree T':
            - For each node u of T, there is an internal node u' of T' associated with u
            - If u is an external node of T and does not have a sibling immediately following it,
                the children of u' in T' are external nodes
            - If u is an internal node of T and v is the first child of u in T, then v' is the left child of u' in T'
            - If node v has a sibling w immediately following it, then w' is the right child of v' in T'
           
Chapter 8: Heaps and Priority Queues
    * Priority queue stores a collection of prioritized elements, supports arbitrary insertion,
        supports removal of elements in order of priority
    * No external notion of "position", removal is all priority based
   
    8.1.1 Keys, Priorities, and Total Order Relations
        * A key is an an object assigned to an element as a specific attribute for that element,
            and that can be used to identify, rank, or weigh that element
        * Keys in this sense are not necessarily unique, and may change
       
        8.1.1.1 Comparing Keys with Total Orders
            * A priority queue needs a comparison rule that never contradicts itself
            * A comparison rule, <=, is robust if it defines a 'total order' relation, for every set of keys, that satisfies:
                - Reflexive property: k <= k
                - Antisymmetric property: if k1 <= k2 and k2 <= k1, then k1 = k2
                - Transitive property: if k1 <= k2 and k2 <= k3, then k1 <= k3
            * Fundamental functions of a priority queue P are:
                - insert(e)
                - min()
                - removeMin()
               
            8.1.1.1.1 Example 8.1 -- priority queue of standby passengers for an airline flight
           
    8.1.2 Comparators
        * How to implement the total order relation?  There are multiple approaches.
        * Good way is to design the priority queue as a templated class with an abstract type argument
        * A concrete example for a Point2D class:
       
            bool operator<(const Point2D& p, const Point2D& q) {
                if (p.getX() == q.getX())   return p.getY() < q.getY();
                else                        return p.getX() < q.getX();
            }
           
        8.1.2.1
            8.1.2.1.1 Example 8.2 -- ordering strings by alphabetic vs numeric
            8.1.2.1.2 Example 8.3
                - Most common way to achieve independence of element type and comparison method is "composition",
                    where you have each entry be a pair, (e, k), where e is the element and k is the priority info
                - In that case, each key object defines its own comparison function, and changing the key class changes order
                - The method we're using here si simpler, based on defining a 'comparator' object that sorts two objects
       
        8.1.2.2 Defining and Using a Comparator Class
            * Suppose a class Point2D
            * Two comparators:
           
                class LeftRight {
                public:
                    bool operator() (const Point2D& p, const Point2D& q) const
                        { return p.getX() < q.getX(); }
                };
                class BottomTop {
                public:
                    bool operator() (const Point2D& p, const Point2D& q) const
                        { return p.getY() < q.getY(); }
                };
               
            * A generic function that prints the small of two elements given a comparator for those elements:
           
                template <typename E, typename C>
                void printSmaller(const E& p, const E& q, const C& isLess) {
                    cout << (isLess(p, q) ? p : q) << endl;
                }
               
            * Actual usage:
           
                Point2D p(1.3, 5.7), q(2.5, 0.6);
                LeftRight leftRight;
                BottomTop bottomTop;
                printSmaller(p, q, leftRight);
                printSmaller(p, q, bottomTop);
               
    8.1.3 The Priority Queue ADT
        * A priority queue P supports:
            size()
            empty()
            insert(e)
            min()
            removeMin()
           
        8.1.3.1
            8.1.3.1.1 Example 8.4 -- operations examples for a priority queue
           
    8.1.4 A C++ Priority Queue Interface
        * Informal interface:
       
            template <typename E, typename C>
            class PriorityQueue {
            public:
                int size() const;
                bool isEmpty() const;
                void insert(const E& e);
                const E& min() const throw(QueueEmpty);
                void removeMin() throw(QueueEmpty);
            };
           
    8.1.5 Sorting with a Priority Queue
        * For a collection L of n elements that can be compared according to a total order relation, we can sort them
            using a priority queue Q called PriorityQueueSort
        * Process consists of two phases:
            1.  Put the elements of L into an initially empty priority queue P via n insert() operations
            2.  Extract the elements from P back into L in nondecreasing order via min and removeMin
        * Example pseudo code for that:
       
            Algorithm PriorityQueueSort(L, P):
                Input:  An STL list L of n elements, a priority queue P that compares elements
                Output: The sorted list L
               
                while !L.empty() do
                    e <- L.front
                    L.pop front()
                    P.insert(e)
                while !P.empty() do
                    e <- P.min()
                    P.removeMin()
                    L.push_back(e)
                   
        * Run time of the algorithm is determined by the run times of insert, min and removeMin
        * Not really a sorting algorithm, more of a sorting scheme
       
    8.1.6 The STL priority_queue Class
        * To use:
       
            #include <queue>
            using namespace std;
            priority_queue<int> p1;
            priority_queue<Point2D, vector<Point2D>, LeftRight> p2;
           
        * Templated with three parameters: base type of the elements, underlying STL container the queue is stored in,
            and the comparator object--only the first argument is required
        * Second arg defaults to stl vector, third arg defaults to C++ < operator
        * In general, a comparator is a class that overrides the () operator to define a boolean function implementing less than
        * Principal member functions of the STL priority queue:
       
            size()
            empty()
            push(e)
            top()
            pop()
           
8.2 Implementing a Priority Queue with a List
    8.2.1
        8.2.1.1 Implementation with an Unsorted List
            * Implementing with an unsorted doubly linked list L
            * Adding elements to the back of the list with push_back(e) is O(1)
            * To perform min or removeMin takes O(n) time
        8.2.1.2 Implementation with a Sorted List
            * Stores elements sorted by their key values
            * min and removeMin are O(1)
            * insert is O(n)
           
    8.2.2 A C++ Priority Queue Implementation using a List
        * Class def for a priority queue based on an STL list:
       
            template <typename E, typename C>
            class ListPriorityQueue {
            public:
                int size() const;
                bool empty() const;
                void insert(const E& e);
                const E& min() const;
                void removeMin();
            private:
                std::list<E> L;
                C isLess;
            };
       
            template <typename E, typename C>
            int ListPriorityQueue<E,C>::size() const
                { return L.size(); }
           
            template <typename E, typename C>
            bool ListPriorityQueue<E,C>::empty() const
                { return L.empty(); }
               
            template <typename E, typename C>
            void ListPriorityQueue<E,C>::insert(const E& e) {
                typename std::list<E>::iterator p;
                p = L.begin();
                while (p != L.end() && !isLess(e, *p)) ++p;
                L.insert(p, e);
            }
           
            template <typename E, typename C>
            const E& ListPriorityQueue<E,C>::min() const
                { return L.front(); }
           
            template <typename E, typename C>
            void ListPriorityQueue<E,C>::removeMin()
                { L.pop_front(); }
               
    8.2.3 Selection-Sort and Insertion-Sort
        8.2.3.1 Selection-Sort
            * Implementing a priority queue P with an unsorted list will start up in O(n) time, and min/removeMin are O(Pn)
            * The bottleneck is the repeated "selection" of the minimum element from an unsorted list in teh second phase
            * First removeMin takes O(n) time, second is O(n-1)
            * Total time for the second phase is O(n + (n-1) + ... + 2 + 1) = O(n^2) time
           
        8.2.3.2 Insertion Sort
            * Implementing P with a sorted list makes the second phase's run time O(n), since min/removeMin is O(1)
            * Makes the first phase the bottleneck, since insert takes time proportional to size of P
            * Total time for the first phase is O(1 + 2 + ... + (n-1) + n) = O(n^2) time as well
           
8.3 Heaps
    * An efficient realizaation of a priority queue uses a heap
    * Heaps let you do both insertions and removals in logarithmic time
    * Abandons the idea of a list, stores elements and keys in a binary tree
   
    8.3.1 The Heap
        * A heap is a binary tree B that stores a collection of elements with their associated keys at its nodes
        * Satisfies two additional properties:
            - A relational property, defined in terms of the way keys are stored in T
            - A structural property, defined in terms of the nodes of T itself
        * We assume that a total order relation on the keys is given by, for example, a comparator
        * The Heap-Order Property:
            - In a heap T, for every node v other than the root, the key associated with v
                is greater than or equal to the key associated with v's parent
        * A minimum key is always at the root of T, is at the "top of the heap"
        * Distinction between having largest or smallest key at the top is totally arbitrary
        * For efficiency, we want the heap T to have as small a height as possible
        * Low height enforced by insisting that T must be 'complete'
        * Terminology:
            level i of T                    set of nodes of depth i
            v is to the left of w           if v is encountered before w in an inorder traversal of T
           
        * Complete Binary Tree Property:
            A heap T with height h is a 'complete' binary tree, that is, levels 0, 1, 2, ..., h-1 of T have
                the maximum number of nodes possible (namely, level i has 2^i nodes, for 0 <= i <= h-1) and
                the nodes at level h fill this level from left to right.
               
        8.3.1.1 The Height of a Heap
            * Let h denote the height of heap T
            * The last node of T is the node on level h such that all other nodes on h are to the left of it
            * Proposition 8.5: A heap T storing n entries has height h = floor(log n)
            * Justification: level h has at most 2^h nodes, so the number of nodes of T is at most:
           
                (1 + 2 + 4 + ... + 2^(h-1)) + 2^h = 2^(h+1) - 1
               
                Since the number of nodes is equal to the number n of entries, we obtain
                   
                    2^h <= n <= 2^(h+1)-1
                   
                log of both sides of those inequalities gives
               
                    log(n+1)-1 <= h <= log n
                   
                Since h is an integer, those inequalities imply: h = floor(log n)
               
            * Consequently, if we can perform update operations on a heap in time proportional to its height,
                the operations will run in O(log n)
               
    8.3.2 Complete Binary Trees and Their Representation
        8.3.2.1 The Complete Binary Tree ADT
            * Supports all functions of binary tree adt, plus:
                add(e)          Add to T and return a new external node v storing e,
                                    such that T is a complete binary tree with last node v
                remove()        Remove the last node of T and return its element
               
            * Two cases for add(e):
                - If the bottom level of T is not full, it inserts a new node on the bottom level
                    immediately after  the rightmost node of that level, so T's height remains the same
                - If the bottom level is full, it inserts as the left child of the leftmost node of
                    the bottom level of T, and T's height increases by 1
                   
        8.3.2.2 A Vector Representation of a Complete Binary Tree
            * Especially suitable for a complete binary tree T
            * In this implementation, nodes of T are stored in a vector A such that v in T is
                the element of A with index equal to the level number f(v) defined as follows:
                - If v is the root of T, then f(v) = 1
                - If v is the left child of node u, then f(v) = 2f(u)
                - If v is the right child of node u, then f(v) = 2f(u) + 1
               
            * Using that, the nodes of T have contiguous indices in the range [1,n], and the last node is always at n
            * In this implementation, add and remove are O(1)
           
        8.3.2.3 A C++ Implementation of a Complete Binary Tree
            * Informal Interface:
           
                template <typename E>
                class CompleteTree {
                public:
                    class Position;
                    int size() const;
                    Position left(const Position& p);
                    Position right(const Position& p);
                    Position parent(const Position& p);
                    bool hasLeft(const Position& p) const;
                    bool hasRight(const Position& p) const;
                    bool isRoot(const Position& p) const;
                    Position root();
                    Position last();
                    void addLast(const E& e);
                    void removeLast();
                    void swap(const Position& p, const Position& q);
                };
               
            * Vector based implementation:
           
                template <typename E>
                class VectorCompleteTree {
                private:
                    std::vector<E> V;                       // tree contents
                public:
                    typedef typename std::vector<E>::iterator Position; // a position in the tree
                protected:
                    Position pos(int i)
                        { return V.begin() + i; }
                    int idx(const Position& p) const
                        { return p - V.begin(); }
                public:
                    VectorCompleteTree() : V(1) { }
                    int size() const                        { return V.size() - 1; }
                    Position left(const Position& p)        { return pos(2*idx(p)); }
                    Position right(const Position& p)       { return pos(2*idx(p) + 1); }
                    Position parent(const Position& p)      { return pos(idx(p)/2); }
                    bool hasLeft(const Position& p) const   { return 2*idx(p) <= size(); }
                    bool hasRight(const Position& p) const  { return 2*idx(p)+1 <= size(); }
                    bool isRoot(const Position& p) const    { return idx(p) == 1; }
                    Position root()                         { return pos(1); }
                    Position last()                         { return pos(size()); }
                    void addLast(const E& e)                { V.push_back(e); }
                    void removeLast()                       { V.pop_back(); }
                    void swap(const Position& p, const Position& q)
                                                            { E e = *q; *q = *p; *p = e; }
                };
               
    8.3.3 Implementing a Priority Queue with a Heap
        * Heap based priority queue P consists of:
            - heap: a complete binary tree T whose nodes store the elements of the queue, and whose
                keys satisfy the heap-order property. We assume T is implemented using a vector as above
                for each node v of T, the associated key is k(v)
            - comp: a comparator that defines the total order relation among the keys
           
        8.3.3.1 Insertion
            * To add a new element e in T, we add a new node z with add(), so that the new node is the last node of T
            * Then we store e in this node--tree is complete, but may violage heap order property
            * Unless z is the root of T, we compare k(z) with k(u) stored at the parent u of z
            * If k(z) >= k(u), heap order is satisfied and we do nothing
            * If k(z) < k(u), we need to restore the heap order property by swapping z and u
            * If the move causes heap order to be violated, we keep swapping in T until no violation occurs
            * This is called 'up-heap bubbling', and in the worst case moves an element from n to root, which is floor(log n)
       
        8.3.3.2 Removal
            * Smallest key is at the root of T, but we can't delete r without disrupting T
            * Instead access the last node w of T, copy its entry to the root, then delete the last node
       
        8.3.3.3 Down-Heap Bubbling after a Removal
            * T then probably violates the heap order
            * Two possible cases for h>1:
                - if r has no right child, let s be the left child of r
                - otherwise (r has both children), let s be a child of r with the smaller key
            * If k(r) <= k(s), heap order is satisfied
            * If k(r) > k(s), heap order is borked, must be restored by swapping r and s
            * Restores property for node r and children, but may bork it for s
            * May have to continue swapping down T until no violation occurs--this is 'down-heap bubbling'
            * A swap either resolves the issue or propagates it downward
           
        8.3.3.4 Analysis
            * Performance of a priority queue built via a heap:
                size, empty, min are all O(1)
                insert, removeMin are O(log n)
            * Heap is a very efficient realization of the priority queue ADT
            * Has fast time for both insertion and removal, unlike a list based priority queue
           
    8.3.4 C++ Implementation
        * Class definition, sans error checking:
       
            template <typename E, typename C>
            class HeapPriorityQueue {
            public:
                int size() const;
                bool empty() const;
                void insert(const E& e);
                const E& min();
                void removeMin();
            private:
                VectorCompleteTree<E> T;
                C isLess;
               
                typedef typename VectorCompleteTree<E>::Position Position;
            };
           
            template <typename E, typename C>
            int HeapPriorityQueue<E,C>::size() const
                { return T.size(); }
               
            template <typename E, typename C>
            bool HeapPriorityQueue<E,C>::empty() const
                { return size() == 0; }
               
            template <typename E, typename C>
            const E& HeapPriorityQueue<E,C>::min()
                { return *(T.root()); }
               
            template <typename E, typename C>
            void HeapPriorityQueue<E,C>::insert(const E& e) {
                T.addLast(e);
                Position v = T.last();
                while (!T.isRoot(v)) {
                    Position u = T.parent(v);
                    if (!isLess(*v, *u)) break;
                    T.swap(v.u);
                    v = u;
                }
            }
           
            template <typename E, typename C>
            void HeapPriorityQueue<E,C>::removeMin() {
                if (size() == 1)
                    T.removeLast();
                else {
                    Position u = T.root();
                    T.swap(u, T.last());
                    T.removeLast();
                    while (T.hasLeft(u)) {
                        Position v = T.left(u);
                        if (T.hasRight(u) && isLess(*(T.right(u)), *v))
                            v = T.right(u);
                        if (isLess(*v, *u)) {
                            T.swap(u,v);
                            u = v;
                        }
                        else break;
                    }
                }
            }
           
    8.3.5 Heap-Sort
        * Based on the PriorityQueueSort scheme from 8.1.5:
        * During phase 1, the i-th insert operation (1 <= i <= n) takes O(1 + log i) time,
            since the heap has i entries after the operation is performed
        * During phase 2, the j-th removeMin operation (1 <= j <= n) runs in time O(1+log(n-j+1)),
            since the heap has n - j + 1 entries at the time the operation is being performed
        * So each phase takes O(n log n) time
       
        8.3.5.1 Implementing Heap-Sort In-Place
            * If the list L is an array, we can do a heap sort using a portion of L itself to store the heap
                1.  Use a reverse comparator, which creates a max-heap
                    Use the left side of L up to i - 1 to store the heap
                    Works like a regular heap, but 0 indexed, so element at k >= children at 2k+1 and 2k+2
                2.  In phase 1, start with an empty heap
                    move the boundary between the heap and the list from left to right
                    in step i(i=1, ..., n), expand the heap by adding the element at i-1 via up-heap bubbling
                3.  In phase 2, start with an empty list and move the boundary from right to left
                    at step i(i=1, ..., n), remove a max element from the heap and store it at n-1
                   
    8.3.6 Bottom-Up Heap Construction
        * Heap sort is O(n log n), but if we have all elements in advance, there's a bottom-up way to build the heap
        * Bottom-up construction runs in O(n)
        * Assuming the number n of keys is an integer of the type n = 2^h - 1 (heap is a complete, full binary tree)
        * Nonrecursively, bottom-up heap construction consists of the following h = log(n+1) steps:
            1.  Construct (n+1)/2 elementary heaps storing one entry each
            2.  Form (n+1)/4 heaps, each storing three entries, by joining pairs of
                    elementary heaps and adding a new entry
            3.  Form (n+1)/8 heaps, each with 7 entries, by joining pairs of 3-entry heaps and adding a new entry
           
                i   In the generic i-th step, 2 <= i <= h, we form (n+1)/2^i heaps, each
                    storing 2^i-1 entries, by joining pairs of heaps storing (2^(i-1) - 1) entries
                    and adding a new entry as the root, then down-bubbling as appropriate
                   
                h+1 In the last step we form the final heap, storing all the n entries, by joining two heaps
                    storing (n-1)/2 entries and adding a new entry. The new entry is placed initially at the
                    root, then down-bubbled as necessary
                   
        8.3.6.1 Recursive Bottom-Up Heap Construction
            * Algorithm:
           
                Algorithm BottomUpHeap(L):
                    Input:  An STL list L storing n = 2^(h+1) - 1 entries
                    Output: A heap T storing the entries of L
                   
                    if L.empty() then
                        return an empty heap
                    e <- L.front()
                    L.pop_front()
                    Split L into two lists, L1 and L2, each of size (n-1)/2
                    T1 <- BottomUpHeap(L1)
                    T2 <- BottomUpHeap(L2)
                    Create Binary Tree T with root r storing e, left subtree T1, right subtree T2
                    Perform a down-heap bubbling from the root r of T, if necessary
                    return T
                   
            * Bottom up construction of a heap with n entries takes O(n) time, if two keys can be compared in O(1) time
           
8.4 Adaptable Priority Queues
    * Priority Queues may need additional methods, if for instance you have to remove other than the min
    * Or if a heap element's key value changes
   
    8.4.1
        8.4.1.1 Functions of the Adaptable Priority Queue ADT
            * A priority queue P that in addition to the standard operations, supports:
                insert(e)
                remove(p)
                replace(p,e)
               
    8.4.2 A List-Based Implementation
       
        template <typename E, typename C>
        class AdaptPriorityQueue {
        protected:
            typedef std::list<E> ElementList;
        public:
            class Position {
            private:
                typename ElementList::iterator q;
            public:
                const E& operator*() { return *q; }
                friend class AdaptPriorityQueue;
            };
        public:
            int size() const;
            bool empty() const;
            const E& min() const;
            Position insert(const E& e);
            void removeMin();
            void remove(const Position& p);
            Position replace(const Position& p, const E& e);
        private:
            ElementList L;
            C isLess;
        };
       
        template <typename E, typename C>
        typename AdaptPriorityQueue<E,C>::Position AdaptPriorityQueue<E,C>::insert(const E& e) {
            typename ElementList::iterator p = L.begin();
            while (p != L.end() && !isLess(e, *p)) ++p;             // find larger element
            L.insert(p,e);                                          // insert before p
            Position pos; pos.q = --p;
            return pos;                                             // inserted position
        }
       
        template <typename E, typename C>
        void AdaptPriorityQueue<E,C>::remove(const Position& p)
            { L.erase(p,q); }
           
        template <typename E, typename C>
        typename AdaptPriorityQueue<E,C>::Position AdaptPriorityQueue<E,C>::replace(const Position& p, const E& e) {
            L.erase(p,q);
            return insert(e);
        }
       
    8.4.3 Location-Aware Entries
        * If you too closely couple storage to heap placement, there can be problems
        * Helps to create a locator object, whose job is to store the position p of element e in a data structure
        * Each entry in the priority queue needs to know its associated locator l, so rather than storing
            the element in the priority queue, we store a pair consisting of the pair (e,&l) of
            the element e and a pointer to its locator--this is a 'locator-aware entry'
        * Price paid is storing two additional pointers (locator and locator's address) per entry, so increase is a constant
       
Chapter 9: Hash Tables, Maps, and Skip Lists

9.1 Maps
    * A map stores elements taht can be located quickly using keys
    * An entry is a key value pair, whose key must be unique in the map
    * Also called 'associative stores' or 'associative containers'
   
    9.1.1
        9.1.1.1 Entries and the Composition Pattern
            * The composition pattern defines a single object that's composed of other objects
            * A C++ class for an entry storing a key-value pair:
           
                template <typename K, typename V>
                class Entry {
                public:
                    Entry(const K& k = K(), const V& v = V())
                        : _key(k), _value(v) { }
                    const K& key() const { return _key; }
                    const V& value() const { return _value; }
                    void setKey(const K& k) { _key = k; }
                    void setValue(const V& v) { _value = v; }
                private:
                    K _key;
                    V _value;
                };
               
    9.1.2 The Map ADT
        * Involves an iterator object that can reference entities and navigate the map
        * Given an iterator p, the entry may be accessed by dereferencing the iterator, *p
        * Key and value can be accessed with p->key() and p->value()
        * To advance an iterator we overload the increment operator, so ++p advances p to the next entry
        * We can iterator over M by initializing p to M.begin() and incrementing p until M.end()
        * ADT functions:
            size()
            empty()
            find(k)
            put(k,v)
            erase(k)
            begin()
            end()
           
        9.1.2.1
            9.1.2.1.1 Example 9.1 -- usage of ADT functions
           
    9.1.3 A C++ Map Interface
        * Informal interface to a Map:
       
            template <typename K, typename V>
            class Map {
            public:
                class Entry;
                class Iterator;
               
                int size() const;
                bool empty() const;
                Iterator find(const K& k) const;
                Iterator put(const K& k, const V& v);
                void erase(const K& k) throw (NonexistentElement);
                void erase(const Iterator& p);
                Iterator begin();
                Iterator end();
            };
   
    9.1.4 The STL map class
        * Member functions:
            size()
            empty()
            find(k)
            operator[k]
            inert(pair(k,v))
            erase(k)
            erase(p)
            begin()
            end()
           
        * Usage example:
       
            map<string, int> myMap;
            map<string, int>::iterator p;
            myMap.insert(pair<string, int>("Rob", 28));
            myMap["Joe"] = 38;
            myMap["Joe"] = 50;
            myMap["Sue"] = 75;
            p = myMap.find("Joe");
            myMap.erase(p);
            myMap.erase("Sue");
            p = myMap.find("Joe");
            if (p == myMap.end()) cout << "nonexistent\n";
            for (p = myMap.begin(); p != myMap.end(); ++p) {
                cout << "(" << p->first << "," << p->second << ")\n";
            }
           
    9.1.5 A Simple List-Based Map Implementation
        * Map via storing n entries in a list L, implemented as a doubly linked list
        * find(k), put(k, v), erase(k) all involve simple scans down L looking for an entry with key k
        * Algorithms:
       
            Algorithm find(k):
                Input:  A key k
                Output: The position of the matching entry of L, or end if there is no key k in L
               
                for each position p in [L.begin(), l.end()) do
                    if p.key() = k then
                        return p
                return end
               
            Algorithm put(k,v):
                Input:  A key-value pair (k,v)
                Output: The position of the inserted/modified entry
                for each position p in [L.begin(), L.end()) do
                    if p.key() = k then
                        *p -> (k,v)
                        return p
                p <- L.insertBack((k,v))
                n <- n + 1
                return p
               
            Algorithm erase(k):
                Input:  A key k
                Output: None
               
                for each position p in [L.begin(), L.end()) do
                    if p.key() = k then
                        L.erase(p)
                        n <- n - 1
                       
        * This is only efficient for very small maps because each algorithm is O(n)
       
9.2 Hash Tables
    * keys are addresses for values in a map
    * One of the most efficient ways to implement a map is to use a hash table
    * Worst case run time of map operations in an n entry hash table is O(n), but often O(1)
    * Two major components: a bucket array and a hash function
   
    9.2.1 Bucket Arrays
        * An array A of size N, where each cell of A is a "bucket", a collection of key-value pairs
        * Integer N defines the capacity of the array
        * If keys are well distributed in the range [0,N-1], an entry e with key k goes into bucket A[k]
        * If keys are unique integers, each bucket holds at most one entry, so search/insertion/removal is O(1)
        * That wastes space and limits you in terms of key choice
       
    9.2.2 Hash Functions
        * A function h that maps each key k in our map to an integer in the range [0,N-1] where N is capacity of bucket array
        * Use the hash function value h(k) as an index to the bucket array A, instead of k
        * Entry (k,v) is in the bucket A[h(k)]
        * if h(k) is not unique in the map, you get a key collision--a good hash function minimizes collisions
        * Evaluation of h(k) is two actions:
            1.  mapping k to an integer, the 'hash code'
            2.  mapping the hash code to an integer in the range of indices [0,N-1], the 'compression function'
           
    9.2.3 Hash Codes
        * A hash code for key k should be repeatable, and an integer value, avoiding collisions as much as possible
       
        9.2.3.1 Hash Codes in C++
            * Assume the number of bits of each type is known, which you can get from including <limits>
            * Defines a templated class numeric limits, which given a base type T like char, int, float:
           
                number of bits in a var of type T is numeric_limits<T>.digits
               
        9.2.3.2 Converting to an Integer
            * For any data type X that is represented using at most as many bits as our integer hash codes,
                we can take an integer representation of its bits as a hash code for X
            * For char, short, and int, we can do this by casting to int
            * long is typically twice the bits of int--casting to an int removes half the information
            * A better hash code sums the high order bits as an int with the low order bits as an int
           
        9.2.3.3 Polynomial Hash Codes
            * Summation hash code is not good for character strings or other variable length objects
            * Summing the string 'cat' is the same as summing 'tac' or 'act'--ignores position
            * Better one chooses a nonzero constant greater than 1, a, and uses:
           
                x0a^(k-1) + x1a^(k-2) + ... + x sub k-2a + x sub k-1
               
            * It's a polynomial in a that takes the components (x0, x1, ..., xk-1) of an object x as coefficients
            * Can be rewritten as:
           
                xk-1 + a(xk-2 + a(xk-3 + ... + a(x2 + a(x1 + ax0))...))
               
            * Some studies show that 33, 37, 39, 41 are good choices for a when working with english word strings
           
        9.2.3.4 Cyclic Shift Hash Codes
            * Variant on polynomial replaces multiplication by a with a cyclic shift of a partial sum by a certain number of bits
            * Example in C++:
           
                int hashCode(const char* p, int len) {
                    unsigned int h = 0;
                    for (int i = 0; i < len; i++) {
                        h = (h << 5) | (h >> 27);
                        h += (unsigned int) p[i];
                    }
                    return hashCode(int(h));
                }
               
            * Experimentally a shift of 5 gives the lowest collisions
           
        9.2.3.6 Hashing Floating Point Quantities
            * Casting a float to an int would truncate the fraction part of the float
            * C++ provides an operation called a reinterpret cast to cast between unrelated types
            * Treats quantities as a sequence of bits and makes no attempt to convert meaningfully from one type to another
            * Could hash a float by reinterpreting it as an array of characters and then using hashCode():
           
                int hashCode(const float& x) {
                    int len = sizeof(x);
                    const char* p = reinterpret_cast<const char*>(&x);
                    return hashCode(p, len);
                }
               
            * Reinterpret casts are not portable operations, it's machine specific
           
    9.2.4 Compression Functions
        * hash codes aren't usually suitable for immediate use with a bucket array, since they're probably out of range
        * Second action of a hash function is to compress the hash code to a usable key
       
        9.2.4.1 The Division Method
            * One simple compression function (the division method) is:
           
                h(k) = abs(k) % N
           
            * If N is prime, it helps to spread the distribution of hashed values
            * If N is not prime, there is a high likelihood that patterns will be created in the key distribution
            * Probability of two different keys getting hashed to the same bucket should be < 1/N
            * If there is a repeated pattern of key values of the form iN + j for several different i's, there are collisions
           
        9.2.4.2 The MAD Method
            * More sophisticated function is "multiply add and divide":
           
                h(k) = abs(ak + b) % N
               
            * Where N is prime, and a and b are nonnegative integers randomly chosen when the compression function is determined,
                so that a % N != 0
            * Eliminates repeated patterns in a set of hash codes and gets closer to having a "good" hash function

    9.2.5 Collision-Handling Schemes
        9.2.5.1 Separate Chaining
            * Have each bucket A[i] store a small map, Mi, implemented using a list, holding entries (k,v) such that h(k) = i
            * Algorithms based on that:
           
                Algorithm find(k):
                    Output: The position of the matching entry in the map or end if there is no key k in the map                   
                    return A[h(k)].find(k) { delegate the find(k) to the list-based map at A[h(k)] }
                   
                Algorithm put(k,v):
                    p <- A[h(k)].put(k,v)  { delegate the put to the list-based map at A[h(k)] }
                    n <- n + 1
                    return p
                   
                Algorithm erase(k):
                    Output: None
                    A[h(k)].erase(k)       { delegate erase to the list based map at A[h(k)] }
                    n <- n - 1
                   
        9.2.5.2 Open Addressing
            * Avoiding the extra storage of a separate data structure in each bucket involves 'open addressing'
           
        9.2.5.3 Linear Probing and its Variants
            * If we try to insert an entry (k,v) into a bucket A[i] that is already occupied (where i = h(k)):
                - try next at A[(i+1) mod N].  If that's occupied:
                - try at A[(i+2) mod N], etc., until we find an empty bucket
            * Requires that we modify our get() op to search through A[i] etc. until finding a key k or an empty cell
            * Disadvantage is that it clusters entries into contiguous runs, which slows down search
       
        9.2.5.4 Quadratic Probing
            * Iteratively try the buckets at A[(i+f(j)] mod N], for j = 0,1,2,..., where f(j) = j^2, until there's an empty bucket
            * Creates 'secondary clustering', because the search cell bounces around A in patterns
           
        9.2.5.5 Double Hashing
            * Choose a secondary hash function, h', and if h maps k to A[i] with i = h(k) that's already occupied,
                we iteratively try buckets A[(i+f(j)) mod N] for j = 1,2,3..., where f(j) = j * h'(k)
            * h'() can't evaluate to zero--popular choice is h'(k) = q - (k mod q) for some prime q < N (and N should be prime)
           
    9.2.6 Load Factors and Rehashing
        * In all the above schemes, the load factor alpha = n/N should be kept below 1
        * alpha < 0.5 for open-addressing is good, alpha < 0.9 for separate chaining
        * As alpha >= 0.5, probability of collisions tips to positive, clusters grow, etc
       
        9.2.6.1 Rehashing into a New Table
            * If the load factor goes avove a threshold, it's common to require that the table be resized to regain a lower load factor
            * When resizing, it's good to at least double the base size of the hash table
            * Must define a new hash function, possibly computing new parameters, for the new hash
            * Then insert every item from the old array into the new one using the new hash function
           
    9.2.7 A C++ Hash Table Implementation
        * HashMap implementation:
           
            template <typename K, typename V, typename H>
            class HashMap {
            public:
                typedef Entry<const K,V> Entry;                 // a key/value pair
                class Iterator;                                 // an iterator/position
            public:
                HashMap(int capacity = 100);                    // constructor
                int size() const;
                bool empty() const;
                Iterator find(const K& k);
                Iterator put(const K& k, const V& v);
                void erase(const K& k);
                void erase(const Iterator& p);
                Iterator begin();
                Iterator end();
            protected:
                typedef std::list<Entry> Bucket;
                typedef std::vector<Bucket> BktArray;
                Iterator finder(const K& k);                    // find utility
                Iterator inserter(const Iterator& p, const Entry& e);       // insert utility
                void eraser(const Iterator& p);                 // remove utility
                typedef typename BktArray::iterator BItor;      // bucket iterator
                typedef typename Bucket::iterator EITor;        // Entry iterator
                static void nextEntry(Iterator& p)
                    { ++p.ent; }
                static bool endOfBkt(const Iterator& p)
                    { return p.ent == p.bkt->end(); }
            private:
                int n;                                          // number of entries
                H hash;                                         // hash comparator
                BktArray B;                                     // bucket array
            public:
                class Iterator {
                private:
                    EItor ent;
                    BItor bkt;
                    const BktArray* ba;
                public:
                    Iterator(const BktArray& a, const BItor& b, const EItor& q = EItor())
                        : ent(q), bkt(b), ba(&) { }
                    Entry& operator*() const;                       // get entry
                    bool operator==(const Iterator& p) const;       // are iterators equal?
                    Iterator& operator++();                         // advance to next entry
                    friend class HashMap;                           // give HashMap access
                };
            };
           
        9.2.7.1 Iterator Dereferencing and Condensed Function Definitions
            * C++ syntax requires a lot of template qualifiers
            * Example of Iterator dereferencing operator:
           
                template <typename K, typename V, typename H>
                typename HashMap<K,V,H>::Entry& HashMap<K,V,H>::Iterator::operator*() const
                    { return *ent; }
                   
            * To save notational space, the book will write the same thing as:
           
                /* HashMap K,V,H:: */
                Entry& Iterator::operator *() const
                    { return *ent; }
                   
        9.2.7.2 Definitions of the Other Iterator Member Functions
            * Check to see if two iterators are equal:
           
                /* HashMap K,V,H:: */
                bool Iterator::operator ==(const Iterator& p) const {
                    if (ba != p.ba || bkt != p.bkt) return false;           // ba or bkt differ?
                    else if (bkt == ba->end()) return true;                 // both at the end
                    else return (ent == p.ent);                             // else use entry to decide
                }
               
            * Incrementing to the next Iterator position, which may mean crossing to next bucket:
           
                /* HashMap K,V,H:: */
                Iterator& Iterator::operator ++() {
                    ++ent;                                                  // next entry in bucket
                    if (endOfBkt(*this)) {                                  // at end of bucket?
                        ++bkt;
                        while (bkt != ba->end() && bkt->empty())            // find non-empty bucket
                            ++bkt;
                        if (bkt == ba->end()) return *this;                 // end of bucket array?
                        ent = bkt->begin();                                 // first nonempty entry
                    }
                    return *this;                                           // return self
                }
               
        9.2.7.3 Definitions of the HashMap Member Functions
            * Beginning and end:
           
                /* HashMap K,V,H:: */
                Iterator end()
                    { return Iterator(B, B.end()); }
                   
                /* HashMap K,V,H:: */
                Iterator begin() {
                    if (empty()) return end();
                    BItor bkt = B.begin();
                    while (bkt->empty()) ++bkt;
                    return Iterator(B, bkt, bkt->begin());
                }
               
            * Constructor and standard functions for HashMap:
           
                /* HashMap K,V,H:: */
                HashMap(int capacity) : n(0), B(capacity) { }
               
                /* HashMap K,V,H:: */
                int size() const { return n; }
               
                /* HashMap K,V,H:: */
                bool empty() const { return size() == 0; }
               
                /* HashMap K,V,H:: */
                Iterator finder(const K& k) {
                    int i = hash(k) % B.size();                         // get hash index i
                    BItor bkt = B.begin() + i;                          // the i-th bucket
                    Iterator p(B, bkt, bkt->begin());                   // start of i-th bucket
                    while (!endOfBkt(p) && (*p).key() != k)
                        nextEntry(p);
                    return p;
                }
               
                /* HashMap K,V,H:: */
                Iterator find(const K& k) {
                    Iterator p = finder(k);                             // look for k
                    if (endOfBkt(p))                                    // didn't find it?
                        return end();                                   // return end iterator
                    else
                        return p;                                       // return its position
                }
                   
                /* HashMap K,V,H:: */
                Iterator inserter(const Iterator& p, const Entry& e) {
                    EItor ins = p.bkt->insert(p.ent, e);
                    n++;
                    return Iterator(B, p.bkt, ins);
                }
               
                /* HashMap K,V,H:: */
                Iterator put(const K& k, const V& v) {
                    Iterator p = finder(k);
                    if (endOfBkt(p)) {
                        return inserter(p, Entry(k,v));
                    }
                    else {
                        p.ent->setValue(v);
                        return p;
                    }
                }
               
                /* HashMap K,V,H:: */
                void eraser(const Iterator& p) {
                    p.bkt->erase(p.ent);
                    n--;
                }
               
                /* HashMap K,V,H:: */
                void erase(const Iterator& p)
                    { eraser(p); }
                   
                /* HashMap K,V,H:: */
                void erase(const K& k) {
                    Iterator p = finder(k);
                    if (endOfBkt(p))
                        throw NonexistentElement("Erase of nonexistent");
                    eraser(p);
                }
               
9.3 Ordered Maps
    * A ordered map is a sorted key/value store
    * Performs the usual map operations, but also has an order relation for the keys, a comparator, etc.
    * Ordered map includes all the standard map ADT functions, plus:
        firstEntry(k)
        lastEntry(k)
        ceilingEntry(k)
        floorEntry(k)
        lowerEntry(k)
        higherEntry(k)
       
    9.3.1
        9.3.1.1 Implementing an Ordered Map
            * Since it's ordered, an unordered list or hash table is not appropriate
           
    9.3.2 Ordered Search Tables and Binary Search
        * Fast algorithm for search in this case involves an ordered vector
        * Ordered vector implementation of a map is an 'ordered search table'
        * Space requirement is O(n)
        * Insert and erase are also O(n), much worse than linked list
        * Search is still much faster
       
        9.3.2.1 Binary Search
            * The elements of L are map entries, and since L is ordered, the entry at i has a key no smaller than 0,...,i-1
                and no larger than i+1,...,n-1
            * If at the current stage of the search we cannot rule out that an entry has a key equal to k, it's a 'candidate'
            * Algorithm has a low and a high parameter, such that all candidate entries are at least low and at most high
            * Initially, low = 0 and high = n-1
            * then we compare k to the key of the median candidate e, which has the index:
           
                mid = floor((low+high)/2)
               
            * Three cases to consider:
                1.  If k = e.key(), search terminates and returns e
                2.  If k < e.key(), we recur on the first half of the vector (indices from low to mid-1)
                3.  If k > e.key(), recur on the indices from mid+1 to high
               
            * Algorithm:
           
                Algorithm BinarySearch(L, k, low, high):
                    Input:  An ordered vector L with n entries and integers low and high
                    Output: An entry of L with key equal to k and index between low and high, if it exists
                   
                    if low > high then
                        return end
                    else
                        mid <- (low + high) / 2
                        e <- L.at(mid)
                        if k = e.key() then
                            return e
                        else if k < e.key() then
                            return BinarySearch(L, k, low, mid-1)
                        else
                            return BinarySearch(L, k, mid+1, high)
                           
            * Run time for binary search is floor(log n) + 1
            * Due to inefficiencies in insert/erase, we use ordered map tables in situations with high read / low write
           
        9.3.2.2 Comparing Map Implementations
       
            Method              List            Hash Table                      Search Table
            size, empty         O(1)            O(1)                            O(1)
            find                O(n)            O(1) exp., O(n) worst-case      O(log n)
            insert              O(1)            O(1)                            O(n)
            erase               O(n)            O(1) exp., O(n) worst-case      O(n)
           
    9.3.3 Two Applications of Ordered Maps
        9.3.3.1 Flight Databases
            * Flight db is a map where keys are Flight objects made of a tuple:
           
                k = (origin, destination, date, time)
               
            * Additional flight information is stored in the value object
           
        9.3.3.2 Maxima Sets
            * Modeling a tradeoff between automobile max speed and cost
            * Lets people find the fastest car they can afford
            * Uses a key-value pair to model the two parameters trading off between
            * Formally, a price-performance pair (a,b) 'dominates' a pair (c,d) if (a < c && b > d)
            * Pair (a,b) is a 'maximum' if it is not dominated by any other pair
           
        9.3.3.3 Maintaining a Maxima Set with an Ordered Heap
            * Store the set of pairs in an ordered map M, ordered by cost, so cost is the key and speed is the value
            * add(c,p) will add a new pair, best(c) will return the best pair with cost at most c
            * Algorithms:
           
                Algorithm best(c):
                    Input:  A cost c
                    Output: The cost-performance pair in M with largest cost >= c or the sentinel end
                   
                    return M.floorEntry(c)
                   
                Algorithm add(c,p):
                    Input:  A cost-performance pair (c,p)
                    Output: None (but M will have (c,p) added to the set of pairs
                   
                    e <- M.floorEntry(c)            { greatest pair with cost at most c }
                    if e != end then
                        if e.value() > p then
                            return                  { (c,p) is dominated, so don't insert it in M }
                        e <- M.ceilingEntry(c)      { next pair with cost at least c }
                        { remove all pairs dominated by (c,p) }
                        while e != end and e.value() < p do
                            M.erase(e.key())                    { this pair is dominated by (c,p) }
                            e <- M.higherEntry(e.key())         { next pair after e }
                        M.put(c,p)                              { add (c,p), which is not dominated
                       
            * Implementing with any previously discussed data structure is inefficient--need to use a skip list
           
9.4 Skip Lists
    * A skip list efficiently realizes an ordered map
    * It makes random choices in arranging the entries, so search and update 
        are O(log n) on average
    * Skip lists have as expected bounds that are worst-case for binary search in a 
        lookup table, but skip lists are faster than lookup tables for map updates
    * A skip list S for a map M consists of a series of lists {S0, S1, ..., Sh}
    * Each list Si stores a subset of the entries of M sorted by increasing keys plus 
        entries with two special keys, -infinity and +infinity, where -infinity is smaller 
        than every possible key that can be inserted in M and +infinity is larger than 
        every possible key that can be inserted in M
    * The lists in S satisfy the following:
        - List S0 contains every entry of the map M (plus -infinity and +infinity)
        - For i = 1, ..., h-1, list Si contains a randomly generated subset of the entries 
            in list Si-1
        - List Sh contains only -infinity and +infinity
        
    * Example skip list:
        S5 = [-inf,                                         +inf]
        S4 = [-inf,     17,                                 +inf]
        S3 = [-inf,     17,     25,                     55, +inf]
        S2 = [-inf,     17,     25, 31,                 55, +inf]
        S1 = [-inf, 12, 17,     25, 31, 38,     44,     55, +inf]
        S0 = [-inf, 12, 17, 20, 25, 31, 38, 39, 44, 50, 55, +inf]
        
    * Each entry in Si+1 is selected at 50% probability from Si
    * If S0 has n entries, S1 will have about n/2, Si will have about n/2^i entries
    * The height h of S will be about log n
    * Positions in a skip list can be traversed with:
        after(p)        return position following p on same level
        before(p)       return position preceding p on same level
        below(p)        return position below p in the same tower
        above(p)        return position above p in the same tower
    * Return null if position does not exist
    * We can implement a skip list by means of a linked structure so all traversals 
        take O(1) given position p
    * It's a collection of h doubly linked lists aligned at towers, which are also 
        doubly linked lists
    
    9.4.1 Search and Update Operations in a Skip List
        * All skip list search and update algorithms are based on a SkipSearch function
        * SkipSearch takes a key k and finds the position p of the entry e in list S0 such 
            that e has the largest key (possibly -infinity) less than or equal to k
            
        9.4.1.1 Searching in a Skip List
            * Given a search key k, start with p in the top left position in S
            * Start position is Sh[-inf]
            * Perform these steps where key(p) denotes key of position p:
                1.  If S.below(p) is null, search terminates--at the bottom
                    Else, drop down to next lower level in present tower: p=S.below(p)
                2.  Scan-forward step: Starting at pp, move p forward until it is at the 
                    right-most position on the present level, such that key(p) <= k
                    Repeat step 1.
                    
            * Pseudo-code of SkipSearch:
            
                Algorithm SkipSearch(k):
                    Input:  A search key k
                    Output: Position p in the bottom list S0 such that the entry at p
                            has the largest key less than or equal to k
                            
                    p <- s
                    while below(p) != null do
                        p <- below(p)               { drop down }
                        while k <= key(after(p)) do
                            p <- after(p)           { scan forward }
                    return p
                    
        9.4.1.2 Insertion in a Skip List
            * Uses randomization to decide the height of the tower for a new entry
            * For a new entry (k,v), start by performing a SkipSearch(k), to get position
                p of the bottom level entry with the largest key less than or equal to k
            * Then insert (k,v) immediately after position p
            * After inserting at the bottom level, binary coin flip--if 1, insert into S1,
                continue flipping for each list up (if Si-1 coin flip was 1)
            * Algorithm for SkipInsert(k,v), expected to be O(log n):
            
                Algorithm SkipInsert(k,v):
                    Input:  Key k and value v
                    Output: Topmost position of the entry inserted
                    
                    p <- SkipSearch(k)
                    q <- null
                    e <- (k, v)
                    i <- -1
                    
                    repeat
                        i <- i + 1
                        if i <= h then
                            h <- h + 1              { add a new level to S }
                            t <- after(s)
                            s <- insertAfterAbove(null, s, (-inf, null))
                            insertAfterAbove(s, t, (+inf, null))
                        while above(p) = null do
                            p <- before(p)          { scan backward }
                            p <- above(p)           { jump up to higher level }
                            q <- insertAfterAbove(p,q,e)    { add pos to tower of new entry}
                    until coinfFlip() = tails
                    n <- n + 1
                    return q
                    
        9.4.1.3 Removal in a Skip List
            * To do erase(k), do SkipSearch(k), if p stores an entry with key different
                from k, return null, else remove p and all positions above p
            * Has O(log n) expected running time
            * Note that you don't actually need references to entries at the levels of the
                skip list above the bottom level, since all you need there are keys
            * Also, you don't need above() or before()--you only ever move down and right
            
        9.4.1.4 Maintaining the Top-most level
            * A skip list S must maintain a reference to the start position as a member var
            * Must have a policy for any insertion that wishes to continue inserting a new
                entry past the top level of S
            * Two solutions:
                - Restrict the top level, h, to be kept at some fixed value that's a function
                    of n, the number of entries in the map. If you do this, you have to
                    modify insert to stop inserting once you reach the top level
                - Let an insertion continue inserting a new psoition as long as heads keeps
                    getting returned from coinFlip(). Probability of this being a problem is low