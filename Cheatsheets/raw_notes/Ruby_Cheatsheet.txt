#### Ruby Cheatsheet ####

#### OPERATORS ####
    #### MATHEMATICAL ####
    # + - * / ** %

    #### LOGICAL #### 
    # && || ! and or not
    
    #### COMPARISON/EQUALITY ####
    # == != > < >= <= <=> .eql?
    
    #### ASSIGNMENT ####
    # = += -= *= **= %= &= ^= ||=
    
    #### BITWISE ####
    # ~ | & ^ << >> &= ^= ||=
    
    #### RANGES ####
    # ..            open range
    # ...           closed range
    # ===           tests for inclusion in range
    # (1..9).to_a   to array

#### CONDITIONALS ####

    #### IF/ELSIF/ELSE ####
        if 1 == 1
            print "true"
        end
        
        if 1 == 1: print "true" end
        
        print "true" if 1 == 1
        
        if x
            y = true
        else
            y = false
        end
        
        if x == 1
            y = 'a'
        elsif x == 2
            y = 'b'
        else
            y = 'c'
        end
        
        if    x == 1: y = 'a'
        elsif x == 2: y = 'b'
        else          y = 'c'
        end
    
    #### TERNARY ####
        x = x == 1 ? 'a' : 'b'
    
    #### CASE ####
        y = case x
            when 1: 'a'
            when 2: 'b'
            else    'c'
        end
    
        z = 5
        case z
            when    0: puts "lowest"
            when 1..3: puts "medium-low"
            when 4..5: puts "medium"
            when 6..7: puts "medium-high"
            when 8..9: puts "high"
            when   10: puts "highest"
            else       puts "off scale"
        end
    
    #### WHILE ####
        while i < breeds.size do
            temp << breeds[i].capitalize
            i += 1
        end
        
        while i < breeds.size
            temp << breeds[i].capitalize
            i += 1
        end
        
        temp = 98.3
        begin
            print "Your temp is " + temp.to_s + " Fahrenheit. "
            puts "I think you're okay."
            temp += 0.1
        end while temp < 98.6
        
        cash += 1.00, sum while cash < 1_000_000.00
    
    #### BREAK #### 
        while i < breeds.size
            temp << breeds[i].capitalize
            break if temp[i] == "Arabian"
            i += 1
        end
        p => temp    
        
    #### Unless/until ####
    
        # Simple unless
        unless lang == "de"
            dog = "dog"
        else
            dog = "Hund"
        end
    
        
        # Inline form
        puts age += 1 unless age > 29
    
        
        # Like do/while
        weight = 150
        begin
            puts "Weight: " + weight.to_s
            weight += 5
        end until weight == 200
    
        
        # As statement modifier:
        puts age += 1 until age > 28
        
    #### The loop method ####        
        # runs continuously until break, comes from Kernel
        loop do
            print "Type something: "
            line = gets
            break if line =~ /q|Q/
            puts line
        end
        
    #### The for loop ####
    
        # simple example
        for i in 1..5 do
            print i, " "
        end
        
        # alternately
        for i in 1..5
            print i, " "
        end
        
        # one liner
        for i in 1..5 do print i, " " end
        
        # using 'times'
        10.times { |i| print i, " " }
        
        # using 'upto'    
        1.upto(10) { |i| print i, " " }
        
        # using 'downto'
        5.downto(1) { |i| print i, " " }
        
    #### BEGIN and END blocks ####
    
        BEGIN { puts "Date and time: " + Time.now.to_s }
        def bmi(w, h)
            703.00*(w.to_f/(h.to_f**2))
        end
        
        my_bmi = bmi(196,73)
        
        puts "Your BMI is: " + x = sprintf("%0.2f", my_bmi)
        
        END { puts "Blah blah blah." }
            
            
#### STRINGS ####
    #### INSTANTIATION ####
        x = String.new
        x = String.new("This is a string.")
        x = "This is a string."
        
    #### QUOTE STYLES AND HEREDOCS ####
        'abc'           # Preserves escaped characters
        "abc"           # Interprets escaped characters
        %!abc!          # General delimited strings
        %[abc]
        %(abc)
        
        x = <<end       # heredoc like double quotes
end     
        x = <<"end"     # heredoc like double quotes
end        
        x = <<'end'     # heredoc like single quotes
end
        x = <<`end`     # heredoc like backticks
end
        x = <<-end      # allows indentation
end
        
    #### CONCATENATION ####
        "a" "b" "c"
        "a" + "b" + "c"
        "a" << "b" << "c"
        "a".concat "b"
        
    #### ACCESSING STRINGS ####
        x = 'abcdef'
        x['cde']        # returns string if found
        x[1]            # returns charcode of pos 1
        x[1].chr        # returns character at pos 1
        x[0..4]         # inclusive range selection
        x[0...4]        # exclusive range selection
        x[/cde/]        # via regex
        
    #### COMPARISONS ####
        a == b          # full equality test
        a.eql? b        # full equality test
        a <=> b         # compares character codes
        a casecmp b     # case insensitive character comparison
        
    #### STRING METHODS ####
        x.size
        x.length
        x.freeze        # make immutable
        x.frozen?
        x.index('a')
        x.insert(2,'b')
        x * 4           # repeats 4 times
        x['abc']= 'xyz' # substitutes in place
        x.chop
        x.chop!
        x.chomp
        x.chomp!
        x.delete "b"
        x.gsub "abc","xyz" # substring replacement
        x.replace "xyz" # replaces entire string
        x.reverse
        x.reverse!
        x.split         # returns ['abcdef']
        x.split(//)     # returns array of letters
        x.capitalize
        x.capitalize!
        x.downcase
        x.upcase
        x.swapcase
        x.ljust 10      # adds right padding
        x.rjust 10      # adds left padding
        x.ljust(20,'-') # pads with string
        x.center 30     # centers
        x.center 30,'-' # centers with string
        x.lstrip
        x.rstrip
        x.strip
        x.class
        x.to_f          # to float
        x.to_i          # to integer
        x.intern        # :abcdef
        x.to_sym        # :abcdef
        x.grep(/abc/)   # search with Enumerable.grep
        
        # next/succ methods increments the rightmost character
        "a".next    # => "b"
        "aa".succ   # => "ab"        

        
        # splitting by lines
        "A\nB\nC\nD".each { |item| puts item.capitalize }
    
        # splitting by bytes
        "ABCD".each_byte { |b| print b, "/" }        
        
                    
#### NUMBERS ####
    #### OPERATORS #### 
    # Operators: + - * / ** %
    # Unary: + -
    # Named: .div .modulo .divmod .quo .remainder
    #
    # Integer division results in truncated Int result
    # .div returns only integral part, truncates decimal part
        
    #### INTROSPECTION ####
    x.zero?
    x.nonzero?
    x.finite?
    x.infinite?
    x.nan?
    x.inspect
    
    #### ITERATION ####
    10.times { |i| print i, " " }
    
    ####  METHODS ####
    x.abs
    x.ceil
    x.floor
    x.round
    x.next
    x.chr
    
    #### MATH FUNCTIONS ####
    Math.constants # => ["E", "PI"]
    Math.exp(1) # Euler to the power of x
    Math.sqrt
    Math.log(Math::E) # => 1.0
    Math.log(1)
    
    #### RATIONAL NUMBERS #### 
        require 'rational'
        require 'mathn'
        
        rat = Rational(25/100)
        
        rat + Rational(1/4)
        rat + 1/4
        
        rat - Rational(1/8)
        rat - 1/8
        
        rat * 3
        rat / 2
        
        rat % Rational(1/2)
        
        rat**2        
    
    #### PRIMES ####
    
        require 'mathn'
        
        prime_number = Prime.new
        prime_number.next
        prime_number.succ
        
        puts "The next prime is " + prime_number.next.to_s + "."    
        

#### ARRAYS ####
    #### INSTANTIATION ####
    x = Array.new
    x = Array.new(12)
    x = Array.new(12, "defaultstring")
    
    x = Array.new(10) { |e| e = e * 2 }
    
    x = Array.[]("a","b","c")
    x = Array["a","b","c"]
    x = ["a","b","c"]
    x = %w[a b c]
    
    #### ACCESSING ELEMENTS ####
    x[0]
    x[-1]
    x[0,3]
    
    #### ADDING/REMOVING ELEMENTS ####
    x.pop
    x.push('a')
    x.shift
    x.unshift('a')
    
    x.insert(0,'a')
    x[2..4] = "a","b","c"   # range replace
    x[2,2]  = "a","b","c"   # start and length replace

    x.delete "a"
    x.delete_at(1)
    
    #### ITERATION ####
    x.each { |e| print e.capitalize + " " }  # performs iteration
    x.map  { |e| print e.capitalize + " " }  # performs iteration, returns array
    
    #### CONCATENATION ####
    x + y
    x << y
    x.concat(y)
    
    #### SET OPERATIONS ####
    & intersection
    - difference
    | union    
    
    #### ARRAY METHODS ####
    x.empty?
    x.size
    x.clear
    x.slice(0,3)
    x.first
    x.last
    x.at(0)
    x.include ? 'a'
    x.uniq
    x.uniq!
    x.sort
    x.sort!
    x.reverse
    x.flatten
    x.transpose     # converts [["a", 1], ["b", 2], ["c", 3]]
                    # to       [["a","b","c"], [1,2,3]]        
                    
#### HASHES ####
    #### INSTANTIATION ####
    x = Hash.new
    x = Hash.new('defaultstring')
    x = Hash.new 'defaultstring'
    x = Hash[:key1, "val1", :key2, "val2"]
    x = Hash[:key1 => "val1", :key2 => "val2"]
    x = {"key1" => "val1", "key2" => "val2"}
    
    #### ACCESSING ELEMENTS ####
    x["key1"]
    
    x.select { |key,val| key > 1000 } # returns elements matching block
    
    #### ITERATION ####
    x.each { |k,v| puts "#{k}/#{v}" }
    
    #### CHANGING VALUES ####
    x['key1']= "val3"
    x.merge y
    x.delete('key2')
    x.delete('key3') { |key| puts "not found" } # block runs if key not found
    x.delete_if { |k,v| k<3 }
    x.replace(y)
    x.clear
    
    #### CLASS CONVERSIONS ####
    x.to_s
    x.to_a
    x.to_hash
    
    #### HASH METHODS ####
    x.empty?
    x.length
    x.size
    x.has_key? 'a'
    x.has_value? 'b'
    x.keys
    x.values
    x.values_at 'a'
    x.values_at 'a','b'
    x.index 'val2'
    x.sort # sorts by key                    