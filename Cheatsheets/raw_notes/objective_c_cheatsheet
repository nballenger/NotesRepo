Language construct cheatsheet:

++++ GENERAL INFO ++++

    * Case sensitive
    * Comment style is // and /* */
    * Block syntax is { } for multi-line, blank for single line

++++ DEFINING A CLASS ++++

    // @interface section:
    @interface ClassName: ParentClass
    {
        datatype    membername;
        datatype    membername;
    }
    
    // prepending a + indicates a class method
    +(void)   methodname;
    
    // prepending a - indicates instance method
    -(void)   methodname;  // No args
    -(void)   methodname: (int) n;  // with one arg
    
    @end
    
    // @implementation section
    @implementation ClassName
    -(void) methodname
    {
        // method body
    }
    @end

++++ DEFINING MULTI_ARG METHODS ++++

    -(void) setName: (char) n andEmail: (char) e
    {
        name  = n;
        email = e;
    }
    
    -(void) set: (int) n : (int) e
    {
        name  = n;
        email = e;
    }
++++ INVOKING A CLASS METHOD ++++

    [ClassName method];
    
++++ INVOKING AN INSTANCE METHOD ++++

    [instanceName method];
    
    [instanceName method: arg1, arg2];
    
    instanceName.method;
    
    instanceName.property = value; // equiv. to setProperty: value

    [instanceName methodpart_a: arg1 part_b: arg2]
    
++++ BASIC DATA TYPES ++++

    type:                       NSLog chars:
    char                        %c
    short int                   %hi, %hx, %ho
    unsigned short int          %hu, %hx, %ho
    int                         %i, %x, %o
    unsigned int                %u, %x, %o
    long int                    %li, %lx, %lo
    unsigned long int           %lu, %lx, %lo
    long long int               %lli, %llx, %llo
    unsigned long long int      %llu, %llx, %llo
    float                       %f, %e, %g, %a
    double                      %f, %e, %g, %a
    long double                 %Lf, %Le, %Lg
    id                          %p

++++ ARITHMETIC OPERATORS ++++

    +  -  /  *  %

++++ TYPE CAST OPERATOR ++++

    i2 = 1000;
    f2 = (float) i2 / 100;
    NSLog (@"Value is %f", f2); // prints "Value is 10.0"

++++ ASSIGNMENT OPERATORS ++++

    =  +=  -=  /=  *=  %=  --  ++

++++ BITWISE OPERATORS ++++

    &       Bitwise AND
    |       Bitwise inclusive-OR
    ^       Bitwise OR
    ~       Ones complement
    <<      Left shift
    >>      Right shift

++++ RELATIONAL OPERATORS ++++

    ==  !=  <  <=  >  >=

++++ LOOPS ++++

*   for (n = 1; n < 10; n++)
    {
        NSLog (@"Value of n is %i", n);
    }
    
    int n;
    n = 0;
*   while (n < 5)
    {
        NSLog (@"Value of n is %i", n);
    }
    
*   do
        NSLog (@"Value of n is %i", n);
    while (n < 5);
    
    n = 5
    while (1)
    {
        NSLog (@"Value of n is %i", n);
        n--;
        if (n <= =)
*           break;
    }
    
    n = 1;
    while (n < 20)
    {
        n++;
        if (n % 2 == 0)
*           continue;
        else
            NSLog (@"Value of n is %i", n);
    }
    }
 
 
++++ TAKING CLI INPUT ++++


++++ CONDITIONAL STATEMENTS ++++

    int n;
    n = 10;    
*   if (n < 20)
        NSLog(@"Less than 20!");
*   else if (n > 20)
        NSLog(@"More than 20!");
*   else
        NSLog(@"Exactly 20!");
        
        
*   switch (n)
    {
        case 1:
            NSLog(@"Little!");
            break;
        case 10:
            NSLog(@"Medium!");
            break;
        case 100:
            NSLog(@"Large!");
            break;
        default:
            NSLog(@"Whatever.");
            break;
    }
    
    int x;
*   x = (n > 20) ? 1 : 0;


++++ SEPARATE INTERFACE AND IMPLEMENTATION ++++

File MyClass.h:
    #import <Foundation/Foundation.h>
    @interface MyClass : NSObject
    {
        int a;
        int b;
    }
    @property int a, b;     // Set up synthesizing getters/setters
    -(void)     print;
    @end
    
File MyClass.m:
    #import "MyClass.h"     // Locally imports first file
    @implementation MyClass
    @synthesize a, b;       // second part of getters/setters
    -(void)     print       // method implementations
    {
        NSLog(@"a: %i, b: %i", a, b);
    }
    @end
    
++++ VARIABLE SCOPE ++++

    * Scope is block level
    * Variables must still be declared and typed
    * Arguments to methods are considered local variables
    * You can declare a local variable static in its declaration
    * Static variables retain value through multiple method calls
    * Static variables can only be accessed from within the method in which they're declared
    * Static variables can also be declared outside a method, to make them accessible to all methods within a class

++++ self KEYWORD ++++

    * [self methodname] inside a method directly identifies the calling obj
    
++++ INHERITANCE ++++

    * The root class is at the top of the hierarchy
    * subclasses inherit methods and instance variables
    * Method resolution begins in the base class and proceeds to the root
    * the @class directive allows you to import a single class
    * Objects passed into instance variables will be stored as pointers
    * to avoid that, have your setter method explicitly create an object
    * object values for instance variables should be released prior to object release
    
++++ OVERRIDING METHODS ++++

    * Works like you would expect.
    * It's possible to override the dealloc method of NSObject to do garbage collection for your classes
    * overriding the release method and overriding dealloc are different--release only invokes dealloc on something if there are no remaining pointers to it.
    * The super keyword invokes methods of the parent class
    * [super release] invokes the release method of the parent class, for instance
    * an example overridden dealloc, doing garbage collection:
    
        -(void) dealloc
        {
            if (some_instance_var_obj)
                [some_instance_var_obj release];
            [super dealloc];
        }
        
    OR
    
        -(void) dealloc
        {
            [some_instance_var_obj release]; // okay to send msg to null obj
            [super dealloc];
        }
        
    * If you set an instance variable to values from a passed in object, make sure to release the object passed in if necessary:
    
        -(void) setSomething: (SomeClass *) obj
        {
            [some_instance_var_obj release];
            some_instance_var_obj = [[SomeClass alloc] init];
            [some_instance_var_obj setVal: obj.val];
        }
        
++++ ADDING NEW INSTANCE VARIABLES ++++

    * Declare them in the child class.
    
++++ ABSTRACT CLASSES ++++

    * Most of the NSObject, NSNumber type things are abstract.
    
++++ THE ID DATATYPE ++++

    * Generic datatype--can be used to store objects belonging to any class
    * dynamically typed data type--basically a loosely typed container
    * can induce runtime errors, since datatype is indeterminate at compile
    
++++ NSOBJECT INTROSPECTION METHODS ++++

    -(BOOL) isKindOfClass: class-object
    -(BOOL) isMemberOfClass: class-object
    -(BOOL) respondsToSelector: selector
    +(BOOL) instancesRespondToSelector: selector
    +(BOOL) isSubclassOfClass: class-object
    -(id)   performSelector: selector
    -(id)   performSelector: selector withObject: object
    -(id)   performSelector: selector withObject: object1 withObject: object2
    
    Example tests:
    
        if ([obj1 class] == [obj2 class]) ...
        [myFract isMemberOfClass: [Fraction class]]
    
    To produce a selector:
    
        @selector (alloc)
        @selector (setTo:over:)
    
    Testing with a selector:
    
        [Fraction instancesRespondToSelector: @selector (setTo:over:)]
        
        action = @selector (draw);
        if ([graphicObject respondsToSelector: action YES)
            [graphicObject performSelector: action]
        else
            // error handling
            
++++ EXCEPTION HANDLING WITH @try ++++

    Code examples:
    
        @try {
            statement;
        }
        @catch (NSException *exception) {
            statement;
        }
        @catch (OtherException *exc) {
            @throw;
        }
        @finally {
            statement; // runs whether or not an exception is thrown
        }
        
++++ INITIALIZING CLASSES ++++

    * you can define custom init methods, like initWithArray
    
    Example init method:
    
        -(Fraction *) initWith: (int) n: (int) d
        {
            self = [super init];
            if (self)
                [self setTo: n over: d];
            return self;
        }
        
++++ SCOPING DIRECTIVES ++++

    @protected -- Methods defined in the class and any subclasses can directly access the instance variables that follow.  This is the default case.
    @private   -- Methods defined in the class can directly access the instance variables that follow, but subclasses cannot.
    @public    -- Methods defined in the class and any other classes or modules can directly access the instance variables that follow.
    @package   -- For 64-bit images, the instance variable can be accessed anywhere within the image that implements the class.
    
++++ EXTERNAL VARIABLES ++++

    * global variables are declared outside the scope of a class
    * by convention, their names start with a lowercase g
    * External variables are those whose value can be accessed and changed by any other functions or methods.  They are declared with the keyword 'extern', like:
    
        extern int gMoveNumber;
        
    * Any external variable must be declared somewhere as non-external.
    * A variable can be declared external many times, but defined only once.
    * To declare a variable that will be globally scoped but not externally available, use the 'static' keyword, like:
    
        static int gGlobalVar = 0;
    
++++ STORAGE CLASS SPECIFIERS ++++

    * extern and static are two specifiers.  Others include:
    
        auto  -- used to declare an automatic local variable--default for variables
        const -- declares a variable the program will not change the value of
        volatile -- tells the compiler the variable will change its value. Keeps the compiler from optimizing away redundant looking assignments. 
        
++++ ENUMERATED DATA TYPES ++++

    * Lets you define a range of values that can be assigned to a variable.
    
        enum flag { false, true };  // defines a data type
        enum flag endOfData;        // defines a variable of that type
    
    * You can assign numeric values to correspond to some enum identifiers:
    
        enum direction { up, down, left = 10, right }; // u=0, d=1, l=10, r=11
        enum boolean   { no = 0, false = 0, yes = 1, true = 1 };
        
    * You can explicitly assign an integer value to an enum data type variable, but you should do it with the cast operator.
    * You can leave out the name of the datatype and assign directly to a variable:
    
        enum { e, w, s, n } direction;
        
    * enumeration identifiers must be unique among similarly scoped identifiers
    
++++ THE typedef STATEMENT ++++

    * You can assign different names to data types with typedef:
    
        typedef int Counter;
        Counter j, n;
        
++++ DATA TYPE CONVERSIONS ++++

    * Conversion rules for expressions involving more than one datatype:
        - If a is type long double, b is type long double, return is long double
        - If a is type double, b is type double, return is double
        - If a is type float, b is float, return is float
        - If either is _Bool, char, short int or bit field, or enum, it is converted to type int
        - If a is type long long into, b is long long into, return is long long int
        - If a is long int, b is long int, return is long int
        - If you get here, you've got two ints, and the return is an int.
        
    * Signed ints have their sign extended to the left as they are transformed.
    * Some processors, like the iPhone's, will convert a char to a signed int, so define things as unsigned char for that platform.
    
++++ CATEGORIES ++++

    * Categories let you modularize the definition of a class into groups or categories of related methods, and gives an easy way to extend an existing class definition without having access to that class's source, and without subclassing.
    * The syntax in an interface section for categories is:
    
        @interface Fraction (MathOps)
        -(Fraction *) add: (Fraction *) f;
        -(Fraction *) mul: (Fraction *) f;
        -(Fraction *) sub: (Fraction *) f;
        -(Fraction *) div: (Fraction *) f;
        @end
        
        @implementation Fraction (MathOps)
            // code for category methods
        @end
        
    * Categories have access to the instance variables of the original class, but can't add any of their own.
    * Categories can override methods in the class, but probably shouldn't.
    * You don't have to implement all the methods in a category
    * Object/category named pairs must be unique within the Objective-C namespace
    
++++ PROTOCOLS ++++

    * A protocol is a list of methods that is shared among classes.
    * Methods in a protocol do not have implementations, and are meant to be implemented by someone else.
    * Defining a protocol looks like:
    
        @protocol NSCopying
        -(id) copyWithZone: (NSZone *) zone;
        @end
        
    * If you adopt a protocol, you define your interface to tell the compiler you're using the protocol:
    
        @interface AddressBook: NSObject <NSCopying>
        
    * From that, the compiler won't expect to see copyWithZone in the interface section, but it will expect to see it in the implementation
    * You can use a protocol to define methods that you want people who subclass your code to implement.
    * Protocols are classless--any class can conform to a protocol.
    * You can check to see whether something conforms to a protocol:
    
        if ([currentObject conformsToProtocol: @protocol (Drawing)] == YES) ...
        
    * You can tell the compiler a variable will hold objects that conform to a protocol:
    
        id <Drawing> currentObject;
        id <NSCopying, NSCoding> myDocument;
        
    * A protocol can extend an existing protocol:
    
        @protocol Drawing3D <Drawing>
        
    * A category can adopt a protocol:
    
        @interface Fraction (Stuff) <NSCopying, NSCoding>
        
    * Protocol names must be unique.
    
    * Some protocols are abstract / informal: they list methods in a category, but they don't implement them.  Helpful for modularization / documentation.
    
++++ COMPOSITE OBJECTS ++++

    * Composite objects are built from one or more objects from other classes.
    * As an alternative to subclassing you can create a composite object--it won't give access to the methods of a parent, because that class (which would have been the parent) is now an instance variable via an object.
    
        @interface Square: NSObject
        {
            Rectangle *rect;
        }
        -(int) setSide: (int) s;
        -(int) side;
        -(int) area;
        -(int) perimeter;
        @end
        
    * This will make the Square responsible for allocating the memory for the contained Rectangle object, so you need to override init or add a new method like initWithSide: to do the allocation.
    * For the same reason, you need to override dealloc to make sure the Rectangle object is released when the Square object is.
    
++++ THE PREPROCESSOR ++++
    
    * The preprocessor is a part of the compilation process that recognizes special statements that can be interspersed throughout a program.  
    * Preprocessor statements are identified by the presence of a # mark as the first non-space character on the line
    * Using the #define statement to set constants:
    
        #define TRUE    1
        #define FALSE   0
    
    * Constants are all caps or have lowercase k as the first letter
    * Definitions can contain complex expressions:
    
        #define TWO_PI 2.0 * 3.141592654
        
    * Definitions are used with direct replacement, so the expression doesn't have to be a single valid Objective-C expression, but it must work when placed in context.
    * Definitions can be configured to take arguments:
    
        #define IS_LEAP_YEAR(y) y % 4 == 0 && y % 100 != 0 || y % 400 == 0
        if ( IS_LEAP_YEAR (year) ) ...
    
    * Definitions are sometimes called macros. 
    * Macro for creating Fraction objects:
    
        #define MakeFract(x,y) ([[Fraction alloc] initWith: x over: y])
        myFract = MakeFract (1,3);
        
    * Macro for returning the max of two values:
    
        #define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )
        limit = MAX (x + y, minValue);
        
    * If you put a # in front of a parameter in a macro definition, the preprocessor creates a constant C-style string out of the macro argument when the macro is invoked.
    
        #define str(x) # x
        printf (str (Blah blah\n)); // converts to "Blah blah\n" in place
        #define printint(var) printf (# var " = %i\n", var)
        
    * The ## operator is used in macros to join two tokens.  It is preceded or followed by the name of a parameter to the macro.  The preprocessor takes the actual argument to the macro that is supplied when the macro is invoked and creates a single token out of that argument and whatever token follows or precedes the ##.
    
        #define printx(n)  printf ("%i\n", x ## n) 
        printx (20); // expands into printf("%i\n", x20);
        
    * You can use the #import statement to tell the preprocessor to include all your personal macros in a file.  Files of preprocessor instructions typically end with .h, and are header / include files
    
        #import "mymacros.h"  // looks in the project directory and other paths
        #import <Foundation/Foundation.h> // Looks in the system header file dir
        
++++ CONDITIONAL COMPILATION ++++

    * The preprocessor offers switches to let you compile different code for different systems.
    
        #ifdef MAC_OS_X
        #   define DATADIR "/uxn1/data"
        #else
        #   define DATADIR "\usr\data"
        #endif
        
    * You can define names like MAC_OS_X in code, or with a -D flag to gcc
    * Debugging lines:
    
        #ifdef DEBUG
            NSLog (@"User name = %s, id = %i", userName, userId);
        #endif
        
    * Additional statements:
    
        #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
        #define NSMaximumStringLength (INT_MAX-1)
        #elif 1
        #define NSMaximumStringLength (INT_MAX+1)
        #endif 
        
    * Removing a defined name:
    
        #undef name
        
++++ UNDERLYING C LANGUAGE FEATURES ++++

++++ ARRAYS ++++

    * Arrays are sequential storage with zero-indexed integer keys
    * Arrays must be declared before use, which means declaring the type of element to be stored in the array and the maximum size of the array.
    
        int *numbers [100]; // defines a 100 item integer array
        
    * Array elements can be initialized starting with the first element, like:
    
        numbers[5] = {0,1,2,3,4}; // sets numbers[0] to 0, numbers[1] to 1, etc.
        
    * You can set specific values of an array:
    
        int a[] = { [9] = 100, [2] = 3, [1] = 2, [0] = 1 }; // ten item array
        
    * Arrays can be defined without giving the number of elements (in objective c)
    * An array with no defined size is automatically sized to fit the initialization elements
    * If you put a terminating null character '\0' at the end of a character array, you create a string that can be used in a statement like:
    
        char word[] = {'H','e','l','l','o','\0'};
        NSLog (@"%s", word);
        
    * Multidimensional arrays are defined via statements like:
    
        int M[4][5] = {
            { 1, 2, 3, 4, 5},
            { 6, 7, 8, 9,10},
            {11,12,13,14,15},
            {16,17,18,19,20},
        };
        
    * Or this, which is equivalent:
    
        int M[4][5] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
        
++++ FUNCTIONS ++++

    * First line of a function definition tells the compiler:
        - Who can call it
        - The type of return value
        - Its name
        - The number and type of arguments it takes
        
    * Function definitions look like:
    
        void calculateTriangularNumber (int n)
        {
            int i, triangularNumber = 0;
            for (i = 1; i <= n; ++i)
                triangularNumber += i;
            NSLog(@"Triangular number %i is %i", n, triangularNumber);
        }
        
    * Functions are different from methods in that they are not attached to a class or object.
    * Function return type defaults to int, while method default return type is id
    * Default scope for functions is external, but they can be declared static
    * To pass an array to a function or method, pass it in by name
    
++++ STRUCTURES ++++

    * Structures group multiple pieces of data:
    
        struct date
        {
            int month;
            int day;
            int year;
        }
    
    * That declaration creates a new data type that can be used like
    
        struct date purchaseDate;
    
    * A member of a structure is accessed with the dot operator:
    
        purchaseDate.day = 21;
        
    * Structures are initialized in the following ways:
    
        struct date today = { 7, 2, 2011 }; // all three values
        struct date today = { 7 }; // just the first value
        struct date today = { .month = 7, .day = 2, .year = 2011 };
        struct date today = { .year = 2011 };
        
    * Nested structures are created like:
    
        struct date_and_time
        {
            struct date sdate;
            struct time stime;
        };
        
    * Their members are accessed via:
    
        struct.sdate.day = 21;
        
++++ BIT FIELDS ++++

    * You can pack information inside a special structure:
    
        struct packedStruct
        {
            unsigned int f1:1;
            unsigned int f2:1;
            unsigned int f3:1;
            unsigned int type:4;
            unsigned int index:9;
        };
        
    * The colon and number after the member name set the bit it corresponds to
    * There is no guarantee about whether objective-c will pack the bit field from left to right or right to left
    * Normal data can be included in a structure that includes bit fields:
    
        struct table_entry
        {
            int count;
            char c;
            unsigned int f1:1;
            unsigned int f2:1;
        }
    
    * A bit field with no name can be specified to cause some bits inside a storage unit to be skipped
    * A bit field with a size of 0 can be used to force the next bit field to align to a unit boundary.
    
++++ POINTERS ++++

    * Pointers provide an indirect means of accessing the value of a particular data item.
    * A pointer might look like:
    
        int count = 10;
        int *intPtr; // the * means it's an integer pointer data type
        intPtr = &count; // the & unary operator (the address op) makes a pointer
    
    * Assigning to a pointer like this:
    
        *intPtr = 20; // will set the value of the count variable, b/c * redirects
        
    * Using a pointer to a struct member requires wrapping your *pointer var in parens:
    
        struct date
        {
            int month;
            int day;
            int year;
        } todaysDate;
        struct date *datePtr = &todaysDate;
        (*datePtr).day = 21; // . has higher precendence than *, thus the parens
        
    * Pointers to structure members can also be accessed by the structure pointer operator:
    
        datePtr->day = 21;
        
    * Pointers can be supplied to functions and methods as arguments
    * Pointers to arrays are defined with the datatype that the array holds:
    
        int numbers[] = {1,2,3,4,5};
        int *numbersPtr = **numbers; // no & here because it would point to n[0]
        int *valuesPtr = numbers; // sets pointer to numbers[0]
        int *valuesPtr = &numbers[0]; // same thing but more verbose
        
    * To use an array pointer to sequence through an array:
    
        *(valuesPtr + 3) // is equal to numbers[3]
        valuesPtr += 1; // it's now a pointer to numbers[1]
        valuesPtr++; // numbers[2]
        valuesPtr--; // numbers[1] again
        
    * You can compare array pointers to find relative positions
    * Pointers to character strings are useful like so:
    
        // Version without pointers:
        void copyString (char to[], char from[])
        {
            int i;
            for (i = 0; from[i] != '\0'; ++i)
                to[i] = from[i];
            to[i] = '\0';
        }
        
        // Version with pointers:
        void copyString (char *to, char *from)
        {
            for ( ; *from != '\0'; ++from, ++to)
                *to = *from;
            *to = '\0';
        }
        
    * Auto-increment and auto-decrement can be used to pre-increment/decrement or post-increment/decrement with ++i vs i++.
    * This means that:
        
        *(++textPtr) // increments and then gets the character
        *(textPtr++) // gets the character and then increments
        
    * You can compare pointers, but additionally you can subtract them, and the result is the number of elements between the two pointers.
    * It is also possible to declare a pointer to a function:
    
        int doubler (int x)
        {
            return x * 2;
        }
        int (*fnPtr) (int);
        fnPtr = doubler;
        
++++ UNIONS ++++

    * A union allows you to store different types of data in the same storage area.
    
        union mixed
        {
            char c;
            float f;
            int i;
        };
    
    * Looks like a struct, but memory is allocated differently--where a struct would contain all three members, a union contains only one at a time, of any of the defined member types.
    * Pointers to unions work the same as pointers to structures.
    * Union initialization works like:
    
        union mixed x = { '#' }; // sets the first member to #
        union mixed x = {.f=123.4}; // sets the floating member
        
++++ COMPOUND LITERALS ++++

    * A compound literal is a type name enclosed in parentheses followed by an initialization list.  It creates an unnamed value of the specified type, with scope limited to the block it was created in.
    
        theDate = (struct date) { .month=7, .day=2, .year=2004}; // set up a var
        setStartDate((struct date) { .month=7, .day=2, .year=2004}); // pass to func
        
++++ THE goto STATEMENT ++++

    * Immediately branches to another part of the program via a label.
    
        LABEL_A: statement; // sets the label
        goto LABEL_A;       // goes to it
        
++++ THE null STATEMENT ++++        
    
    * You can put a semi-colon alone wherever a normal program statement would appear
    * equivalent to python's 'pass'
    
++++ THE COMMA OPERATOR ++++

    * Lowest precedence
    * separates statements in a for init, and elsewhere
    * returns the value of the rightmost operation
    
++++ THE sizeof OPERATOR ++++

    * Tells you the number of bytes being used to store something:
    
        sizeof (x) // gets the size of x
        sizeof (pointer) // gets the size of the pointer
        sizeof (*pointer) // gets the size of the thing the pointer is pointing to
        
++++ COMMAND LINE ARGUMENTS ++++

    * When the runtime system calls main, two args are passed to it.
    * argc is an integer value that gives the number of values from the command line
    * argv is an array of character pointers with argc+1 pointers in it
    * first pointer is to the name of the program or a null string
    * subsequent entries point to the values given on the same line
    * last pointer, argv[argc], is null
    * to access the CLI args, you have to declare main as follows:
    
        int main (int argc, char *argv[])
        
++++ HOW THINGS WORK ++++

    * Instance variables are stored in structures
    * An object variable is really a pointer
    * Methods are functions, and message expressions are function calls
    * The id type is a generic pointer type