# Notes on MySQL Shell 8.0 Reference Manual

From https://dev.mysql.com/doc/mysql-shell/8.0/en/

* Has functionality similar to the `mysql` CLI client, also gives scripting capabilities via Python and JS
* Has APIs for working with MySQL.
    * X DevAPI lets you work with both relational and document data
    * AdminAPI lets you work with InnoDB clueter

# Chapter 1: MySQL Shell Features

* Processes code in JavaScript, Python, and SQL
* Entered code processed as whatever the currently active language is
* Also uses MySQL Shell commands, which are slash commands like postgres
* From 8.0.18, uses Python 3
* Has an interactive code execution mode, REPL-like
* Can also take code from sources and do batch processing
* If you use the `--interactive` flag, batch processing will be done line by line, so you can use slash commands like you're in the interactive session
* Includes these APIs for developing code that interacts with MySQL:
    * X DevAPI - works with both relational and document data when connected using the X Protocol
    * AdminAPI lets you work with InnoDB cluster, which gives an integrated solution for HA and scalability
* Provides integrated command line client for all MySQL products that support X Protocol, and the legacy mysql protocol
* You can define extensions of the shell in the form of reports and extension objects, in JavaScript or Python. They can be persisted and loaded automatically on start. Has several built in reports.
* Has the following utilities for working with MySQL:
    * Upgrade checker util to verify whether MySQL instances are ready for upgrade
    * JSON import util to import JSON docs to a collection or tables. Use `util.importJSON()`
    * Parallel table import util that splits up a single data file and uses multiple threads to load the chunks into a mysql table
* Exposes a lot of functionality via an API command syntax that lets you easily integrate mysqlsh with other tools, like bash scripts
* Can return output as table, tabbed, vertical, or JSON output
* Can log info about the execution process at multiple detail levels
* Interaction with a MySQL server done through a Session object. For Python and JS, a Session can be created via `mysqlx.getSession()` Sessions are language specific, and cannot be used in SQL mode.
* For SQL mode, global session is supported. A global session is created when the connection info is passed to MySQL Shell using command options, or by `\connect`

# Chapter 2: Installing MySQL Shell

# Chapter 3: Using MySQL Shell Commands

* Commands that configure the MySQL Shell from the interactive code editor

## 3.1 MySQL Shell Commands

```
\help \h \?
\quit \q \exit
\                   begins multi-line mode in SQL mode
\status \s          show current shell status
\js                 switch to js execution
\py                 switch to py execution
\sql                switch to sql execution
\connect \c         connect to a server
\reconnect
\use \u             specify schema to use
\source \.          execute a script file in the active language
\warnings \W        show any warnings generated by a statement
\nowarnings \w      don't show warnings
\history            view and edit command line history
\rehash             manually update the autocomplete name cache
\option             query/change shell config options
\show               run specified report using provided options adn args
\watch              run the report, refresh at specified interval
\edit \e            Open a command in the default system editor
\system \!          run the specified OS command
```

# Chapter 4: Getting Started with MySQL Shell

## 4.1 Starting MySQL Shell

* Default call to `mysqlsh` with no args opens it with no connection, in javascript mode

## 4.2 MySQL Shell Connections

* Can connect using both X Protocol and MySQL protocol
* You can configure the MySQL server instance Shell is connected to by:
    * Using command params on Shell start
    * Using `\connect instancename` while running
    * In Python or JS mode, using `shell.connect('instancename')`
* All those ways support specifying the connection as follows:
    * As a URI-like string, like `myuser@example.com:3306/main-schema`
    * With kv pairs, like `(user:'myuser', host:'example.com', port:3306, schema:'main-schema')` in language-specific constructions (JSON or py dict)
* Defaults if not specified
    * user defaults to current system user name
    * host defaults to localhost
    * port defaults 33060 using X Protocol, 3306 for mysql protocol
* If a connection is lost, MySQL auto-retries reconnection
* You can use `\reconnect` to make the Shell try several times for the global session with the previously given params
* You can configure the timeout with `connect-timeout` connection param: `\connect user@example.com?connect-timeout=2000` (time is in MS)
* To enable compression for the connection: `\connect user@example.com?compression=true`
    * That allows compression of all info sent between client and server if possible.
    * Default is no compression.
    * Equivalent CLI param is `--compress` or `-C`
    * Available for classic MySQL protocol only
    * `\status` shows whether it's enabled for the session
* On unix, Shell connections default to using unix sockets if
    * A TCP port isn't given, or
    * A hostname isn't specified or is `localhost`, or
    * `--socket` or `-S` is specified, with or without a path to a socket file

### 4.2.1 Connecting using Individual Parameters

* `--user|-u`
* `--host|-h`
* `--port|-P`
* `--schema|--database|-D`
* `--socket|-S`

### 4.2.2 Using Encrypted Connections

* `--ssl` - deprecated in favor of `--ssl-mode`
* `--ssl-mode`
* `--ssl-ca=filename`
* `--ssl-capath=dir_name`
* `--ssl-cert=filename`
* `--ssl-cipher=name`
* `--ssl-key=filename`
* `--ssl-crl=name`
* `--ssl-crlpath=dir_name`
* `--tls-version=version`
* `--tls-ciphersuites=suites`

### 4.2.3 Connections in JavaScript and Python

* When a connection is made using the command options or by using any of the Shell commands, a global session object is created which can be used in any of the execution modes
* In JS or Python, any global session object is accessible via a variabled called `session`
* You can also establish new session objects and assign them to other variables
* You get them via
    * `mysqlx.getSession(connectionData[,password])`
    * `mysql.getClassicSession(connectionData[, password])`
* Code example:

    ```
    mysql-js> var session=mysqlx.getSession({host: 'localhost',
                                             user: 'root',
                                             password: 'password',
                                             ssl_ca: "path_to_ca_file",
                                             ssl_cert: "path_to_cert",
                                             ssl_key: "path_to_key"});
    ```

## 4.3 Pluggable Password Store

* You can persist the password for a server connection using a secret store like a keychain. 
* Once the password is stored, whenever Shell opens a session it retrieves the password from the configured Secret Store Helper to log in
* Same holds for scripts executed by Shell
* Built in support for secret stores:
    * MySQL login-path, requires having mysql client package installed
    * MacOS keychain
    * Windows API
* Automatic password storage and retrieval is performed when:
    * `mysqlsh` invoked with connection options, establishing a first session
    * you use `\connect`
    * you use `shell.connect()`
    * you use any AdminAPI methods requiring a connection

### 4.3.1 Pluggable Password Configuration Options

* Use the `shell.options` interface to configure the pluggable password store

### 4.3.2 Working with credentials

* Functions for working with the pluggable password store:
    * `shell.listCredentialHelpers()`
    * `shell.storeCredential(url[, password])`
    * `shell.deleteCredential(url)`
    * `shell.deleteAllCredentials()`
    * `shell.listCredentials()`

## 4.4 MySQL Shell Sessions

### 4.4.1 MySQL Shell Sessions Explained

* Following types of Session object are available
    * Session - use for new app development to communicate via X Protocol
    * ClassicSession - for non-X Protocol comms
* Creates a Session object by default
* You can configure the session object type using Shell command options, the `scheme` of a URI-like connection string, or by option to `\connect`
* CLI params:
    * `--mysqlx|--mx` - creates a Session
    * `--mysql|--mc` - creates a ClassicSession
* In URI like conn string:
    * `mysqlx` scheme or
    * `mysql` scheme
* Via Shell commands
    * `\connect --mysqlx|--mx URI`
    * `\connect --mysql|--mc URI`
* Via `shell.connect`:
    * `shell.connect('mysqlx://user@host')`

## 4.5 MySQL Shell Global Objects

* Has a number of built in global objects that are present in both JavaScript and Python:
    * `cluster` - represents an InnoDB cluster
    * `dba` - gives access to InnoDB cluster admin functions via AdminAPI
    * `session` - available when a global session exists
    * `db` - available via global session that uses a default db
    * `shell` - access to shell functions, like
        * `shell.options` - functions to set/unset shell preferences
        * `shell.reports` - built in or user defined Shell reports as functions
    * `util` - Shell tools

## 4.6 Using a Pager

* You can use an external pager like `less` or `more`
* Ways to configure:
    * `shell.options[pager] = ""`
    * Via `PAGER` env var
    * via `--pager` CLI param
    * via `\pager | \P` Shell command

# Chapter 5: MySQL Shell Code Execution

## 5.1 Active Language

* Three modes, switch with `\js`, `\py`, `\sql`
* Specify on command line with `--js`, `--py`, `--sql`
* Default is JavaScript
* From 8.0.16 you can execute one-off SQL commands even without switching modes, by doing `\sql SELECT 1;`

## 5.2 Interactive Code Execution

```javascript
var mySession = mysqlx.getSession('user:pwd@localhost');
var result = mySession.world_x.countryinfo.find().execute();
var record = result.fetchOne();
while(record) {
    print(record);
    record = result.fetchOne();
}
```

* CRUD commands only actually executed when `execute()` is called
* However, in interactive mode `execute()` is implicitly called when you hit `Return` after a statement
* Explicitly calling `execute()` is optional for:
    * `Collection.add()`
    * `Collection.find()`
    * `Collection.remove()`
    * `Collection.modify()`
    * `Table.insert()`
    * `Table.select()`
    * `Table.delete()`
    * `Table.update()`
* Automatic execution disabled if the object is assigned to a variable
* When a line is processed and the function returns any of the available `Result` objects, the info in the Result object is automatically displayed on screen
* Functions that return a Result:
    * SQL execution and CRUD operations (listed above)
    * Transaction handling and drop functions of the session objects in both session types:
        * `startTransaction()`
        * `commit()`
        * `rollback()`
        * `dropSchema()`
        * `dropCollection()`
        * `ClassicSession.runSql()`
* Multi-line support is automatic in Python or JS mode for block statements
* In SQL mode multi-line starts when the command `\\` (single slash) is issued

    ```
    mysql-sql> \
    ... create procedure get_actors()
    ... begin
    ...   select first_name from sakila.actor;
    ... end
    ```

## 5.3 Code Autocompletion

* Tab supports autocomplete in any language mode
* Supports these text objects:
    * SQL mode: schema names, table names, column names in current schema
    * JS/PY modes, aware of object members:
        * global object names
        * members of global objects
        * global user defined variables
        * chained object property references like `shell.options.verbose`
        * chained X DevAPI method calls like `col.find().where().execute().fetchOne()`
* On by default. Acts like normal shell autocomplete--one possible, completes it, multiple possible, displays all
* In SQL mode, will autocomplete
    * SQL keywords
    * SQL snippets like `SHOW CREATE TABLE`
    * Table names for active schema, if db name caching not disabled
* As an exception, if a backtick is found only table names are considered for completion.
* It's not context aware, so there's no filtering of completion based on SQL grammar
* In JS and Python modes, string to be completed is determined right to left, beginning at current cursor position when tab is pressed.
* Contents in method calls are ignored but must be syntactically correct
* Strings, comments, and nested method calls must be properly closed and balanced, to allow chained methods to be handled properly.
* To disable autocomplete:
    * Start with `--no-name-cache`
    * Modify the `autocomplete.nameCache` and `devapi.dbObjectHandles` keys of the `shell.options` object during runtime
* If disabled, you can manually update the text objects autocomplete is aware of by using `\rehash`, which forces a reload of the name cache based on the currently active schema.

## 5.4 Editing Code

* The `\edit` command (available from 8.0.18 forward) opens a command in the default system editor, then presents the edited command in Shell for execution
* 

