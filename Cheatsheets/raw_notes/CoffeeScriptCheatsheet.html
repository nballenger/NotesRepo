<DOCTYPE html>
<html lang="en">
  <head>
    <title>CoffeeScript Cheatsheet</title>
    <style type="text/css">
    section { padding-left: 20px; border: 1px solid silver; margin-bottom: 10px; padding-right: 20px; }
    </style>
  </head>
  <body>
    <article id="coffeescript-cheatsheet">
      <header>
        <h1>CoffeeScript Cheatsheet</h1>
      </header>
      
      <section id="syntax">
        <header>
          <h2>Syntax</h2>
        </header>
        
        <section>
          <header>
            <h3>General Rules</h3>
          </header>
          <ul>
            <li>File must be pure coffeescript</li>
            <li>No semicolons</li>
            <li>Comments start with a hash</li>
            <li>Multiline comments are enclosed in <code>###</code></li>
            <li>White space is significant</li>
            <li>Curly brackets replaced with a tab</li>      
          </ul>
        </section>
        
        <section>
          <header>      
            <h3>Functions</h3>
          </header>
          
          <section>
            <header>
              <h4>Function Definition</h4>
            </header>
            <ul>
              <li>function keyword is replaced with <code>-&gt;</code></li>
              <li>You can do oneliners or indented blocks:
<pre>func = -&gt; "bar"
func = -&gt;
    "bar"</pre>
              </li>
        
              <li>Arguments are specified before the arrow:
<pre>times = (a, b) -&gt; a * b
times = (a = 1, b = 2) -&gt; a * b</pre>
              </li>
            
              <li>Use a splat (...) to accept multiple args:
<pre>sub = (nums...) -&gt;
    result = 0
    nums.foreach (n) -&gt; result += n
    result</pre>
              </li>
            </ul>
          </section>
          
          <section>
            <header>    
              <h4>Function Invocation</h4>
            </header>
            <ul>
              <li>with parens, apply() or call()</li>
              <li>Will automatically call if they're invoked with at least one arg</li>
              <li>parens are optional, but recommended</li>
              <li>with no arguments, you must use parens to invoke</li>
            </ul>
          </section>
          
          <section>
            <header>        
              <h4>Function Context</h4>
            </header>
            <ul>
              <li>Helper syntax: the fat arrow <code>=&gt;</code></li>
              <li>Using <code>=&gt;</code> ensures the function context will be bound to the local one:
<pre>this.clickHandler = -&gt; alert "clicked"
element.addEventListener "click", (e) =&gt; this.clickHandler(e)</pre>
              </li>

              <li>Similar to jQuery's <code>proxy()</code></li>
              <li>Lets you avoid <code>self = this</code> type stuff</li>
            </ul>
          </section>
        </section>
        
        <section>      
          <header>
            <h3>Data Structures</h3>
          </header>
          
          <section>
            <header>      
              <h4>Arrays</h4>
            </header>
            <ul>
              <li>Arrays can use whitespace instead of commas, though square brackets are required:        
<pre>array1 = [1,2,3]
array2 = [
    1
    2
    3
]
array3 = [1,2,3,]</pre>        
              </li>
              
              <li>Coffeescript will strip trailing commas in array defs</li>

              <li>Lets you use ranges separated by <code>..</code> or <code>...</code></li>
              
              <li>A range with no prefix will expand into an array:
<pre>range = [1..5]</pre>
              </li>
              
              <li>If the range is specified after a variable, it's converted into a call to <code>slice()</code> on the array:
<pre>firstTwo = ["one, "two, "three"][0..1]</pre>
              </li>
        
              <li>You can use the syntax to replace an array segment with another array:
<pre>numbers = [0..9]
numbers[3..5] = [-3, -4, -5]</pre>
              </li>
        
              <li>You can also use ranges with a string to return a subset:
<pre>my = "my string"[0..1]</pre>
              </li>
              
              <li>You can search for a value in an array with <code>in</code>:
<pre>words = ["rattled", "roudy", "rebbles", "ranks"]
alert "Stop wagging me" if "ranks" in words</pre>
              </li>        
            </ul>
          </section>
          
          <section>
            <header>
              <h4>Object Literal Definition</h4>
            </header>
            <ul>
              <li>Syntax is the same as in JS, though braces are optionally replaced with indentation and new lines can replace commas:
<pre>object1 = {one: 1, two: 2}
object2 = one: 1, two: 2
object3 = 
    one: 1
    two: 2
User.create(name: "John Smith")</pre>
              </li>        
            </ul>
          </section>
        </section>
      
        <section>
          <header>
            <h3>Flow Control</h3>
          </header>
          
          <section>
            <header>
              <h4>Conditionals</h4>
            </header>
            <ul>
              <li>Optional parens with if and else:
<pre>if true == true
    "We're Ok"
    
if true != true then "Panic"</pre>
              </li>
              <li><code>then</code> lets you know in a one liner where the block begins</li>
              <li>You can't use the ternary operator</li>
              <li>Allows suffixed if statements:
<pre>alert "It's cold!" if heat &lt; 5</pre>
              </li>
              <li>You can use either <code>!</code> or <code>not</code> for negation:
<pre>if not true then "Panic"</pre>
              </li>
        
              <li>Also has an unless statement:
<pre>unless true
    "Panic"</pre>
              </li>
        
              <li>Uses <code>is</code> to mean <code>===</code>:
<pre>if true is 1
    "Type coercion fail!"</pre>
              </li>
        
              <li>You can use <code>isnt</code> to mean 'is not':
<pre>if true isnt true
    alert "Opposite day!"</pre>
              </li>
            </ul>
          </section>
          
          <section>
            <header>
              <h4>Loops</h4>
            </header>            
            <ul>
              <li>Iteration syntax:
<pre>for name in ["Roger", "Roderick", "Brian"]
    alert "Release #{name}"</pre>
              </li>
        
              <li>Current iteration index by passing in a variable:
<pre>for name, i in ["Roger the pickpocket", "Roderick the robber"]
    alert "#{i} - Release #{name}"</pre>
              </li>
        
              <li>You can iterate on one line with the postfix form:
<pre>release prisoner for prisoner in ["Roger", "Roderick", "Brian"]</pre>
              </li>
        
              <li>You can filter, like python comprehensions:
<pre>prisoners = ["Roger", "Roderick", "Brian"]
release prisoner for prisoner in prisoners when prisoner[0] is "R"</pre>
              </li>
        
              <li>You can use comprehensions for iterating over properties in objects:
<pre>names = sam: seaborn, donna: moss
alert("#{first} #{last}") for first, last of names</pre>
              </li>
              
              <li><code>while</code> is very similar to pure js, but returns an array like <code>map()</code>:
<pre>num = 6
minstrel = while num -= 1
    num + " Brave Sir Robin ran away"</pre>
              </li>
            </ul>
          </section>
        </section>
        
        <section>
          <header>
            <h3>Strings</h3>
          </header>
      
          <section>
            <header>
              <h4>String Interpolation</h4>
            </header>
            <ul>
              <li>Uses Ruby style string interpolation.</li>
              <li>Double quoted strings can have #{} tags, containing interpolatable strings:
<pre>favorite_color = "Blue. No, yel..."
question = "Bridgekeeper: What... is your favorite color?
            Galahad: #{favorite_color}
            Bridgekeeper: Wrong!
            "</pre>
              </li>
              <li>You can use multiple lines without connecting with a +</li>
            </ul>
          </section>
        </section>
        
        <section>
          <header>
            <h3>Aliases and the Existential Operator</h3>
          </header>
          <ul>
            <li><code>@</code> can be used as an alias for <code>this</code>
<pre>@savior = true</pre>
            </li>
          
            <li><code>::</code> is an alias for <code>prototype</code>:
<pre>User::first = -&gt; @records[0]</pre>
            </li>
        
            <li>CS replaces null checks using <code>if</code> with a <code>?</code> existential operator</li>

            <li><code>?</code> returns <code>true</code> unless a variable is null or undefined:
<pre>praise if brian?</pre>
            </li>
        
            <li>Can also be used in place of <code>||</code>:
<pre>velocity = southern ? 40</pre>
            </li>
        
            <li>If you put <code>?</code> before accessing a property, it'll do a null check:
<pre>blackKnight.getLegs()?.kick()</pre>
            </li>
        
            <li>You can check that a property is a function and callable by putting <code>?</code> right before the parens--if it's not a function or not callable it just won't get called:
        
<pre>blackKnight.getLegs().kick?()</pre>      
            </li>
          </ul>
        </section>
        
        <section>
          <header>          
            <h3>Classes</h3>
          </header>
          
          <section>
            <header>
              <h4>General Class Info</h4>
            </header>            
            <ul>
              <li>Behind the scenes it's prototype based, but you use the class keyword:
<pre>class Animal
animal = new Animal</pre>
              </li>
              <li>Constructors are defined with <code>constructor</code>:
<pre>class Animal
    constructor: (name) -&gt;
        @name = name</pre>
              </li>
        
              <li>If you prefix an argument with <code>@</code>, CS will set the arguments as instance properties in the constructor:
<pre>class Animal
    constructor: (@name) -&gt;</pre>
              </li>
        
              <li>Arguments passed on instantiation are proxied to the constructor:
<pre>animal = new Animal("Parrot")
alert "Animal is a #{animal.name}"</pre>
              </li>
            </ul>
          </section>
          
          <section>
            <header>
              <h4>Instance Properties</h4>
            </header>          
            <ul>
              <li>Adding instance properties is the same syntax as adding properties</li>
              <li>Make sure properties are indented correctly inside the class body:
<pre>class Animal
    price: 5
    sell: (customer) -&gt;
    
animal = new Animal
animal.sell(new Customer)</pre>
              </li>
        
              <li>If you use a fat arrow (<code>=&gt;</code>) in an instance method, it'll always invoke in the correct context, and 'this' will always refer to the current instance:
<pre>class Animal
    price: 5
    
    sell: =&gt;
        alert "Give me #{@price} shillings!"
        
animal = new Animal
$("#sell").click(animal.sell)</pre>
              </li>
        
              <li>Particularly useful in event callbacks--in the above, normally sell() would get invoked in the context of #sell (#sell would be 'this'), but the fat arrow ensures it executes in the context of the animal object</li>
            </ul>
          </section>
          <section>
            <header>
              <h4>Static Properties</h4>
            </header>            
            <ul>
              <li>Inside a class definition, <code>this</code> refers to the class object</li>
              <li>You can set class properties directly on <code>this</code>:    
<pre>class Animal
    this.find = (name) -&gt;
    
Animal.find("Parrot")</pre>
              </li>
        
              <li>You can also use <code>@</code> as an alias for this to write static properties:    
<pre>class Animal
    @find: (name) -&gt;
    
Animal.find("Parrot")</pre>
              </li>
            </ul>    
          </section>
          
          <section>
            <header>
              <h4>Inheritance and Super</h4>
            </header>
            <ul>
<li>You can inherit from another class using the <code>extends</code> keyword:

<pre>class Animal
    constructor: (@name) -&gt;
    
    alive: -&gt;
        false
        
class Parrot extends Animal
    constructor: -&gt;
        super("Parrot")
        
    dead: -&gt;
        not @alive()</pre>
</li>
<li><code>super()</code> is turned into a function call on the class's parent prototype</li>
<li>In practice it's the same as super in Python, invoking the overwritten
inherited function</li>
<li>Unless you override <code>constructor</code>, CS will invoke the parent's constructor</li>
<li>CS uses prototypal inheritance to automatically inherit all of a class's
instance properties</li>
<li>Classes are dynamic--if you add properties to a parent class after a
child has been created, the property will still be propagated to all 
inherited children:

<pre>class Animal
    constructor: (@name) -&gt;
    
class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip</pre>
            </li>

            <li>Note: static properties are copied to subclasses, rather than inherited    </li>
            </ul>
          </section>  
          
          <section>
            <header>
              <h4>Mixins</h4>
            </header>
            <ul>
              <li>Not natively supported by CoffeeScript, but easy to implement</li>
              <li>Example of two functions, <code>extend()</code> and <code>include()</code> that'll add class and instance properties respectively to a class:
        
<pre>extend = (obj, mixin) -&gt;
    obj[name] = method for name, method of mixin
    obj
    
include = (klass, mixin) -&gt;
    extend klass.prototype, mixin
    
# Usage
include Parrot,
    isDeceased: true
    
(new Parrot).isDeceased</pre>
              </li>

              <li>Lets you share common logic between modules when inheritance doesn't work</li>
              <li>You can use multiple mixins, compared to one inheritable class            </li>
            </ul>
          </section>
          <section>
            <header>
              <h4>Extending Classes</h4>
            </header>
            <ul>
              <li>Going to define a class Module that we can inherit from for mixin support</li>
              <li>Will have two static functions, <code>@extend()</code> and <code>@include()</code>:

<pre>moduleKeywords = ['extended', 'included']

class Module
    @extend: (obj) -&gt;
        for key, value of obj when key not in moduleKeywords
            # Assign properties to the prototype
            @::[key] = value
            
        obj.included?.apply(@)
        this</pre>
              </li>

              <li>moduleKeywords makes sure you have callback support when mixins extend a class:
<pre>classProperties = 
    find: (id) -&gt;
    create: (attrs) -&gt;
    
instanceProperties =
    save: -&gt;
    
class User extends Module
    @extend classProperties
    @include instanceProperties
    
# Usage:
user = User.find(1)</pre>
              </li>

              <li>Since we've got callbacks whenever modules are extended, we can shortcut the process of applying both static and instance properties:
        
<pre>ORM =
    find: (id) -&gt;
    create: (attrs) -&gt;
    extended: -&gt;
        @include
            save: -&gt;
            
class User extendes Module
    @extend ORM</pre>
              </li>
            </ul>
          </section>
        </section>        
      </section><!-- /#syntax -->
      <section id="idioms">
        <header>
          <h2>CoffeeScript Idioms</h2>
        </header>

        <section>
          <header>
            <h3>Each</h3>
          </header>
          <ul>
            <li>In pure JS you could use forEach() or a for loop to iterate an array</li>
            <li>In CS you can use this:
<pre>myFunction(item) for item in array</pre>
            </li>
          </ul>
        </section>

        <section>
          <header>
            <h3>Map</h3>
          </header>
          <ul>
            <li>CS comprehensions can produce map() behavior, though you MUST surround the comprehension in parens to get a mapped array back:
                    
<pre>result = (item.name for item in array)</pre>
            </li>
          </ul>
        </section>

        <section>
          <header>
            <h3>Select</h3>
          </header>
          <ul>
            <li>JS 5 has a <code>filter()</code> function for reducing arrays:
<pre>var result = []
for (var i = 0; i &lt; array.length; i++)
    if (array[i].name == "test")
        result.push(array[i])
        
result = array.filter(function(item, i){
    return item.name == "test"
});</pre>
            </li>
            <li>CS's syntax uses the 'when' keyword to filter items with a comparison, which compiles to a for loop executed in an anonymous function:
        
<pre>result = (item for item in array when item.name is "test")</pre>
            </li>

            <li>Complex selections with comprehensions:
    
<pre>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [...]

# Or
passed = (score for score in scores when score &gt; 60)</pre>
            </li>

            <li>Multi-line comprehension:
    
<pre>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
    (if score &gt; 60 then passed else failed).push score</pre>
            </li>
          </ul>
        </section>

        <section>
          <header>
            <h3>Includes</h3>
          </header>
          <ul>
            <li>To check inside an array you have to use <code>indexOf()</code>, which requires a shim because IE hasn't implemented it</li>
            <li>In CS, you can use:
<pre>included = "test" in array</pre>
            </li>

            <li>CS uses <code>Array.prototype.indexOf()</code>, shimming if necessary</li>
            <li>The syntax won't work for strings:
    
<pre>included = "a long test string".indexOf("test") isnt -1</pre>
        
    * Or use the bitwise operator to avoid the -1 comparison
    
        string = "a long test string"
        included = !!~ string.indexOf "test"
      </section>
    </article>
  </body>
</html>
